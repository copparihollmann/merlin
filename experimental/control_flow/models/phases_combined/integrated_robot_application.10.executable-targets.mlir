#composite_of_8960b = #util.composite<8960xi8, [
    dense<"0xC33C46BD233AA03D8760E43DF310A3BD92EA023DDFFFFA3C3FB59CBDD67822BD657B11BE2E4CEEBD428D22BD46CC993D3076D8BD25E617BD5F6A8EBB21A71F3C9F7F80BD92A3FE3C723613BE77408B3D9251B13DCF91BFBDF9DA743DD64527BD639EB5BD68CB173D33409E3C1DDFA7BD3723DD3DF05AB9BCF96FE7BD4299C63D030B3A3D238ABBBCFBF0BC3D746E953DA3624D3C3065213D6DF8993CBF1588BD5115883C8A42E53AF62D0EBEE6A0DFBB684E123D953A313DE3220C3C419B17BDECF9CBBD0A518DBD93F5E6BDD33064BD1122F63D7F91023E7F8CE83D0153A63C624B9C3D96D3FABDCCB00DBE49488CBD147795BD5FDA12BE5B0F4BBD569FE0BD372A103E5ACA8A3CA12B9A3CC949703DE500CEBD67CBA9BDD8E8703B36DE92BDBCD80DBD0133053E6302033D8483A13B5FC4D5BDE3670CBECF09723DB12606BEC171D23DC993023C82E1B9BD8AA9AA3C39B0ABBDABC471BD29BC033EB5F06E3D80E30E3E8DA7D73DC70D5B3DD7F9F23BC14F93BD3EA8E33DF6F293BD558AE63C0F46CCBDBE2712BED055373D7EF5A73DF061B93DA792ACBD4CF702BECD2E18BC8B5EF4BDC4FABB3DC56C0A3EBC5FDA3DF4B408BDCBD6E43C765E0C3E42B85CBDC5C6FBBCBA5EF5BDE549E6BD347B0DBC83BF0EBD746DA4BC84A2E2BD36A4BEBDFC0CDDBDB05E7EBDCBB8383DD8B091BD4EDBB23C5A70F3BDE7B5D83D37E6AD3C68940EBD3AF579BDDB8E083EC064CC3CD7CAA43C15972B3DC6F16FBD35E99B3D4526683DD97395BA82FFF43C85E6C3BC93B88D3DFC2BA3BD30A6CE3D36411FBD80D71BBD33695B3DA7BAAC3DFC17E03D9B5C13BDFCF6D1BC3B988A3C185DE0BDC3ED03BC0B99993D9E1E613DA0DB2D3D3889FE3D9BB8AF3CF375AE3D68C98FBDDF570FBE3CB1063ED6D8693D89BDD93D5C95C73DFD9CAA3D3CA5033C1DCC9BBCD18D9C3CD8AC16BCF22914BD162811BDD87B67BD87DFBFBDD74EDBBCB6346FBD6B688BBD566703BE03ECE53D18578FBD7EA4D9BDF9FF05BE8B083CBD2786BCBD64FEF6BC8114093DB4D0F23BBD513DBC3D56E13C81CF82BC2F18FB3DD6AC58BD"> : tensor<4x3x4x4xf32>,
    dense<"0x9866223D00DADBBA0000000000000000000000000000000000000000000000003045FDBBBCDD46BD000000000000000000000000000000000000000000000000108D2DBDCEA10FBD000000000000000000000000000000000000000000000000886F0ABD9030AA3C000000000000000000000000000000000000000000000000189132BC7A62153D0000000000000000000000000000000000000000000000005008E9BCA070F1BC000000000000000000000000000000000000000000000000A81968BCF09CD03C0000000000000000000000000000000000000000000000000849B4BCC8CB4FBD00000000000000000000000000000000000000000000000082C26E3DC00B45BB00000000000000000000000000000000000000000000000064A8863CC21948BD000000000000000000000000000000000000000000000000D0AF2C3C489D333C000000000000000000000000000000000000000000000000905C813C3848A93C000000000000000000000000000000000000000000000000B8A20BBC60DF933B000000000000000000000000000000000000000000000000F866223C142BFF3C000000000000000000000000000000000000000000000000F082313D608241BB000000000000000000000000000000000000000000000000ECEEC2BC8E5A083D000000000000000000000000000000000000000000000000E8E157BC001279BB000000000000000000000000000000000000000000000000087710BCC24A3E3D000000000000000000000000000000000000000000000000DA705CBD00164CBA00000000000000000000000000000000000000000000000066B7253DC03A453C000000000000000000000000000000000000000000000000E60D6CBDD0695B3C000000000000000000000000000000000000000000000000705697BB9E06073D00000000000000000000000000000000000000000000000070668CBB1086D7BC000000000000000000000000000000000000000000000000A8D94A3D80E4DA3B000000000000000000000000000000000000000000000000905652BC605B18BC0000000000000000000000000000000000000000000000002CF8B6BCE617783D000000000000000000000000000000000000000000000000D6AC0BBD88A9C03C000000000000000000000000000000000000000000000000EC70243D5C34FE3C000000000000000000000000000000000000000000000000E0E0693BFCE232BD0000000000000000000000000000000000000000000000009041B43C4A0B5FBD0000000000000000000000000000000000000000000000009CB2D9BCA024083B000000000000000000000000000000000000000000000000285563BC5ABD24BD0000000000000000000000000000000000000000000000008872613CAEED71BD00000000000000000000000000000000000000000000000020B75DBCC02EEA3A000000000000000000000000000000000000000000000000F0CFB5BC38A60BBC000000000000000000000000000000000000000000000000768341BDE089653D0000000000000000000000000000000000000000000000008033C9BB80B3CFBB000000000000000000000000000000000000000000000000CA57763DE8E7113C000000000000000000000000000000000000000000000000BCDA22BD201BC43B0000000000000000000000000000000000000000000000006859183CE84964BD00000000000000000000000000000000000000000000000080CEC5BC8C616BBD0000000000000000000000000000000000000000000000008A0831BDEE1A74BD000000000000000000000000000000000000000000000000B86D513D30615E3D00000000000000000000000000000000000000000000000074EFD33CF8F322BD00000000000000000000000000000000000000000000000010CB61BCF000113D00000000000000000000000000000000000000000000000000EBF439ACCE8F3C0000000000000000000000000000000000000000000000005A0B3CBD064004BD00000000000000000000000000000000000000000000000096A4583DE0B8FA3C0000000000000000000000000000000000000000000000007877DC3C6CAEF6BC0000000000000000000000000000000000000000000000005C51973C541A4BBD0000000000000000000000000000000000000000000000000AB37C3DC086703D000000000000000000000000000000000000000000000000665B63BD7878123C000000000000000000000000000000000000000000000000E0E881BC00E5203A000000000000000000000000000000000000000000000000A0EC47BB941F513D00000000000000000000000000000000000000000000000070ED083CDEDD35BD000000000000000000000000000000000000000000000000882B5EBD9A02713D00000000000000000000000000000000000000000000000008E9903CBEDD493D00000000000000000000000000000000000000000000000062CB38BD10DDE53B000000000000000000000000000000000000000000000000781B033C1C289D3C00000000000000000000000000000000000000000000000092AC63BDC8D004BD00000000000000000000000000000000000000000000000012257FBDDE7E683D000000000000000000000000000000000000000000000000961F5B3D48533F3D000000000000000000000000000000000000000000000000F0B71A3D60996F3B000000000000000000000000000000000000000000000000F0B80C3C6C00313D000000000000000000000000000000000000000000000000AC59B13C64AA91BC000000000000000000000000000000000000000000000000D867C7BCF005D63B00000000000000000000000000000000000000000000000098B007BDB830BC3C00000000000000000000000000000000000000000000000080A7863A30FCF53B00000000000000000000000000000000000000000000000020CA6DBC800F073B00000000000000000000000000000000000000000000000030EC8D3C26F53BBD00000000000000000000000000000000000000000000000090B0CCBBB467763D000000000000000000000000000000000000000000000000960012BD927A083D000000000000000000000000000000000000000000000000D4E6913C1A0F0DBD0000000000000000000000000000000000000000000000006811183D92763F3D000000000000000000000000000000000000000000000000B8865EBD888B23BC00000000000000000000000000000000000000000000000064007A3D64E127BD0000000000000000000000000000000000000000000000007AF5423D70E313BD00000000000000000000000000000000000000000000000000B264BAC0D6FBBB0000000000000000000000000000000000000000000000005A2B3BBDBC39CBBC00000000000000000000000000000000000000000000000082762F3D50D5F23B0000000000000000000000000000000000000000000000006ECB673D182B6C3C000000000000000000000000000000000000000000000000E04D19BD0852183C0000000000000000000000000000000000000000000000002C42AEBC88C4F53C00000000000000000000000000000000000000000000000058AF88BC6E564CBD000000000000000000000000000000000000000000000000186B6A3C48690F3C000000000000000000000000000000000000000000000000B2E856BDF053133C0000000000000000000000000000000000000000000000000CA3FE3CAC638ABC0000000000000000000000000000000000000000000000009080B93C10EE3CBC000000000000000000000000000000000000000000000000A457EBBC341C28BD000000000000000000000000000000000000000000000000F03737BDE86A26BD0000000000000000000000000000000000000000000000000AFB32BD94B984BC000000000000000000000000000000000000000000000000E266473D0A9C5F3D000000000000000000000000000000000000000000000000A26D1BBDD0BF193D0000000000000000000000000000000000000000000000002C8D56BDAC0932BD00000000000000000000000000000000000000000000000098D1FABCE85BBBBC000000000000000000000000000000000000000000000000F0DF0A3C9C3CC9BC00000000000000000000000000000000000000000000000040DA5DBB846E67BD0000000000000000000000000000000000000000000000000E7E003D441A453D0000000000000000000000000000000000000000000000007423FB3C90D794BB00000000000000000000000000000000000000000000000008DDEA3CD457553D000000000000000000000000000000000000000000000000307B95BCE8D9173D00000000000000000000000000000000000000000000000080C2ED3C547CC2BC00000000000000000000000000000000000000000000000080F913BDD2496CBD000000000000000000000000000000000000000000000000F65A62BDA82079BC0000000000000000000000000000000000000000000000007C7EB63C54FD80BC000000000000000000000000000000000000000000000000088F65BDC6F2163D000000000000000000000000000000000000000000000000AC59263DBC0FE33C000000000000000000000000000000000000000000000000005AEA3BEE4C0F3D000000000000000000000000000000000000000000000000C022AA3AF8808C3C000000000000000000000000000000000000000000000000701C273C38F4B93C00000000000000000000000000000000000000000000000078B4113DA82133BC000000000000000000000000000000000000000000000000F8B84BBCDCE994BC000000000000000000000000000000000000000000000000483D0ABD4C52E6BC0000000000000000000000000000000000000000000000009480FBBC80DF923C000000000000000000000000000000000000000000000000BADE50BD8EE113BD0000000000000000000000000000000000000000000000000054603BA27526BD00000000000000000000000000000000000000000000000040655C3D4CAC5BBD00000000000000000000000000000000000000000000000094C39DBC32B81E3D000000000000000000000000000000000000000000000000083E7FBD60FCE93C00000000000000000000000000000000000000000000000090D20DBC402471BB00000000000000000000000000000000000000000000000054422ABD3CF4B03C000000000000000000000000000000000000000000000000046C0D3D1E4E2EBD000000000000000000000000000000000000000000000000AE945A3DB00400BD000000000000000000000000000000000000000000000000CACE59BD26A40D3D000000000000000000000000000000000000000000000000804F183D90B823BD000000000000000000000000000000000000000000000000404B0EBBF63444BD00000000000000000000000000000000000000000000000000B3DCBB4849693D00000000000000000000000000000000000000000000000080AF1E3BDE6827BD0000000000000000000000000000000000000000000000007E08143DACAF593D000000000000000000000000000000000000000000000000EC18CCBC3A7C513D000000000000000000000000000000000000000000000000DA4735BDE8FA5BBC000000000000000000000000000000000000000000000000B62506BD007D57BA0000000000000000000000000000000000000000000000008874F4BC00B08ABB0000000000000000000000000000000000000000000000005EC93CBDFEAF35BD000000000000000000000000000000000000000000000000E890723DE0C7F1BB000000000000000000000000000000000000000000000000C89A073D1856B13C0000000000000000000000000000000000000000000000003AE1513D86C6523D0000000000000000000000000000000000000000000000005E1760BD1CB8D63C00000000000000000000000000000000000000000000000060AF6D3D0803783C000000000000000000000000000000000000000000000000C8033C3DE6CB7DBD000000000000000000000000000000000000000000000000D0F40F3D90B9BDBB000000000000000000000000000000000000000000000000D0E4F8BC9E2C373D000000000000000000000000000000000000000000000000BE3731BDEE97733D000000000000000000000000000000000000000000000000C2873BBD9AE42BBD00000000000000000000000000000000000000000000000094E8163DCE1A65BD000000000000000000000000000000000000000000000000240AD6BC665950BD0000000000000000000000000000000000000000000000000CD84DBDDA49153D0000000000000000000000000000000000000000000000001E00393D4645733D000000000000000000000000000000000000000000000000523378BDC0BEF23C00000000000000000000000000000000000000000000000068BF6C3D46E94B3D000000000000000000000000000000000000000000000000E22F393D5898B2BC0000000000000000000000000000000000000000000000005CA4B2BCD6DB29BD000000000000000000000000000000000000000000000000127F07BD8CBE48BD0000000000000000000000000000000000000000000000004007BCBBF67739BD000000000000000000000000000000000000000000000000F077B63CE045C0BB000000000000000000000000000000000000000000000000B4AEA3BC7A060BBD00000000000000000000000000000000000000000000000026CA7BBDF0073E3C00000000000000000000000000000000000000000000000008B2323C06172B3D000000000000000000000000000000000000000000000000445267BDF0840CBD0000000000000000000000000000000000000000000000009CE672BD6CF0FD3C000000000000000000000000000000000000000000000000D08AFFBC901AC4BB0000000000000000000000000000000000000000000000008E8A1EBDE0DD37BC000000000000000000000000000000000000000000000000586515BD76987EBD00000000000000000000000000000000000000000000000000317D3BE0AB653D0000000000000000000000000000000000000000000000008818D3BC205A6DBD0000000000000000000000000000000000000000000000007850E93CF0108ABB0000000000000000000000000000000000000000000000002833B83C9E776D3D0000000000000000000000000000000000000000000000006C9615BD82AF663D0000000000000000000000000000000000000000000000003C491BBD00F33ABA000000000000000000000000000000000000000000000000E0A812BDECF8ABBC00000000000000000000000000000000000000000000000008BCBE3CD6FD00BD000000000000000000000000000000000000000000000000AC09BE3C889153BD000000000000000000000000000000000000000000000000A8113F3DF8C9203D000000000000000000000000000000000000000000000000ACA0FD3CE0744ABB000000000000000000000000000000000000000000000000D46773BD70FA88BB000000000000000000000000000000000000000000000000BAE20EBD60C8CF3B000000000000000000000000000000000000000000000000806960BC1628423D000000000000000000000000000000000000000000000000527A7F3D20223CBD000000000000000000000000000000000000000000000000E2AD583DB4CFE13C0000000000000000000000000000000000000000000000000CAC803C1E24043D00000000000000000000000000000000000000000000000050BEC2BC001824B8000000000000000000000000000000000000000000000000908101BD0056B7BC000000000000000000000000000000000000000000000000A49C5D3DFA6B473D000000000000000000000000000000000000000000000000C093793B406C28BC000000000000000000000000000000000000000000000000E27F0D3DD0D9A43B000000000000000000000000000000000000000000000000609AA0BCFA6E45BD00000000000000000000000000000000000000000000000094012CBDC0B8163B0000000000000000000000000000000000000000000000007CADCABC90DD60BC00000000000000000000000000000000000000000000000050B01FBDB4678FBC000000000000000000000000000000000000000000000000E0BBA7BBE06CC13C00000000000000000000000000000000000000000000000086571ABD562B2B3D0000000000000000000000000000000000000000000000000C84D73C709D3E3C000000000000000000000000000000000000000000000000F8B452BCC45AC9BC0000000000000000000000000000000000000000000000008C25F1BCC8342FBD000000000000000000000000000000000000000000000000CCA7663D0C880FBD000000000000000000000000000000000000000000000000EE4F733DD67B6C3D000000000000000000000000000000000000000000000000801D17BA225F39BD00000000000000000000000000000000000000000000000000F4E8BBF053A1BB0000000000000000000000000000000000000000000000007E201ABD803063BC0000000000000000000000000000000000000000000000009ED961BD1048A93B0000000000000000000000000000000000000000000000004CE180BC4A5378BD000000000000000000000000000000000000000000000000FE5776BDB0E0383C0000000000000000000000000000000000000000000000009420EDBC14AA33BD0000000000000000000000000000000000000000000000004ABA55BDCC45E3BC0000000000000000000000000000000000000000000000001002093D865A2FBD000000000000000000000000000000000000000000000000E06D4A3CBE48293D000000000000000000000000000000000000000000000000A6E64E3DDCE5153D000000000000000000000000000000000000000000000000426E49BDE055BF3C00000000000000000000000000000000000000000000000004F224BD283C4BBD000000000000000000000000000000000000000000000000E861D4BC809156BD000000000000000000000000000000000000000000000000F637783DFE375DBD00000000000000000000000000000000000000000000000078610E3D04B5E3BC00000000000000000000000000000000000000000000000092B6663D828577BD0000000000000000000000000000000000000000000000003C8B8E3CC4F9C43C000000000000000000000000000000000000000000000000AA0D7B3DA45E143D0000000000000000000000000000000000000000000000004061BEBC62705C3D0000000000000000000000000000000000000000000000004007613DC0C8273C000000000000000000000000000000000000000000000000C0172A3BA8EEB13C0000000000000000000000000000000000000000000000005E164ABDD8B75DBD000000000000000000000000000000000000000000000000A0CA13BC1CB8E63C0000000000000000000000000000000000000000000000006AF70A3DA65475BD000000000000000000000000000000000000000000000000B0EB40BCC0B9373D000000000000000000000000000000000000000000000000B452CE3C349F593D0000000000000000000000000000000000000000000000004E47733D00B26EBC00000000000000000000000000000000000000000000000042435ABDAA30733D0000000000000000000000000000000000000000000000007096883C9A1F103D000000000000000000000000000000000000000000000000045CE9BCEE4C73BD000000000000000000000000000000000000000000000000D81EC23C20CFFD3C000000000000000000000000000000000000000000000000A0D79F3C6E6D4BBD0000000000000000000000000000000000000000000000000CBF243DF04DA6BB0000000000000000000000000000000000000000000000002053EFBCE489773D0000000000000000000000000000000000000000000000004C2FAEBC40438CBA00000000000000000000000000000000000000000000000024B4E9BCB863FF3C000000000000000000000000000000000000000000000000CC30673D8869603D00000000000000000000000000000000000000000000000020505BBB706FC83C00000000000000000000000000000000000000000000000040B191BB94A6663D0000000000000000000000000000000000000000000000005E25723D740E413D00000000000000000000000000000000000000000000000084F3803CB09AFA3B000000000000000000000000000000000000000000000000FA87053DA8ED323D000000000000000000000000000000000000000000000000A0A1043B546400BD000000000000000000000000000000000000000000000000FC9F89BC7CC703BD000000000000000000000000000000000000000000000000AC72EE3C58CD2F3C0000000000000000000000000000000000000000000000002831F53CA879B53C000000000000000000000000000000000000000000000000120857BD3C6B6A3D000000000000000000000000000000000000000000000000C06F903A00F9DFBB000000000000000000000000000000000000000000000000101184BCCA8530BD000000000000000000000000000000000000000000000000C8540F3D306B313D000000000000000000000000000000000000000000000000F4D19A3C367A033D000000000000000000000000000000000000000000000000CAA0673DB03678BD000000000000000000000000000000000000000000000000C4A9C0BCE8A616BD000000000000000000000000000000000000000000000000FC750ABDC03E9C3B00000000000000000000000000000000000000000000000040FA71BB7C4A8ABC00000000000000000000000000000000000000000000000064229ABC14AF7EBD000000000000000000000000000000000000000000000000C4E2E43C10EA953C00000000000000000000000000000000000000000000000036661DBDF6C62B3D000000000000000000000000000000000000000000000000581F3F3D5853BD3C000000000000000000000000000000000000000000000000"> : tensor<1x256x8x1xf32>,
]>
#executable_target_embedded_elf_x86_64 = #hal.executable.target<"llvm-cpu", "embedded-elf-x86_64", {cpu = "znver3", cpu_features = "+prfchw,-cldemote,+avx,+aes,+sahf,+pclmul,-xop,+crc32,-amx-fp8,+xsaves,-avx512fp16,-usermsr,-sm4,-egpr,+sse4.1,-avx512ifma,+xsave,+sse4.2,-tsxldtrk,-sm3,-ptwrite,-widekl,-movrs,+invpcid,+64bit,+xsavec,-avx10.1-512,-avx512vpopcntdq,+cmov,-avx512vp2intersect,-avx512cd,+movbe,-avxvnniint8,-ccmp,-amx-int8,-kl,-avx10.1-256,-sha512,-avxvnni,-rtm,+adx,+avx2,-hreset,-movdiri,-serialize,+vpclmulqdq,-avx512vl,-uintr,-cf,+clflushopt,-raoint,-cmpccxadd,+bmi,-amx-tile,+sse,-avx10.2-256,-gfni,-avxvnniint16,-amx-fp16,-zu,-ndd,+xsaveopt,+rdrnd,-avx512f,-amx-bf16,-avx512bf16,-avx512vnni,-push2pop2,+cx8,-avx512bw,+sse3,+pku,-nf,-amx-tf32,-amx-avx512,+fsgsbase,+clzero,+mwaitx,-lwp,+lzcnt,+sha,-movdir64b,-ppx,+wbnoinvd,-enqcmd,-amx-transpose,-avx10.2-512,-avxneconvert,-tbm,-pconfig,-amx-complex,+ssse3,+cx16,+bmi2,+fma,+popcnt,-avxifma,+f16c,-avx512bitalg,+rdpru,+clwb,+mmx,+sse2,+rdseed,-avx512vbmi2,-prefetchi,-amx-movrs,+rdpid,-fma4,-avx512vbmi,+shstk,+vaes,-waitpkg,-sgx,+fxsr,-avx512dq,+sse4a", data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", iree.encoding.resolver = #iree_cpu.cpu_encoding_resolver<>, max_stack_allocation_size = 32768 : i64, native_vector_size = 32 : i64, target_triple = "x86_64-unknown-unknown-eabi-elf"}>
#pipeline_layout = #hal.pipeline.layout<bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, Indirect>, #hal.pipeline.binding<storage_buffer, Indirect>, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#pipeline_layout1 = #hal.pipeline.layout<bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#pipeline_layout2 = #hal.pipeline.layout<bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, ReadOnly>, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#pipeline_layout3 = #hal.pipeline.layout<bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#device_target_local = #hal.device.target<"local", [#executable_target_embedded_elf_x86_64]> : !hal.device
module @integrated_robot_application attributes {stream.affinity.default = #hal.device.affinity<@__device_0>} {
  util.global private @__device_0 = #device_target_local
  util.func public @main$async(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.fence, %arg5: !hal.fence, %arg6: !hal.fence, %arg7: !hal.fence) -> (!hal.buffer_view, !hal.buffer_view) attributes {iree.abi.stub, iree.reflection = {iree.abi.declaration = "async func @main$async(%input0: !hal.buffer_view, %input1: !hal.buffer_view, %input2: !hal.buffer_view, %input3: !hal.buffer_view, %input4: !hal.fence, %input5: !hal.fence) -> (%output0: !hal.buffer_view, %output1: !hal.buffer_view)", iree.abi.model = "coarse-fences"}} {
    %0:2 = util.call @_main$async(%arg0, %arg1, %arg2, %arg3, %arg4, %arg5) : (!hal.buffer_view, !hal.buffer_view, !hal.buffer_view, !hal.buffer_view, !hal.fence, !hal.fence) -> (!hal.buffer_view, !hal.buffer_view)
    hal.fence.signal<%arg7 : !hal.fence>
    util.return %0#0, %0#1 : !hal.buffer_view, !hal.buffer_view
  }
  hal.executable private @_main$async_dispatch_0 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_0_elementwise_broadcast ordinal(0) layout(#pipeline_layout) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        hal.return %c1, %c1, %c1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_0_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(8 : i64) : i64
          %1 = llvm.mlir.constant(32 : i64) : i64
          %2 = llvm.mlir.constant(64 : index) : i64
          %3 = llvm.mlir.constant(true) : i1
          %4 = llvm.mlir.constant(2 : i32) : i32
          %5 = llvm.mlir.constant(0 : i32) : i32
          %6 = llvm.mlir.constant(1 : i32) : i32
          %7 = llvm.mlir.constant(3 : i32) : i32
          %8 = llvm.mlir.constant(-2.59630184E-7 : f32) : f32
          %9 = llvm.mlir.constant(2.47562348E-5 : f32) : f32
          %10 = llvm.mlir.constant(-0.00138883304 : f32) : f32
          %11 = llvm.mlir.constant(0.0416666418 : f32) : f32
          %12 = llvm.mlir.constant(-5.000000e-01 : f32) : f32
          %13 = llvm.mlir.constant(-2.50293279E-8 : f32) : f32
          %14 = llvm.mlir.constant(2.76001265E-6 : f32) : f32
          %15 = llvm.mlir.constant(-1.98426045E-4 : f32) : f32
          %16 = llvm.mlir.constant(0.00833334774 : f32) : f32
          %17 = llvm.mlir.constant(-0.166666672 : f32) : f32
          %18 = llvm.mlir.constant(-1.000000e+00 : f32) : f32
          %19 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %20 = llvm.mlir.constant(1.57079637 : f32) : f32
          %21 = llvm.mlir.constant(0.636619746 : f32) : f32
          %22 = llvm.mlir.constant(9.99999974E-5 : f32) : f32
          %23 = llvm.mlir.constant(2.000000e+00 : f32) : f32
          %24 = llvm.mlir.constant(5.000000e-01 : f32) : f32
          %25 = llvm.mlir.constant(8 : index) : i64
          %26 = llvm.mlir.constant(4 : index) : i64
          %27 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %28 = llvm.extractvalue %27[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %29 = llvm.load %28 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %3 ["align"(%29, %2 : !llvm.ptr, i64)] : i1
          %30 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %31 = llvm.extractvalue %30[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %32 = llvm.getelementptr %31[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %33 = llvm.load %32 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %3 ["align"(%33, %2 : !llvm.ptr, i64)] : i1
          %34 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %35 = llvm.extractvalue %34[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %36 = llvm.getelementptr %35[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %37 = llvm.load %36 : !llvm.ptr -> !llvm.ptr
          %38 = llvm.mul %25, %0 : i64
          %39 = llvm.udiv %38, %1 : i64
          %40 = llvm.getelementptr %37[%39] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%40, %25 : !llvm.ptr, i64)] : i1
          %41 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %42 = llvm.extractvalue %41[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %43 = llvm.getelementptr %42[3] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %44 = llvm.load %43 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %3 ["align"(%44, %2 : !llvm.ptr, i64)] : i1
          %45 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %46 = llvm.extractvalue %45[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %47 = llvm.getelementptr %46[4] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %48 = llvm.load %47 : !llvm.ptr -> !llvm.ptr
          %49 = llvm.mul %26, %0 : i64
          %50 = llvm.udiv %49, %1 : i64
          %51 = llvm.getelementptr %48[%50] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%51, %26 : !llvm.ptr, i64)] : i1
          %52 = llvm.load %29 : !llvm.ptr -> f32
          %53 = llvm.fmul %52, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %54 = llvm.getelementptr inbounds|nuw %29[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %55 = llvm.load %54 : !llvm.ptr -> f32
          %56 = llvm.fmul %55, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %57 = llvm.fadd %53, %56 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %58 = llvm.fdiv %57, %23 : f32
          %59 = llvm.fsub %56, %53 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %60 = llvm.fdiv %59, %24 : f32
          %61 = llvm.getelementptr inbounds|nuw %33[2] : (!llvm.ptr) -> !llvm.ptr, f32
          %62 = llvm.load %61 : !llvm.ptr -> f32
          %63 = llvm.fdiv %60, %23 : f32
          %64 = llvm.fadd %62, %63 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %65 = llvm.fmul %64, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %66 = llvm.intr.floor(%65) : (f32) -> f32
          %67 = llvm.fmul %66, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %68 = llvm.fsub %64, %67 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %69 = llvm.fptosi %66 : f32 to i32
          %70 = llvm.and %69, %7 : i32
          %71 = llvm.icmp "eq" %70, %6 : i32
          %72 = llvm.icmp "eq" %70, %7 : i32
          %73 = llvm.or %71, %72 : i1
          %74 = llvm.icmp "sgt" %70, %6 : i32
          %75 = llvm.fmul %68, %68 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %76 = llvm.select %73, %19, %68 : i1, f32
          %77 = llvm.select %73, %12, %17 : i1, f32
          %78 = llvm.select %73, %11, %16 : i1, f32
          %79 = llvm.select %73, %10, %15 : i1, f32
          %80 = llvm.select %73, %9, %14 : i1, f32
          %81 = llvm.select %73, %8, %13 : i1, f32
          %82 = llvm.intr.fma(%75, %81, %80) : (f32, f32, f32) -> f32
          %83 = llvm.intr.fma(%75, %82, %79) : (f32, f32, f32) -> f32
          %84 = llvm.intr.fma(%75, %83, %78) : (f32, f32, f32) -> f32
          %85 = llvm.intr.fma(%75, %84, %77) : (f32, f32, f32) -> f32
          %86 = llvm.intr.fma(%75, %85, %19) : (f32, f32, f32) -> f32
          %87 = llvm.fmul %76, %86 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %88 = llvm.fmul %87, %18 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %89 = llvm.select %74, %88, %87 : i1, f32
          %90 = llvm.fmul %58, %89 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %91 = llvm.getelementptr inbounds|nuw %33[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %92 = llvm.load %91 : !llvm.ptr -> f32
          %93 = llvm.fadd %92, %90 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %93, %51 : f32, !llvm.ptr
          %94 = llvm.load %29 : !llvm.ptr -> f32
          %95 = llvm.fmul %94, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %96 = llvm.load %54 : !llvm.ptr -> f32
          %97 = llvm.fmul %96, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %98 = llvm.fadd %95, %97 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %99 = llvm.fdiv %98, %23 : f32
          %100 = llvm.fsub %97, %95 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %101 = llvm.fdiv %100, %24 : f32
          %102 = llvm.load %61 : !llvm.ptr -> f32
          %103 = llvm.fdiv %101, %23 : f32
          %104 = llvm.fadd %102, %103 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %105 = llvm.fmul %104, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %106 = llvm.intr.floor(%105) : (f32) -> f32
          %107 = llvm.fmul %106, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %108 = llvm.fsub %104, %107 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %109 = llvm.fptosi %106 : f32 to i32
          %110 = llvm.and %109, %7 : i32
          %111 = llvm.icmp "eq" %110, %5 : i32
          %112 = llvm.icmp "eq" %110, %6 : i32
          %113 = llvm.icmp "eq" %110, %4 : i32
          %114 = llvm.or %111, %113 : i1
          %115 = llvm.or %112, %113 : i1
          %116 = llvm.fmul %108, %108 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %117 = llvm.select %114, %19, %108 : i1, f32
          %118 = llvm.select %114, %12, %17 : i1, f32
          %119 = llvm.select %114, %11, %16 : i1, f32
          %120 = llvm.select %114, %10, %15 : i1, f32
          %121 = llvm.select %114, %9, %14 : i1, f32
          %122 = llvm.select %114, %8, %13 : i1, f32
          %123 = llvm.intr.fma(%116, %122, %121) : (f32, f32, f32) -> f32
          %124 = llvm.intr.fma(%116, %123, %120) : (f32, f32, f32) -> f32
          %125 = llvm.intr.fma(%116, %124, %119) : (f32, f32, f32) -> f32
          %126 = llvm.intr.fma(%116, %125, %118) : (f32, f32, f32) -> f32
          %127 = llvm.intr.fma(%116, %126, %19) : (f32, f32, f32) -> f32
          %128 = llvm.fmul %117, %127 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %129 = llvm.fmul %128, %18 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %130 = llvm.select %115, %129, %128 : i1, f32
          %131 = llvm.fmul %99, %130 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %132 = llvm.load %33 : !llvm.ptr -> f32
          %133 = llvm.fadd %132, %131 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %133, %44 : f32, !llvm.ptr
          %134 = llvm.load %29 : !llvm.ptr -> f32
          %135 = llvm.fmul %134, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %136 = llvm.load %54 : !llvm.ptr -> f32
          %137 = llvm.fmul %136, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %138 = llvm.fsub %137, %135 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %139 = llvm.fdiv %138, %24 : f32
          %140 = llvm.load %61 : !llvm.ptr -> f32
          %141 = llvm.fadd %140, %139 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %141, %40 : f32, !llvm.ptr
          llvm.return %5 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_1 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_1_slow_memcpy ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c2 = arith.constant 2 : index
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        hal.return %c2, %c1, %c1_0 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_1_slow_memcpy(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(66 : index) : i64
          %2 = llvm.mlir.constant(4356 : index) : i64
          %3 = llvm.mlir.constant(13068 : index) : i64
          %4 = llvm.mlir.constant(true) : i1
          %5 = llvm.mlir.constant(4096 : index) : i64
          %6 = llvm.mlir.constant(8 : index) : i64
          %7 = llvm.mlir.constant(1 : index) : i64
          %8 = llvm.mlir.constant(64 : index) : i64
          %9 = llvm.mlir.constant(32 : index) : i64
          %10 = llvm.mlir.constant(3 : index) : i64
          %11 = llvm.mlir.constant(0 : index) : i64
          %12 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %13 = llvm.extractvalue %12[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %14 = llvm.load %13 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %4 ["align"(%14, %8 : !llvm.ptr, i64)] : i1
          %15 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %16 = llvm.extractvalue %15[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %17 = llvm.getelementptr %16[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %18 = llvm.load %17 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %4 ["align"(%18, %8 : !llvm.ptr, i64)] : i1
          %19 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)>
          %20 = llvm.extractvalue %19[0] : !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)> 
          %21 = llvm.zext %20 : i32 to i64
          %22 = llvm.mul %21, %9 overflow<nsw> : i64
          llvm.br ^bb1(%11 : i64)
        ^bb1(%23: i64):  // 2 preds: ^bb0, ^bb6
          %24 = llvm.icmp "slt" %23, %10 : i64
          llvm.cond_br %24, ^bb2(%11 : i64), ^bb7
        ^bb2(%25: i64):  // 2 preds: ^bb1, ^bb5
          %26 = llvm.icmp "slt" %25, %9 : i64
          llvm.cond_br %26, ^bb3(%11 : i64), ^bb6
        ^bb3(%27: i64):  // 2 preds: ^bb2, ^bb4
          %28 = llvm.icmp "slt" %27, %8 : i64
          llvm.cond_br %28, ^bb4, ^bb5
        ^bb4:  // pred: ^bb3
          %29 = llvm.add %22, %25 : i64
          %30 = llvm.mul %23, %5 : i64
          %31 = llvm.mul %29, %8 : i64
          %32 = llvm.add %30, %31 : i64
          %33 = llvm.add %32, %27 : i64
          %34 = llvm.getelementptr %14[%33] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %35 = llvm.load %34 {alignment = 4 : i64} : !llvm.ptr -> vector<8xf32>
          %36 = llvm.add %29, %7 : i64
          %37 = llvm.add %27, %7 : i64
          %38 = llvm.mul %11, %3 : i64
          %39 = llvm.mul %23, %2 : i64
          %40 = llvm.add %38, %39 : i64
          %41 = llvm.mul %36, %1 : i64
          %42 = llvm.add %40, %41 : i64
          %43 = llvm.add %42, %37 : i64
          %44 = llvm.getelementptr %18[%43] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %35, %44 {alignment = 4 : i64} : vector<8xf32>, !llvm.ptr
          %45 = llvm.add %27, %6 : i64
          llvm.br ^bb3(%45 : i64)
        ^bb5:  // pred: ^bb3
          %46 = llvm.add %25, %7 : i64
          llvm.br ^bb2(%46 : i64)
        ^bb6:  // pred: ^bb2
          %47 = llvm.add %23, %7 : i64
          llvm.br ^bb1(%47 : i64)
        ^bb7:  // pred: ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_2 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_2_conv_4x16x16x3x4x4_f32 ordinal(0) layout(#pipeline_layout2) count(%arg0: !hal.device) -> (index, index, index) {
        %c16 = arith.constant 16 : index
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        hal.return %c16, %c1, %c1_0 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.mlir.global private constant @__constant_4xf32(dense<[0.0602946617, 0.0679099783, 0.0262253601, 2.52176687E-4]> : tensor<4xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<4 x f32>
        llvm.func @_main$async_dispatch_2_conv_4x16x16x3x4x4_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.poison : vector<8xf32>
          %2 = llvm.mlir.constant(0 : i64) : i64
          %3 = llvm.mlir.constant(256 : index) : i64
          %4 = llvm.mlir.constant(8 : i64) : i64
          %5 = llvm.mlir.constant(32 : i64) : i64
          %6 = llvm.mlir.constant(48 : index) : i64
          %7 = llvm.mlir.constant(64 : index) : i64
          %8 = llvm.mlir.constant(true) : i1
          %9 = llvm.mlir.constant(66 : index) : i64
          %10 = llvm.mlir.constant(4356 : index) : i64
          %11 = llvm.mlir.addressof @__constant_4xf32 : !llvm.ptr
          %12 = llvm.mlir.constant(-1 : index) : i64
          %13 = llvm.mlir.constant(8 : index) : i64
          %14 = llvm.mlir.constant(16 : index) : i64
          %15 = llvm.mlir.constant(1 : index) : i64
          %16 = llvm.mlir.constant(4 : index) : i64
          %17 = llvm.mlir.constant(3 : index) : i64
          %18 = llvm.mlir.constant(dense<0.000000e+00> : vector<8xf32>) : vector<8xf32>
          %19 = llvm.mlir.constant(52288 : index) : i64
          %20 = llvm.mlir.constant(0 : index) : i64
          %21 = llvm.getelementptr %11[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<4 x f32>
          %22 = llvm.alloca %13 x f32 {alignment = 64 : i64} : (i64) -> !llvm.ptr
          %23 = llvm.alloca %13 x f32 {alignment = 64 : i64} : (i64) -> !llvm.ptr
          %24 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %25 = llvm.extractvalue %24[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %26 = llvm.load %25 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %8 ["align"(%26, %7 : !llvm.ptr, i64)] : i1
          %27 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %28 = llvm.extractvalue %27[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %29 = llvm.getelementptr %28[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %30 = llvm.load %29 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %8 ["align"(%30, %7 : !llvm.ptr, i64)] : i1
          %31 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %32 = llvm.extractvalue %31[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %33 = llvm.getelementptr %32[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %34 = llvm.load %33 : !llvm.ptr -> !llvm.ptr
          %35 = llvm.mul %19, %4 : i64
          %36 = llvm.udiv %35, %5 : i64
          %37 = llvm.getelementptr %34[%36] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %8 ["align"(%37, %7 : !llvm.ptr, i64)] : i1
          %38 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)>
          %39 = llvm.extractvalue %38[0] : !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)> 
          %40 = llvm.zext %39 : i32 to i64
          %41 = llvm.sdiv %40, %16 : i64
          %42 = llvm.mul %41, %16 : i64
          %43 = llvm.icmp "ne" %40, %42 : i64
          %44 = llvm.icmp "slt" %40, %20 : i64
          %45 = llvm.and %43, %44 : i1
          %46 = llvm.add %41, %12 : i64
          %47 = llvm.select %45, %46, %41 : i1, i64
          %48 = llvm.srem %40, %16 : i64
          %49 = llvm.icmp "slt" %48, %20 : i64
          %50 = llvm.add %48, %16 overflow<nsw> : i64
          %51 = llvm.select %49, %50, %48 : i1, i64
          %52 = llvm.mul %51, %16 overflow<nsw> : i64
          %53 = llvm.mul %20, %13 : i64
          %54 = llvm.add %53, %53 : i64
          %55 = llvm.add %54, %20 : i64
          %56 = llvm.getelementptr %23[%55] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %18, %56 {alignment = 4 : i64} : vector<8xf32>, !llvm.ptr
          %57 = llvm.getelementptr %21[%47] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %58 = llvm.load %57 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          llvm.br ^bb1(%20 : i64)
        ^bb1(%59: i64):  // 2 preds: ^bb0, ^bb16
          %60 = llvm.icmp "slt" %59, %16 : i64
          llvm.cond_br %60, ^bb2(%20 : i64), ^bb17
        ^bb2(%61: i64):  // 2 preds: ^bb1, ^bb15
          %62 = llvm.icmp "slt" %61, %14 : i64
          llvm.cond_br %62, ^bb3, ^bb16
        ^bb3:  // pred: ^bb2
          %63 = llvm.mul %61, %16 overflow<nsw> : i64
          llvm.br ^bb4(%20 : i64)
        ^bb4(%64: i64):  // 2 preds: ^bb3, ^bb5
          %65 = llvm.icmp "slt" %64, %13 : i64
          llvm.cond_br %65, ^bb5, ^bb6(%20 : i64)
        ^bb5:  // pred: ^bb4
          %66 = llvm.mul %20, %13 overflow<nsw, nuw> : i64
          %67 = llvm.add %66, %66 overflow<nsw, nuw> : i64
          %68 = llvm.add %67, %64 overflow<nsw, nuw> : i64
          %69 = llvm.getelementptr inbounds|nuw %23[%68] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %70 = llvm.load %69 : !llvm.ptr -> f32
          %71 = llvm.getelementptr inbounds|nuw %22[%68] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %70, %71 : f32, !llvm.ptr
          %72 = llvm.add %64, %15 : i64
          llvm.br ^bb4(%72 : i64)
        ^bb6(%73: i64):  // 2 preds: ^bb4, ^bb14
          %74 = llvm.icmp "slt" %73, %17 : i64
          llvm.cond_br %74, ^bb7(%20 : i64), ^bb15
        ^bb7(%75: i64):  // 2 preds: ^bb6, ^bb13
          %76 = llvm.icmp "slt" %75, %16 : i64
          llvm.cond_br %76, ^bb8, ^bb14
        ^bb8:  // pred: ^bb7
          %77 = llvm.mul %59, %16 overflow<nsw> : i64
          %78 = llvm.mul %51, %14 overflow<nsw> : i64
          %79 = llvm.add %77, %78 : i64
          %80 = llvm.add %79, %75 : i64
          llvm.br ^bb9(%20 : i64)
        ^bb9(%81: i64):  // 2 preds: ^bb8, ^bb12
          %82 = llvm.icmp "slt" %81, %13 : i64
          llvm.cond_br %82, ^bb10(%20 : i64), ^bb13
        ^bb10(%83: i64):  // 2 preds: ^bb9, ^bb11
          %84 = llvm.icmp "slt" %83, %16 : i64
          llvm.cond_br %84, ^bb11, ^bb12
        ^bb11:  // pred: ^bb10
          %85 = llvm.mul %81, %16 overflow<nsw> : i64
          %86 = llvm.add %63, %85 : i64
          %87 = llvm.add %86, %83 : i64
          %88 = llvm.mul %73, %10 overflow<nsw, nuw> : i64
          %89 = llvm.mul %80, %9 overflow<nsw, nuw> : i64
          %90 = llvm.add %88, %89 overflow<nsw, nuw> : i64
          %91 = llvm.add %90, %87 overflow<nsw, nuw> : i64
          %92 = llvm.getelementptr inbounds|nuw %26[%91] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %93 = llvm.load %92 : !llvm.ptr -> f32
          %94 = llvm.mul %47, %6 overflow<nsw, nuw> : i64
          %95 = llvm.mul %73, %14 overflow<nsw, nuw> : i64
          %96 = llvm.add %94, %95 overflow<nsw, nuw> : i64
          %97 = llvm.mul %75, %16 overflow<nsw, nuw> : i64
          %98 = llvm.add %96, %97 overflow<nsw, nuw> : i64
          %99 = llvm.add %98, %83 overflow<nsw, nuw> : i64
          %100 = llvm.getelementptr inbounds|nuw %30[%99] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %101 = llvm.load %100 : !llvm.ptr -> f32
          %102 = llvm.mul %20, %13 overflow<nsw, nuw> : i64
          %103 = llvm.add %102, %102 overflow<nsw, nuw> : i64
          %104 = llvm.add %103, %81 overflow<nsw, nuw> : i64
          %105 = llvm.getelementptr inbounds|nuw %22[%104] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %106 = llvm.load %105 : !llvm.ptr -> f32
          %107 = llvm.fmul %93, %101 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %108 = llvm.fadd %106, %107 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %108, %105 : f32, !llvm.ptr
          %109 = llvm.add %83, %15 : i64
          llvm.br ^bb10(%109 : i64)
        ^bb12:  // pred: ^bb10
          %110 = llvm.add %81, %15 : i64
          llvm.br ^bb9(%110 : i64)
        ^bb13:  // pred: ^bb9
          %111 = llvm.add %75, %15 : i64
          llvm.br ^bb7(%111 : i64)
        ^bb14:  // pred: ^bb7
          %112 = llvm.add %73, %15 : i64
          llvm.br ^bb6(%112 : i64)
        ^bb15:  // pred: ^bb6
          %113 = llvm.getelementptr %22[%55] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %114 = llvm.load %113 {alignment = 4 : i64} : !llvm.ptr -> vector<8xf32>
          %115 = llvm.extractelement %58[%2 : i64] : vector<1xf32>
          %116 = llvm.insertelement %115, %1[%0 : i32] : vector<8xf32>
          %117 = llvm.shufflevector %116, %1 [0, 0, 0, 0, 0, 0, 0, 0] : vector<8xf32> 
          %118 = llvm.fadd %114, %117 {fastmathFlags = #llvm.fastmath<contract>} : vector<8xf32>
          %119 = llvm.fcmp "ugt" %118, %18 : vector<8xf32>
          %120 = llvm.select %119, %118, %18 : vector<8xi1>, vector<8xf32>
          %121 = llvm.add %52, %59 : i64
          %122 = llvm.mul %47, %3 : i64
          %123 = llvm.mul %121, %14 : i64
          %124 = llvm.add %122, %123 : i64
          %125 = llvm.add %124, %61 : i64
          %126 = llvm.getelementptr %37[%125] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %120, %126 {alignment = 4 : i64} : vector<8xf32>, !llvm.ptr
          %127 = llvm.add %61, %13 : i64
          llvm.br ^bb2(%127 : i64)
        ^bb16:  // pred: ^bb2
          %128 = llvm.add %59, %15 : i64
          llvm.br ^bb1(%128 : i64)
        ^bb17:  // pred: ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_3 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_3_conv_4x8x8x2x2_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c16 = arith.constant 16 : index
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        hal.return %c16, %c1, %c1_0 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_3_conv_4x8x8x2x2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(64 : index) : i64
          %2 = llvm.mlir.constant(true) : i1
          %3 = llvm.mlir.constant(256 : index) : i64
          %4 = llvm.mlir.constant(16 : index) : i64
          %5 = llvm.mlir.constant(8 : i64) : i64
          %6 = llvm.mlir.constant(32 : i64) : i64
          %7 = llvm.mlir.constant(-1 : index) : i64
          %8 = llvm.mlir.constant(8 : index) : i64
          %9 = llvm.mlir.constant(4 : index) : i64
          %10 = llvm.mlir.constant(dense<0xFF800000> : vector<8xf32>) : vector<8xf32>
          %11 = llvm.mlir.constant(0 : index) : i64
          %12 = llvm.mlir.constant(52288 : index) : i64
          %13 = llvm.mlir.constant(2 : index) : i64
          %14 = llvm.mlir.constant(1 : index) : i64
          %15 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %16 = llvm.extractvalue %15[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %17 = llvm.load %16 : !llvm.ptr -> !llvm.ptr
          %18 = llvm.mul %12, %5 : i64
          %19 = llvm.udiv %18, %6 : i64
          %20 = llvm.getelementptr %17[%19] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%20, %1 : !llvm.ptr, i64)] : i1
          %21 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %22 = llvm.extractvalue %21[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %23 = llvm.getelementptr %22[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %24 = llvm.load %23 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %2 ["align"(%24, %1 : !llvm.ptr, i64)] : i1
          %25 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)>
          %26 = llvm.extractvalue %25[0] : !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)> 
          %27 = llvm.zext %26 : i32 to i64
          %28 = llvm.sdiv %27, %9 : i64
          %29 = llvm.mul %28, %9 : i64
          %30 = llvm.icmp "ne" %27, %29 : i64
          %31 = llvm.icmp "slt" %27, %11 : i64
          %32 = llvm.and %30, %31 : i1
          %33 = llvm.add %28, %7 : i64
          %34 = llvm.select %32, %33, %28 : i1, i64
          %35 = llvm.srem %27, %9 : i64
          %36 = llvm.icmp "slt" %35, %11 : i64
          %37 = llvm.add %35, %9 overflow<nsw> : i64
          %38 = llvm.select %36, %37, %35 : i1, i64
          %39 = llvm.mul %38, %13 overflow<nsw> : i64
          llvm.br ^bb1(%11 : i64)
        ^bb1(%40: i64):  // 2 preds: ^bb0, ^bb10
          %41 = llvm.icmp "slt" %40, %13 : i64
          llvm.cond_br %41, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %42 = llvm.add %39, %40 : i64
          %43 = llvm.mul %34, %1 : i64
          %44 = llvm.mul %42, %8 : i64
          %45 = llvm.add %43, %44 : i64
          %46 = llvm.add %45, %11 : i64
          %47 = llvm.getelementptr %24[%46] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %10, %47 {alignment = 4 : i64} : vector<8xf32>, !llvm.ptr
          llvm.br ^bb3(%11 : i64)
        ^bb3(%48: i64):  // 2 preds: ^bb2, ^bb9
          %49 = llvm.icmp "slt" %48, %13 : i64
          llvm.cond_br %49, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %50 = llvm.mul %40, %13 overflow<nsw> : i64
          %51 = llvm.mul %38, %9 overflow<nsw> : i64
          %52 = llvm.add %50, %51 : i64
          %53 = llvm.add %52, %48 : i64
          llvm.br ^bb5(%11 : i64)
        ^bb5(%54: i64):  // 2 preds: ^bb4, ^bb8
          %55 = llvm.icmp "slt" %54, %8 : i64
          llvm.cond_br %55, ^bb6(%11 : i64), ^bb9
        ^bb6(%56: i64):  // 2 preds: ^bb5, ^bb7
          %57 = llvm.icmp "slt" %56, %13 : i64
          llvm.cond_br %57, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %58 = llvm.mul %54, %13 overflow<nsw> : i64
          %59 = llvm.add %58, %56 : i64
          %60 = llvm.mul %34, %3 overflow<nsw, nuw> : i64
          %61 = llvm.mul %53, %4 overflow<nsw, nuw> : i64
          %62 = llvm.add %60, %61 overflow<nsw, nuw> : i64
          %63 = llvm.add %62, %59 overflow<nsw, nuw> : i64
          %64 = llvm.getelementptr inbounds|nuw %20[%63] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %65 = llvm.load %64 : !llvm.ptr -> f32
          %66 = llvm.mul %34, %1 overflow<nsw, nuw> : i64
          %67 = llvm.mul %42, %8 overflow<nsw, nuw> : i64
          %68 = llvm.add %66, %67 overflow<nsw, nuw> : i64
          %69 = llvm.add %68, %54 overflow<nsw, nuw> : i64
          %70 = llvm.getelementptr inbounds|nuw %24[%69] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %71 = llvm.load %70 : !llvm.ptr -> f32
          %72 = llvm.fcmp "ugt" %71, %65 : f32
          %73 = llvm.select %72, %71, %65 : i1, f32
          %74 = llvm.fcmp "uno" %65, %65 : f32
          %75 = llvm.select %74, %65, %73 : i1, f32
          llvm.store %75, %70 : f32, !llvm.ptr
          %76 = llvm.add %56, %14 : i64
          llvm.br ^bb6(%76 : i64)
        ^bb8:  // pred: ^bb6
          %77 = llvm.add %54, %14 : i64
          llvm.br ^bb5(%77 : i64)
        ^bb9:  // pred: ^bb5
          %78 = llvm.add %48, %14 : i64
          llvm.br ^bb3(%78 : i64)
        ^bb10:  // pred: ^bb3
          %79 = llvm.add %40, %14 : i64
          llvm.br ^bb1(%79 : i64)
        ^bb11:  // pred: ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_4 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_4_mmt4d_1x1x256x1x8x1_f32 ordinal(0) layout(#pipeline_layout2) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @iree_uk_mmt4d(!llvm.ptr, i64, i64, !llvm.ptr, i64, i64, !llvm.ptr, i64, i64, i64, i64, i64, i32, i32, i32, i32, !llvm.ptr) -> i32 attributes {hal.import.bitcode = true, hal.import.fields = ["processor_data"], llvm.bareptr = true}
        llvm.func @_main$async_dispatch_4_mmt4d_1x1x256x1x8x1_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(52255 : i64) : i64
          %1 = llvm.mlir.constant(8 : i64) : i64
          %2 = llvm.mlir.constant(0 : i32) : i32
          %3 = llvm.mlir.constant(192 : index) : i64
          %4 = llvm.mlir.constant(8 : index) : i64
          %5 = llvm.mlir.constant(2048 : index) : i64
          %6 = llvm.mlir.constant(1537 : i32) : i32
          %7 = llvm.mlir.constant(8 : i32) : i32
          %8 = llvm.mlir.constant(1 : i32) : i32
          %9 = llvm.mlir.constant(256 : index) : i64
          %10 = llvm.mlir.constant(1 : index) : i64
          %11 = llvm.mlir.constant(0 : index) : i64
          %12 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %13 = llvm.extractvalue %12[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %14 = llvm.load %13 : !llvm.ptr -> !llvm.ptr
          %15 = llvm.getelementptr %13[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %16 = llvm.load %15 : !llvm.ptr -> !llvm.ptr
          %17 = llvm.getelementptr %13[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %18 = llvm.load %17 : !llvm.ptr -> !llvm.ptr
          %19 = llvm.getelementptr inbounds %arg0[4] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %20 = llvm.alloca %1 x i64 {alignment = 8 : i64} : (i64) -> !llvm.ptr
          %21 = llvm.load %19 : !llvm.ptr -> i64
          %22 = llvm.or %21, %0 : i64
          llvm.store %22, %20 : i64, !llvm.ptr
          %23 = llvm.getelementptr inbounds %19[1] : (!llvm.ptr) -> !llvm.ptr, i64
          %24 = llvm.load %23 : !llvm.ptr -> i64
          %25 = llvm.getelementptr inbounds %20[1] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %24, %25 : i64, !llvm.ptr
          %26 = llvm.getelementptr inbounds %19[2] : (!llvm.ptr) -> !llvm.ptr, i64
          %27 = llvm.load %26 : !llvm.ptr -> i64
          %28 = llvm.getelementptr inbounds %20[2] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %27, %28 : i64, !llvm.ptr
          %29 = llvm.getelementptr inbounds %19[3] : (!llvm.ptr) -> !llvm.ptr, i64
          %30 = llvm.load %29 : !llvm.ptr -> i64
          %31 = llvm.getelementptr inbounds %20[3] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %30, %31 : i64, !llvm.ptr
          %32 = llvm.getelementptr inbounds %19[4] : (!llvm.ptr) -> !llvm.ptr, i64
          %33 = llvm.load %32 : !llvm.ptr -> i64
          %34 = llvm.getelementptr inbounds %20[4] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %33, %34 : i64, !llvm.ptr
          %35 = llvm.getelementptr inbounds %19[5] : (!llvm.ptr) -> !llvm.ptr, i64
          %36 = llvm.load %35 : !llvm.ptr -> i64
          %37 = llvm.getelementptr inbounds %20[5] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %36, %37 : i64, !llvm.ptr
          %38 = llvm.getelementptr inbounds %19[6] : (!llvm.ptr) -> !llvm.ptr, i64
          %39 = llvm.load %38 : !llvm.ptr -> i64
          %40 = llvm.getelementptr inbounds %20[6] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %39, %40 : i64, !llvm.ptr
          %41 = llvm.getelementptr inbounds %19[7] : (!llvm.ptr) -> !llvm.ptr, i64
          %42 = llvm.load %41 : !llvm.ptr -> i64
          %43 = llvm.getelementptr inbounds %20[7] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %42, %43 : i64, !llvm.ptr
          %44 = llvm.call @iree_uk_mmt4d(%14, %11, %9, %16, %3, %5, %18, %9, %4, %10, %10, %9, %8, %7, %8, %6, %20) : (!llvm.ptr, i64, i64, !llvm.ptr, i64, i64, !llvm.ptr, i64, i64, i64, i64, i64, i32, i32, i32, i32, !llvm.ptr) -> i32
          llvm.return %2 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_5 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_5_unpack_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_5_unpack_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(2 : index) : i64
          %2 = llvm.mlir.constant(64 : index) : i64
          %3 = llvm.mlir.constant(true) : i1
          %4 = llvm.mlir.constant(8 : index) : i64
          %5 = llvm.mlir.constant(8 : i64) : i64
          %6 = llvm.mlir.constant(32 : i64) : i64
          %7 = llvm.mlir.constant(dense<[true, true, false, false, false, false, false, false]> : vector<8xi1>) : vector<8xi1>
          %8 = llvm.mlir.constant(1024 : index) : i64
          %9 = llvm.mlir.constant(0 : index) : i64
          %10 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %11 = llvm.extractvalue %10[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %12 = llvm.load %11 : !llvm.ptr -> !llvm.ptr
          %13 = llvm.mul %8, %5 : i64
          %14 = llvm.udiv %13, %6 : i64
          %15 = llvm.getelementptr %12[%14] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%15, %2 : !llvm.ptr, i64)] : i1
          %16 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %17 = llvm.extractvalue %16[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %18 = llvm.getelementptr %17[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %19 = llvm.load %18 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %3 ["align"(%19, %2 : !llvm.ptr, i64)] : i1
          %20 = llvm.mul %9, %4 : i64
          %21 = llvm.add %20, %20 : i64
          %22 = llvm.add %21, %20 : i64
          %23 = llvm.add %22, %9 : i64
          %24 = llvm.getelementptr %15[%23] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %25 = llvm.load %24 {alignment = 4 : i64} : !llvm.ptr -> vector<8xf32>
          %26 = llvm.mul %9, %1 : i64
          %27 = llvm.add %26, %9 : i64
          %28 = llvm.getelementptr %19[%27] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.masked.store %25, %28, %7 {alignment = 4 : i32} : vector<8xf32>, vector<8xi1> into !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_6 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_6_elementwise_broadcast ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_6_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(4 : index) : i64
          %1 = llvm.mlir.constant(8 : i64) : i64
          %2 = llvm.mlir.constant(32 : i64) : i64
          %3 = llvm.mlir.constant(64 : index) : i64
          %4 = llvm.mlir.constant(true) : i1
          %5 = llvm.mlir.constant(2 : i32) : i32
          %6 = llvm.mlir.constant(1 : i32) : i32
          %7 = llvm.mlir.constant(0 : i32) : i32
          %8 = llvm.mlir.constant(3 : i32) : i32
          %9 = llvm.mlir.constant(-2.59630184E-7 : f32) : f32
          %10 = llvm.mlir.constant(2.47562348E-5 : f32) : f32
          %11 = llvm.mlir.constant(-0.00138883304 : f32) : f32
          %12 = llvm.mlir.constant(0.0416666418 : f32) : f32
          %13 = llvm.mlir.constant(-5.000000e-01 : f32) : f32
          %14 = llvm.mlir.constant(-2.50293279E-8 : f32) : f32
          %15 = llvm.mlir.constant(2.76001265E-6 : f32) : f32
          %16 = llvm.mlir.constant(-1.98426045E-4 : f32) : f32
          %17 = llvm.mlir.constant(0.00833334774 : f32) : f32
          %18 = llvm.mlir.constant(-0.166666672 : f32) : f32
          %19 = llvm.mlir.constant(-1.000000e+00 : f32) : f32
          %20 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %21 = llvm.mlir.constant(1.57079637 : f32) : f32
          %22 = llvm.mlir.constant(0.636619746 : f32) : f32
          %23 = llvm.mlir.constant(68 : index) : i64
          %24 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %25 = llvm.extractvalue %24[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %26 = llvm.load %25 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %4 ["align"(%26, %3 : !llvm.ptr, i64)] : i1
          %27 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %28 = llvm.extractvalue %27[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %29 = llvm.getelementptr %28[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %30 = llvm.load %29 : !llvm.ptr -> !llvm.ptr
          %31 = llvm.mul %23, %1 : i64
          %32 = llvm.udiv %31, %2 : i64
          %33 = llvm.getelementptr %30[%32] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%33, %0 : !llvm.ptr, i64)] : i1
          %34 = llvm.load %26 : !llvm.ptr -> f32
          %35 = llvm.getelementptr inbounds|nuw %26[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %36 = llvm.load %35 : !llvm.ptr -> f32
          %37 = llvm.fadd %34, %36 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %38 = llvm.fmul %37, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %39 = llvm.intr.floor(%38) : (f32) -> f32
          %40 = llvm.fmul %39, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %41 = llvm.fsub %37, %40 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %42 = llvm.fptosi %39 : f32 to i32
          %43 = llvm.and %42, %8 : i32
          %44 = llvm.icmp "eq" %43, %7 : i32
          %45 = llvm.icmp "eq" %43, %6 : i32
          %46 = llvm.icmp "eq" %43, %5 : i32
          %47 = llvm.or %44, %46 : i1
          %48 = llvm.or %45, %46 : i1
          %49 = llvm.fmul %41, %41 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %50 = llvm.select %47, %20, %41 : i1, f32
          %51 = llvm.select %47, %13, %18 : i1, f32
          %52 = llvm.select %47, %12, %17 : i1, f32
          %53 = llvm.select %47, %11, %16 : i1, f32
          %54 = llvm.select %47, %10, %15 : i1, f32
          %55 = llvm.select %47, %9, %14 : i1, f32
          %56 = llvm.intr.fma(%49, %55, %54) : (f32, f32, f32) -> f32
          %57 = llvm.intr.fma(%49, %56, %53) : (f32, f32, f32) -> f32
          %58 = llvm.intr.fma(%49, %57, %52) : (f32, f32, f32) -> f32
          %59 = llvm.intr.fma(%49, %58, %51) : (f32, f32, f32) -> f32
          %60 = llvm.intr.fma(%49, %59, %20) : (f32, f32, f32) -> f32
          %61 = llvm.fmul %50, %60 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %62 = llvm.fmul %61, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %63 = llvm.select %48, %62, %61 : i1, f32
          llvm.store %63, %33 : f32, !llvm.ptr
          llvm.return %7 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_7 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_7_elementwise_broadcast ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_7_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(true) : i1
          %1 = llvm.mlir.constant(8 : i64) : i64
          %2 = llvm.mlir.constant(32 : i64) : i64
          %3 = llvm.mlir.constant(2 : i32) : i32
          %4 = llvm.mlir.constant(1 : i32) : i32
          %5 = llvm.mlir.constant(0 : i32) : i32
          %6 = llvm.mlir.constant(3 : i32) : i32
          %7 = llvm.mlir.constant(-2.59630184E-7 : f32) : f32
          %8 = llvm.mlir.constant(2.47562348E-5 : f32) : f32
          %9 = llvm.mlir.constant(-0.00138883304 : f32) : f32
          %10 = llvm.mlir.constant(0.0416666418 : f32) : f32
          %11 = llvm.mlir.constant(-5.000000e-01 : f32) : f32
          %12 = llvm.mlir.constant(-2.50293279E-8 : f32) : f32
          %13 = llvm.mlir.constant(2.76001265E-6 : f32) : f32
          %14 = llvm.mlir.constant(-1.98426045E-4 : f32) : f32
          %15 = llvm.mlir.constant(0.00833334774 : f32) : f32
          %16 = llvm.mlir.constant(-0.166666672 : f32) : f32
          %17 = llvm.mlir.constant(-1.000000e+00 : f32) : f32
          %18 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %19 = llvm.mlir.constant(1.57079637 : f32) : f32
          %20 = llvm.mlir.constant(0.636619746 : f32) : f32
          %21 = llvm.mlir.constant(64 : index) : i64
          %22 = llvm.mlir.constant(128 : index) : i64
          %23 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %24 = llvm.extractvalue %23[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %25 = llvm.load %24 : !llvm.ptr -> !llvm.ptr
          %26 = llvm.mul %21, %1 : i64
          %27 = llvm.udiv %26, %2 : i64
          %28 = llvm.getelementptr %25[%27] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %0 ["align"(%28, %21 : !llvm.ptr, i64)] : i1
          %29 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %30 = llvm.extractvalue %29[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %31 = llvm.getelementptr %30[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %32 = llvm.load %31 : !llvm.ptr -> !llvm.ptr
          %33 = llvm.mul %22, %1 : i64
          %34 = llvm.udiv %33, %2 : i64
          %35 = llvm.getelementptr %32[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %0 ["align"(%35, %21 : !llvm.ptr, i64)] : i1
          %36 = llvm.load %28 : !llvm.ptr -> f32
          %37 = llvm.getelementptr inbounds|nuw %28[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %38 = llvm.load %37 : !llvm.ptr -> f32
          %39 = llvm.fadd %36, %38 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %40 = llvm.fmul %39, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %41 = llvm.intr.floor(%40) : (f32) -> f32
          %42 = llvm.fmul %41, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %43 = llvm.fsub %39, %42 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %44 = llvm.fptosi %41 : f32 to i32
          %45 = llvm.and %44, %6 : i32
          %46 = llvm.icmp "eq" %45, %5 : i32
          %47 = llvm.icmp "eq" %45, %4 : i32
          %48 = llvm.icmp "eq" %45, %3 : i32
          %49 = llvm.or %46, %48 : i1
          %50 = llvm.or %47, %48 : i1
          %51 = llvm.fmul %43, %43 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %52 = llvm.select %49, %18, %43 : i1, f32
          %53 = llvm.select %49, %11, %16 : i1, f32
          %54 = llvm.select %49, %10, %15 : i1, f32
          %55 = llvm.select %49, %9, %14 : i1, f32
          %56 = llvm.select %49, %8, %13 : i1, f32
          %57 = llvm.select %49, %7, %12 : i1, f32
          %58 = llvm.intr.fma(%51, %57, %56) : (f32, f32, f32) -> f32
          %59 = llvm.intr.fma(%51, %58, %55) : (f32, f32, f32) -> f32
          %60 = llvm.intr.fma(%51, %59, %54) : (f32, f32, f32) -> f32
          %61 = llvm.intr.fma(%51, %60, %53) : (f32, f32, f32) -> f32
          %62 = llvm.intr.fma(%51, %61, %18) : (f32, f32, f32) -> f32
          %63 = llvm.fmul %52, %62 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %64 = llvm.fmul %63, %17 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %65 = llvm.select %50, %64, %63 : i1, f32
          %66 = llvm.fmul %36, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %67 = llvm.intr.floor(%66) : (f32) -> f32
          %68 = llvm.fmul %67, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %69 = llvm.fsub %36, %68 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %70 = llvm.fptosi %67 : f32 to i32
          %71 = llvm.and %70, %6 : i32
          %72 = llvm.icmp "eq" %71, %5 : i32
          %73 = llvm.icmp "eq" %71, %4 : i32
          %74 = llvm.icmp "eq" %71, %3 : i32
          %75 = llvm.or %72, %74 : i1
          %76 = llvm.or %73, %74 : i1
          %77 = llvm.fmul %69, %69 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %78 = llvm.select %75, %18, %69 : i1, f32
          %79 = llvm.select %75, %11, %16 : i1, f32
          %80 = llvm.select %75, %10, %15 : i1, f32
          %81 = llvm.select %75, %9, %14 : i1, f32
          %82 = llvm.select %75, %8, %13 : i1, f32
          %83 = llvm.select %75, %7, %12 : i1, f32
          %84 = llvm.intr.fma(%77, %83, %82) : (f32, f32, f32) -> f32
          %85 = llvm.intr.fma(%77, %84, %81) : (f32, f32, f32) -> f32
          %86 = llvm.intr.fma(%77, %85, %80) : (f32, f32, f32) -> f32
          %87 = llvm.intr.fma(%77, %86, %79) : (f32, f32, f32) -> f32
          %88 = llvm.intr.fma(%77, %87, %18) : (f32, f32, f32) -> f32
          %89 = llvm.fmul %78, %88 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %90 = llvm.fmul %89, %17 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %91 = llvm.select %76, %90, %89 : i1, f32
          %92 = llvm.fadd %91, %65 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %92, %35 : f32, !llvm.ptr
          llvm.return %5 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_8 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_8_elementwise_broadcast ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_8_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(4 : index) : i64
          %2 = llvm.mlir.constant(8 : i64) : i64
          %3 = llvm.mlir.constant(32 : i64) : i64
          %4 = llvm.mlir.constant(64 : index) : i64
          %5 = llvm.mlir.constant(true) : i1
          %6 = llvm.mlir.constant(1 : i32) : i32
          %7 = llvm.mlir.constant(3 : i32) : i32
          %8 = llvm.mlir.constant(-2.59630184E-7 : f32) : f32
          %9 = llvm.mlir.constant(2.47562348E-5 : f32) : f32
          %10 = llvm.mlir.constant(-0.00138883304 : f32) : f32
          %11 = llvm.mlir.constant(0.0416666418 : f32) : f32
          %12 = llvm.mlir.constant(-5.000000e-01 : f32) : f32
          %13 = llvm.mlir.constant(-2.50293279E-8 : f32) : f32
          %14 = llvm.mlir.constant(2.76001265E-6 : f32) : f32
          %15 = llvm.mlir.constant(-1.98426045E-4 : f32) : f32
          %16 = llvm.mlir.constant(0.00833334774 : f32) : f32
          %17 = llvm.mlir.constant(-0.166666672 : f32) : f32
          %18 = llvm.mlir.constant(-1.000000e+00 : f32) : f32
          %19 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %20 = llvm.mlir.constant(1.57079637 : f32) : f32
          %21 = llvm.mlir.constant(0.636619746 : f32) : f32
          %22 = llvm.mlir.constant(132 : index) : i64
          %23 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %24 = llvm.extractvalue %23[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %25 = llvm.load %24 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %5 ["align"(%25, %4 : !llvm.ptr, i64)] : i1
          %26 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %27 = llvm.extractvalue %26[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %28 = llvm.getelementptr %27[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %29 = llvm.load %28 : !llvm.ptr -> !llvm.ptr
          %30 = llvm.mul %22, %2 : i64
          %31 = llvm.udiv %30, %3 : i64
          %32 = llvm.getelementptr %29[%31] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %5 ["align"(%32, %1 : !llvm.ptr, i64)] : i1
          %33 = llvm.load %25 : !llvm.ptr -> f32
          %34 = llvm.getelementptr inbounds|nuw %25[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %35 = llvm.load %34 : !llvm.ptr -> f32
          %36 = llvm.fadd %33, %35 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %37 = llvm.fmul %36, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %38 = llvm.intr.floor(%37) : (f32) -> f32
          %39 = llvm.fmul %38, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %40 = llvm.fsub %36, %39 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %41 = llvm.fptosi %38 : f32 to i32
          %42 = llvm.and %41, %7 : i32
          %43 = llvm.icmp "eq" %42, %6 : i32
          %44 = llvm.icmp "eq" %42, %7 : i32
          %45 = llvm.or %43, %44 : i1
          %46 = llvm.icmp "sgt" %42, %6 : i32
          %47 = llvm.fmul %40, %40 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %48 = llvm.select %45, %19, %40 : i1, f32
          %49 = llvm.select %45, %12, %17 : i1, f32
          %50 = llvm.select %45, %11, %16 : i1, f32
          %51 = llvm.select %45, %10, %15 : i1, f32
          %52 = llvm.select %45, %9, %14 : i1, f32
          %53 = llvm.select %45, %8, %13 : i1, f32
          %54 = llvm.intr.fma(%47, %53, %52) : (f32, f32, f32) -> f32
          %55 = llvm.intr.fma(%47, %54, %51) : (f32, f32, f32) -> f32
          %56 = llvm.intr.fma(%47, %55, %50) : (f32, f32, f32) -> f32
          %57 = llvm.intr.fma(%47, %56, %49) : (f32, f32, f32) -> f32
          %58 = llvm.intr.fma(%47, %57, %19) : (f32, f32, f32) -> f32
          %59 = llvm.fmul %48, %58 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %60 = llvm.fmul %59, %18 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %61 = llvm.select %46, %60, %59 : i1, f32
          %62 = llvm.fmul %33, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %63 = llvm.intr.floor(%62) : (f32) -> f32
          %64 = llvm.fmul %63, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %65 = llvm.fsub %33, %64 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %66 = llvm.fptosi %63 : f32 to i32
          %67 = llvm.and %66, %7 : i32
          %68 = llvm.icmp "eq" %67, %6 : i32
          %69 = llvm.icmp "eq" %67, %7 : i32
          %70 = llvm.or %68, %69 : i1
          %71 = llvm.icmp "sgt" %67, %6 : i32
          %72 = llvm.fmul %65, %65 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %73 = llvm.select %70, %19, %65 : i1, f32
          %74 = llvm.select %70, %12, %17 : i1, f32
          %75 = llvm.select %70, %11, %16 : i1, f32
          %76 = llvm.select %70, %10, %15 : i1, f32
          %77 = llvm.select %70, %9, %14 : i1, f32
          %78 = llvm.select %70, %8, %13 : i1, f32
          %79 = llvm.intr.fma(%72, %78, %77) : (f32, f32, f32) -> f32
          %80 = llvm.intr.fma(%72, %79, %76) : (f32, f32, f32) -> f32
          %81 = llvm.intr.fma(%72, %80, %75) : (f32, f32, f32) -> f32
          %82 = llvm.intr.fma(%72, %81, %74) : (f32, f32, f32) -> f32
          %83 = llvm.intr.fma(%72, %82, %19) : (f32, f32, f32) -> f32
          %84 = llvm.fmul %73, %83 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %85 = llvm.fmul %84, %18 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %86 = llvm.select %71, %85, %84 : i1, f32
          %87 = llvm.fadd %86, %61 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %87, %32 : f32, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_9 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_9_elementwise_1x2_f32 ordinal(0) layout(#pipeline_layout3) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.mlir.global private constant @__constant_1x2xf32(dense<[[0.036251314, -0.0380887836]]> : tensor<1x2xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<1 x array<2 x f32>>
        llvm.func @_main$async_dispatch_9_elementwise_1x2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(8 : i64) : i64
          %2 = llvm.mlir.constant(32 : i64) : i64
          %3 = llvm.mlir.constant(64 : index) : i64
          %4 = llvm.mlir.constant(true) : i1
          %5 = llvm.mlir.addressof @__constant_1x2xf32 : !llvm.ptr
          %6 = llvm.mlir.constant(128 : index) : i64
          %7 = llvm.mlir.constant(0 : index) : i64
          %8 = llvm.mlir.constant(2 : index) : i64
          %9 = llvm.getelementptr %5[0, 0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<1 x array<2 x f32>>
          %10 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %11 = llvm.extractvalue %10[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %12 = llvm.load %11 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %4 ["align"(%12, %3 : !llvm.ptr, i64)] : i1
          %13 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %14 = llvm.extractvalue %13[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %15 = llvm.getelementptr %14[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %16 = llvm.load %15 : !llvm.ptr -> !llvm.ptr
          %17 = llvm.mul %6, %1 : i64
          %18 = llvm.udiv %17, %2 : i64
          %19 = llvm.getelementptr %16[%18] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%19, %3 : !llvm.ptr, i64)] : i1
          %20 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %21 = llvm.extractvalue %20[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %22 = llvm.getelementptr %21[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %23 = llvm.load %22 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %4 ["align"(%23, %3 : !llvm.ptr, i64)] : i1
          %24 = llvm.mul %7, %8 : i64
          %25 = llvm.add %24, %7 : i64
          %26 = llvm.getelementptr %12[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %27 = llvm.load %26 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %28 = llvm.getelementptr %9[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %29 = llvm.load %28 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %30 = llvm.getelementptr %19[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %31 = llvm.load %30 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %32 = llvm.fadd %27, %29 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %33 = llvm.fsub %32, %31 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %34 = llvm.getelementptr %23[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %33, %34 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_10 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_10_elementwise_broadcast ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_10_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(64 : index) : i64
          %2 = llvm.mlir.constant(true) : i1
          %3 = llvm.mlir.constant(8 : i64) : i64
          %4 = llvm.mlir.constant(32 : i64) : i64
          %5 = llvm.mlir.constant(1 : i32) : i32
          %6 = llvm.mlir.constant(3 : i32) : i32
          %7 = llvm.mlir.constant(-2.59630184E-7 : f32) : f32
          %8 = llvm.mlir.constant(2.47562348E-5 : f32) : f32
          %9 = llvm.mlir.constant(-0.00138883304 : f32) : f32
          %10 = llvm.mlir.constant(0.0416666418 : f32) : f32
          %11 = llvm.mlir.constant(-5.000000e-01 : f32) : f32
          %12 = llvm.mlir.constant(-2.50293279E-8 : f32) : f32
          %13 = llvm.mlir.constant(2.76001265E-6 : f32) : f32
          %14 = llvm.mlir.constant(-1.98426045E-4 : f32) : f32
          %15 = llvm.mlir.constant(0.00833334774 : f32) : f32
          %16 = llvm.mlir.constant(-0.166666672 : f32) : f32
          %17 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %18 = llvm.mlir.constant(1.57079637 : f32) : f32
          %19 = llvm.mlir.constant(0.636619746 : f32) : f32
          %20 = llvm.mlir.constant(-1.000000e+00 : f32) : f32
          %21 = llvm.mlir.constant(128 : index) : i64
          %22 = llvm.mlir.constant(192 : index) : i64
          %23 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %24 = llvm.extractvalue %23[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %25 = llvm.load %24 : !llvm.ptr -> !llvm.ptr
          %26 = llvm.mul %21, %3 : i64
          %27 = llvm.udiv %26, %4 : i64
          %28 = llvm.getelementptr %25[%27] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%28, %1 : !llvm.ptr, i64)] : i1
          %29 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %30 = llvm.extractvalue %29[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %31 = llvm.getelementptr %30[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %32 = llvm.load %31 : !llvm.ptr -> !llvm.ptr
          %33 = llvm.mul %22, %3 : i64
          %34 = llvm.udiv %33, %4 : i64
          %35 = llvm.getelementptr %32[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%35, %1 : !llvm.ptr, i64)] : i1
          %36 = llvm.load %28 : !llvm.ptr -> f32
          %37 = llvm.getelementptr inbounds|nuw %28[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %38 = llvm.load %37 : !llvm.ptr -> f32
          %39 = llvm.fadd %36, %38 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %40 = llvm.fmul %39, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %41 = llvm.intr.floor(%40) : (f32) -> f32
          %42 = llvm.fmul %41, %18 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %43 = llvm.fsub %39, %42 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %44 = llvm.fptosi %41 : f32 to i32
          %45 = llvm.and %44, %6 : i32
          %46 = llvm.icmp "eq" %45, %5 : i32
          %47 = llvm.icmp "eq" %45, %6 : i32
          %48 = llvm.or %46, %47 : i1
          %49 = llvm.icmp "sgt" %45, %5 : i32
          %50 = llvm.fmul %43, %43 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %51 = llvm.select %48, %17, %43 : i1, f32
          %52 = llvm.select %48, %11, %16 : i1, f32
          %53 = llvm.select %48, %10, %15 : i1, f32
          %54 = llvm.select %48, %9, %14 : i1, f32
          %55 = llvm.select %48, %8, %13 : i1, f32
          %56 = llvm.select %48, %7, %12 : i1, f32
          %57 = llvm.intr.fma(%50, %56, %55) : (f32, f32, f32) -> f32
          %58 = llvm.intr.fma(%50, %57, %54) : (f32, f32, f32) -> f32
          %59 = llvm.intr.fma(%50, %58, %53) : (f32, f32, f32) -> f32
          %60 = llvm.intr.fma(%50, %59, %52) : (f32, f32, f32) -> f32
          %61 = llvm.intr.fma(%50, %60, %17) : (f32, f32, f32) -> f32
          %62 = llvm.fmul %51, %61 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %63 = llvm.fmul %62, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %64 = llvm.select %49, %63, %62 : i1, f32
          %65 = llvm.fmul %36, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %66 = llvm.intr.floor(%65) : (f32) -> f32
          %67 = llvm.fmul %66, %18 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %68 = llvm.fsub %36, %67 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %69 = llvm.fptosi %66 : f32 to i32
          %70 = llvm.and %69, %6 : i32
          %71 = llvm.icmp "eq" %70, %5 : i32
          %72 = llvm.icmp "eq" %70, %6 : i32
          %73 = llvm.or %71, %72 : i1
          %74 = llvm.icmp "sgt" %70, %5 : i32
          %75 = llvm.fmul %68, %68 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %76 = llvm.select %73, %17, %68 : i1, f32
          %77 = llvm.select %73, %11, %16 : i1, f32
          %78 = llvm.select %73, %10, %15 : i1, f32
          %79 = llvm.select %73, %9, %14 : i1, f32
          %80 = llvm.select %73, %8, %13 : i1, f32
          %81 = llvm.select %73, %7, %12 : i1, f32
          %82 = llvm.intr.fma(%75, %81, %80) : (f32, f32, f32) -> f32
          %83 = llvm.intr.fma(%75, %82, %79) : (f32, f32, f32) -> f32
          %84 = llvm.intr.fma(%75, %83, %78) : (f32, f32, f32) -> f32
          %85 = llvm.intr.fma(%75, %84, %77) : (f32, f32, f32) -> f32
          %86 = llvm.intr.fma(%75, %85, %17) : (f32, f32, f32) -> f32
          %87 = llvm.fmul %76, %86 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %88 = llvm.fmul %87, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %89 = llvm.select %74, %88, %87 : i1, f32
          %90 = llvm.fmul %89, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %91 = llvm.fsub %90, %64 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %91, %35 : f32, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_11 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_11_elementwise_broadcast ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_11_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(4 : index) : i64
          %2 = llvm.mlir.constant(64 : index) : i64
          %3 = llvm.mlir.constant(true) : i1
          %4 = llvm.mlir.constant(8 : i64) : i64
          %5 = llvm.mlir.constant(32 : i64) : i64
          %6 = llvm.mlir.constant(1 : i32) : i32
          %7 = llvm.mlir.constant(3 : i32) : i32
          %8 = llvm.mlir.constant(-2.59630184E-7 : f32) : f32
          %9 = llvm.mlir.constant(2.47562348E-5 : f32) : f32
          %10 = llvm.mlir.constant(-0.00138883304 : f32) : f32
          %11 = llvm.mlir.constant(0.0416666418 : f32) : f32
          %12 = llvm.mlir.constant(-5.000000e-01 : f32) : f32
          %13 = llvm.mlir.constant(-2.50293279E-8 : f32) : f32
          %14 = llvm.mlir.constant(2.76001265E-6 : f32) : f32
          %15 = llvm.mlir.constant(-1.98426045E-4 : f32) : f32
          %16 = llvm.mlir.constant(0.00833334774 : f32) : f32
          %17 = llvm.mlir.constant(-0.166666672 : f32) : f32
          %18 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %19 = llvm.mlir.constant(1.57079637 : f32) : f32
          %20 = llvm.mlir.constant(0.636619746 : f32) : f32
          %21 = llvm.mlir.constant(-1.000000e+00 : f32) : f32
          %22 = llvm.mlir.constant(128 : index) : i64
          %23 = llvm.mlir.constant(196 : index) : i64
          %24 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %25 = llvm.extractvalue %24[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %26 = llvm.load %25 : !llvm.ptr -> !llvm.ptr
          %27 = llvm.mul %22, %4 : i64
          %28 = llvm.udiv %27, %5 : i64
          %29 = llvm.getelementptr %26[%28] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%29, %2 : !llvm.ptr, i64)] : i1
          %30 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %31 = llvm.extractvalue %30[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %32 = llvm.getelementptr %31[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %33 = llvm.load %32 : !llvm.ptr -> !llvm.ptr
          %34 = llvm.mul %23, %4 : i64
          %35 = llvm.udiv %34, %5 : i64
          %36 = llvm.getelementptr %33[%35] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%36, %1 : !llvm.ptr, i64)] : i1
          %37 = llvm.load %29 : !llvm.ptr -> f32
          %38 = llvm.getelementptr inbounds|nuw %29[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %39 = llvm.load %38 : !llvm.ptr -> f32
          %40 = llvm.fadd %37, %39 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %41 = llvm.fmul %40, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %42 = llvm.intr.floor(%41) : (f32) -> f32
          %43 = llvm.fmul %42, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %44 = llvm.fsub %40, %43 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %45 = llvm.fptosi %42 : f32 to i32
          %46 = llvm.and %45, %7 : i32
          %47 = llvm.icmp "eq" %46, %6 : i32
          %48 = llvm.icmp "eq" %46, %7 : i32
          %49 = llvm.or %47, %48 : i1
          %50 = llvm.icmp "sgt" %46, %6 : i32
          %51 = llvm.fmul %44, %44 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %52 = llvm.select %49, %18, %44 : i1, f32
          %53 = llvm.select %49, %12, %17 : i1, f32
          %54 = llvm.select %49, %11, %16 : i1, f32
          %55 = llvm.select %49, %10, %15 : i1, f32
          %56 = llvm.select %49, %9, %14 : i1, f32
          %57 = llvm.select %49, %8, %13 : i1, f32
          %58 = llvm.intr.fma(%51, %57, %56) : (f32, f32, f32) -> f32
          %59 = llvm.intr.fma(%51, %58, %55) : (f32, f32, f32) -> f32
          %60 = llvm.intr.fma(%51, %59, %54) : (f32, f32, f32) -> f32
          %61 = llvm.intr.fma(%51, %60, %53) : (f32, f32, f32) -> f32
          %62 = llvm.intr.fma(%51, %61, %18) : (f32, f32, f32) -> f32
          %63 = llvm.fmul %52, %62 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %64 = llvm.fmul %63, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %65 = llvm.select %50, %64, %63 : i1, f32
          %66 = llvm.fmul %65, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %66, %36 : f32, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_12 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_12_elementwise_broadcast_2_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_12_elementwise_broadcast_2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(0 : i64) : i64
          %2 = llvm.mlir.constant(dense<[0, 1]> : vector<2xindex>) : vector<2xi64>
          %3 = llvm.mlir.constant(true) : i1
          %4 = llvm.mlir.constant(2 : index) : i64
          %5 = llvm.mlir.constant(8 : i64) : i64
          %6 = llvm.mlir.constant(32 : i64) : i64
          %7 = llvm.mlir.constant(0 : index) : i64
          %8 = llvm.mlir.constant(128 : index) : i64
          %9 = llvm.mlir.constant(64 : index) : i64
          %10 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %11 = llvm.extractvalue %10[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %12 = llvm.load %11 : !llvm.ptr -> !llvm.ptr
          %13 = llvm.mul %8, %5 : i64
          %14 = llvm.udiv %13, %6 : i64
          %15 = llvm.getelementptr %12[%14] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%15, %9 : !llvm.ptr, i64)] : i1
          %16 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %17 = llvm.extractvalue %16[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %18 = llvm.getelementptr %17[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %19 = llvm.load %18 : !llvm.ptr -> !llvm.ptr
          %20 = llvm.mul %9, %5 : i64
          %21 = llvm.udiv %20, %6 : i64
          %22 = llvm.getelementptr %19[%21] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%22, %9 : !llvm.ptr, i64)] : i1
          %23 = llvm.extractelement %2[%1 : i64] : vector<2xi64>
          %24 = llvm.mul %7, %4 : i64
          %25 = llvm.add %24, %23 : i64
          %26 = llvm.getelementptr %15[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %27 = llvm.load %26 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          llvm.store %27, %22 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_13 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_13_elementwise_broadcast ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_13_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(4 : index) : i64
          %2 = llvm.mlir.constant(true) : i1
          %3 = llvm.mlir.constant(8 : i64) : i64
          %4 = llvm.mlir.constant(32 : i64) : i64
          %5 = llvm.mlir.constant(64 : index) : i64
          %6 = llvm.mlir.constant(260 : index) : i64
          %7 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %8 = llvm.extractvalue %7[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %9 = llvm.load %8 : !llvm.ptr -> !llvm.ptr
          %10 = llvm.mul %5, %3 : i64
          %11 = llvm.udiv %10, %4 : i64
          %12 = llvm.getelementptr %9[%11] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%12, %5 : !llvm.ptr, i64)] : i1
          %13 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %14 = llvm.extractvalue %13[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %15 = llvm.getelementptr %14[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %16 = llvm.load %15 : !llvm.ptr -> !llvm.ptr
          %17 = llvm.mul %6, %3 : i64
          %18 = llvm.udiv %17, %4 : i64
          %19 = llvm.getelementptr %16[%18] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%19, %1 : !llvm.ptr, i64)] : i1
          %20 = llvm.load %12 : !llvm.ptr -> f32
          llvm.store %20, %19 : f32, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_14 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_14_elementwise_broadcast_2_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_14_elementwise_broadcast_2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(0 : i64) : i64
          %2 = llvm.mlir.constant(dense<[0, 1]> : vector<2xindex>) : vector<2xi64>
          %3 = llvm.mlir.constant(64 : index) : i64
          %4 = llvm.mlir.constant(true) : i1
          %5 = llvm.mlir.constant(2 : index) : i64
          %6 = llvm.mlir.constant(8 : i64) : i64
          %7 = llvm.mlir.constant(32 : i64) : i64
          %8 = llvm.mlir.constant(1 : index) : i64
          %9 = llvm.mlir.constant(128 : index) : i64
          %10 = llvm.mlir.constant(192 : index) : i64
          %11 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %12 = llvm.extractvalue %11[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %13 = llvm.load %12 : !llvm.ptr -> !llvm.ptr
          %14 = llvm.mul %9, %6 : i64
          %15 = llvm.udiv %14, %7 : i64
          %16 = llvm.getelementptr %13[%15] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%16, %3 : !llvm.ptr, i64)] : i1
          %17 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %18 = llvm.extractvalue %17[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %19 = llvm.getelementptr %18[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %20 = llvm.load %19 : !llvm.ptr -> !llvm.ptr
          %21 = llvm.mul %10, %6 : i64
          %22 = llvm.udiv %21, %7 : i64
          %23 = llvm.getelementptr %20[%22] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%23, %3 : !llvm.ptr, i64)] : i1
          %24 = llvm.extractelement %2[%1 : i64] : vector<2xi64>
          %25 = llvm.mul %8, %5 : i64
          %26 = llvm.add %25, %24 : i64
          %27 = llvm.getelementptr %16[%26] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %28 = llvm.load %27 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          llvm.store %28, %23 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_15 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_15_elementwise_broadcast ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_15_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(64 : index) : i64
          %2 = llvm.mlir.constant(true) : i1
          %3 = llvm.mlir.constant(8 : i64) : i64
          %4 = llvm.mlir.constant(32 : i64) : i64
          %5 = llvm.mlir.constant(192 : index) : i64
          %6 = llvm.mlir.constant(128 : index) : i64
          %7 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %8 = llvm.extractvalue %7[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %9 = llvm.load %8 : !llvm.ptr -> !llvm.ptr
          %10 = llvm.mul %5, %3 : i64
          %11 = llvm.udiv %10, %4 : i64
          %12 = llvm.getelementptr %9[%11] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%12, %1 : !llvm.ptr, i64)] : i1
          %13 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %14 = llvm.extractvalue %13[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %15 = llvm.getelementptr %14[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %16 = llvm.load %15 : !llvm.ptr -> !llvm.ptr
          %17 = llvm.mul %6, %3 : i64
          %18 = llvm.udiv %17, %4 : i64
          %19 = llvm.getelementptr %16[%18] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%19, %1 : !llvm.ptr, i64)] : i1
          %20 = llvm.getelementptr inbounds|nuw %12[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %21 = llvm.load %20 : !llvm.ptr -> f32
          llvm.store %21, %19 : f32, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_16 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_16_elementwise_broadcast ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_16_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(4 : index) : i64
          %2 = llvm.mlir.constant(true) : i1
          %3 = llvm.mlir.constant(8 : i64) : i64
          %4 = llvm.mlir.constant(32 : i64) : i64
          %5 = llvm.mlir.constant(64 : index) : i64
          %6 = llvm.mlir.constant(132 : index) : i64
          %7 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %8 = llvm.extractvalue %7[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %9 = llvm.load %8 : !llvm.ptr -> !llvm.ptr
          %10 = llvm.mul %5, %3 : i64
          %11 = llvm.udiv %10, %4 : i64
          %12 = llvm.getelementptr %9[%11] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%12, %5 : !llvm.ptr, i64)] : i1
          %13 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %14 = llvm.extractvalue %13[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %15 = llvm.getelementptr %14[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %16 = llvm.load %15 : !llvm.ptr -> !llvm.ptr
          %17 = llvm.mul %6, %3 : i64
          %18 = llvm.udiv %17, %4 : i64
          %19 = llvm.getelementptr %16[%18] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%19, %1 : !llvm.ptr, i64)] : i1
          %20 = llvm.getelementptr inbounds|nuw %12[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %21 = llvm.load %20 : !llvm.ptr -> f32
          %22 = llvm.fneg %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %22, %19 : f32, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_17 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_17_elementwise_broadcast ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_17_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(64 : index) : i64
          %2 = llvm.mlir.constant(true) : i1
          %3 = llvm.mlir.constant(8 : i64) : i64
          %4 = llvm.mlir.constant(32 : i64) : i64
          %5 = llvm.mlir.constant(192 : index) : i64
          %6 = llvm.mlir.constant(128 : index) : i64
          %7 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %8 = llvm.extractvalue %7[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %9 = llvm.load %8 : !llvm.ptr -> !llvm.ptr
          %10 = llvm.mul %5, %3 : i64
          %11 = llvm.udiv %10, %4 : i64
          %12 = llvm.getelementptr %9[%11] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%12, %1 : !llvm.ptr, i64)] : i1
          %13 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %14 = llvm.extractvalue %13[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %15 = llvm.getelementptr %14[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %16 = llvm.load %15 : !llvm.ptr -> !llvm.ptr
          %17 = llvm.mul %6, %3 : i64
          %18 = llvm.udiv %17, %4 : i64
          %19 = llvm.getelementptr %16[%18] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%19, %1 : !llvm.ptr, i64)] : i1
          %20 = llvm.load %12 : !llvm.ptr -> f32
          %21 = llvm.fneg %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %21, %19 : f32, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_18 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_18_elementwise_2x2_f32_pack ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_18_elementwise_2x2_f32_pack(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(1 : i64) : i64
          %2 = llvm.mlir.constant(0 : i64) : i64
          %3 = llvm.mlir.constant(16 : index) : i64
          %4 = llvm.mlir.constant(true) : i1
          %5 = llvm.mlir.constant(8 : i64) : i64
          %6 = llvm.mlir.constant(32 : i64) : i64
          %7 = llvm.mlir.constant(8 : index) : i64
          %8 = llvm.mlir.poison : vector<2xf32>
          %9 = llvm.mlir.constant(128 : index) : i64
          %10 = llvm.mlir.constant(320 : index) : i64
          %11 = llvm.mlir.constant(192 : index) : i64
          %12 = llvm.mlir.constant(64 : index) : i64
          %13 = llvm.mlir.constant(1 : index) : i64
          %14 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %15 = llvm.mlir.constant(0 : index) : i64
          %16 = llvm.mlir.constant(2 : index) : i64
          %17 = llvm.mlir.constant(dense<9.99999997E-7> : vector<f32>) : vector<1xf32>
          %18 = llvm.mlir.constant(dense<1.000000e+00> : vector<f32>) : vector<1xf32>
          %19 = llvm.alloca %16 x f32 {alignment = 64 : i64} : (i64) -> !llvm.ptr
          %20 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %21 = llvm.extractvalue %20[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %22 = llvm.load %21 : !llvm.ptr -> !llvm.ptr
          %23 = llvm.mul %12, %5 : i64
          %24 = llvm.udiv %23, %6 : i64
          %25 = llvm.getelementptr %22[%24] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%25, %12 : !llvm.ptr, i64)] : i1
          %26 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %27 = llvm.extractvalue %26[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %28 = llvm.load %27 : !llvm.ptr -> !llvm.ptr
          %29 = llvm.mul %11, %5 : i64
          %30 = llvm.udiv %29, %6 : i64
          %31 = llvm.getelementptr %28[%30] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%31, %12 : !llvm.ptr, i64)] : i1
          %32 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %33 = llvm.extractvalue %32[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %34 = llvm.load %33 : !llvm.ptr -> !llvm.ptr
          %35 = llvm.mul %10, %5 : i64
          %36 = llvm.udiv %35, %6 : i64
          %37 = llvm.getelementptr %34[%36] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%37, %12 : !llvm.ptr, i64)] : i1
          %38 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %39 = llvm.extractvalue %38[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %40 = llvm.getelementptr %39[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %41 = llvm.load %40 : !llvm.ptr -> !llvm.ptr
          %42 = llvm.mul %9, %5 : i64
          %43 = llvm.udiv %42, %6 : i64
          %44 = llvm.getelementptr %41[%43] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%44, %12 : !llvm.ptr, i64)] : i1
          %45 = llvm.alloca %7 x f32 {alignment = 32 : i64} : (i64) -> !llvm.ptr
          %46 = llvm.load %25 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %47 = llvm.getelementptr %31[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %48 = llvm.load %47 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %49 = llvm.getelementptr %25[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %50 = llvm.load %49 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %51 = llvm.load %31 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %52 = llvm.fmul %50, %51 {fastmathFlags = #llvm.fastmath<contract>} : vector<1xf32>
          %53 = llvm.fmul %46, %48 {fastmathFlags = #llvm.fastmath<contract>} : vector<1xf32>
          %54 = llvm.fsub %53, %52 {fastmathFlags = #llvm.fastmath<contract>} : vector<1xf32>
          %55 = llvm.fadd %54, %17 {fastmathFlags = #llvm.fastmath<contract>} : vector<1xf32>
          %56 = llvm.fdiv %18, %55 : vector<1xf32>
          llvm.br ^bb1(%15 : i64)
        ^bb1(%57: i64):  // 2 preds: ^bb0, ^bb7
          %58 = llvm.icmp "slt" %57, %16 : i64
          llvm.cond_br %58, ^bb2, ^bb8
        ^bb2:  // pred: ^bb1
          %59 = llvm.mul %15, %16 : i64
          %60 = llvm.add %59, %57 : i64
          %61 = llvm.getelementptr %37[%60] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %62 = llvm.load %61 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %63 = llvm.mul %13, %16 : i64
          %64 = llvm.add %63, %57 : i64
          %65 = llvm.getelementptr %37[%64] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %66 = llvm.load %65 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %67 = llvm.extractelement %62[%2 : i64] : vector<1xf32>
          %68 = llvm.insertelement %67, %8[%2 : i64] : vector<2xf32>
          %69 = llvm.extractelement %66[%2 : i64] : vector<1xf32>
          %70 = llvm.insertelement %69, %68[%1 : i64] : vector<2xf32>
          %71 = llvm.extractelement %56[%2 : i64] : vector<1xf32>
          %72 = llvm.insertelement %71, %8[%0 : i32] : vector<2xf32>
          %73 = llvm.shufflevector %72, %8 [0, 0] : vector<2xf32> 
          %74 = llvm.fmul %70, %73 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %75 = llvm.add %15, %15 : i64
          %76 = llvm.getelementptr %19[%75] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %74, %76 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.br ^bb3(%15 : i64)
        ^bb3(%77: i64):  // 2 preds: ^bb2, ^bb4
          %78 = llvm.icmp "slt" %77, %7 : i64
          llvm.cond_br %78, ^bb4, ^bb5(%15 : i64)
        ^bb4:  // pred: ^bb3
          %79 = llvm.getelementptr inbounds|nuw %45[%77] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %14, %79 : f32, !llvm.ptr
          %80 = llvm.add %77, %13 : i64
          llvm.br ^bb3(%80 : i64)
        ^bb5(%81: i64):  // 2 preds: ^bb3, ^bb6
          %82 = llvm.icmp "slt" %81, %16 : i64
          llvm.cond_br %82, ^bb6, ^bb7
        ^bb6:  // pred: ^bb5
          %83 = llvm.add %81, %15 overflow<nsw, nuw> : i64
          %84 = llvm.getelementptr inbounds|nuw %19[%83] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %85 = llvm.load %84 : !llvm.ptr -> f32
          %86 = llvm.getelementptr inbounds|nuw %45[%81] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %85, %86 : f32, !llvm.ptr
          %87 = llvm.add %81, %13 : i64
          llvm.br ^bb5(%87 : i64)
        ^bb7:  // pred: ^bb5
          %88 = llvm.load %45 {alignment = 4 : i64} : !llvm.ptr -> vector<8xf32>
          %89 = llvm.mul %15, %3 : i64
          %90 = llvm.mul %57, %7 : i64
          %91 = llvm.add %89, %90 : i64
          %92 = llvm.add %91, %15 : i64
          %93 = llvm.add %92, %15 : i64
          %94 = llvm.getelementptr %44[%93] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %88, %94 {alignment = 4 : i64} : vector<8xf32>, !llvm.ptr
          %95 = llvm.add %57, %13 : i64
          llvm.br ^bb1(%95 : i64)
        ^bb8:  // pred: ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_19 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_19_mmt4d_1x1x2x1x8x1_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @iree_uk_mmt4d(!llvm.ptr, i64, i64, !llvm.ptr, i64, i64, !llvm.ptr, i64, i64, i64, i64, i64, i32, i32, i32, i32, !llvm.ptr) -> i32 attributes {hal.import.bitcode = true, hal.import.fields = ["processor_data"], llvm.bareptr = true}
        llvm.func @_main$async_dispatch_19_mmt4d_1x1x2x1x8x1_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(52255 : i64) : i64
          %1 = llvm.mlir.constant(8 : i64) : i64
          %2 = llvm.mlir.constant(0 : i32) : i32
          %3 = llvm.mlir.constant(32 : index) : i64
          %4 = llvm.mlir.constant(8 : index) : i64
          %5 = llvm.mlir.constant(16 : index) : i64
          %6 = llvm.mlir.constant(1537 : i32) : i32
          %7 = llvm.mlir.constant(8 : i32) : i32
          %8 = llvm.mlir.constant(1 : i32) : i32
          %9 = llvm.mlir.constant(2 : index) : i64
          %10 = llvm.mlir.constant(1 : index) : i64
          %11 = llvm.mlir.constant(0 : index) : i64
          %12 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %13 = llvm.extractvalue %12[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %14 = llvm.load %13 : !llvm.ptr -> !llvm.ptr
          %15 = llvm.getelementptr %13[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %16 = llvm.load %15 : !llvm.ptr -> !llvm.ptr
          %17 = llvm.getelementptr inbounds %arg0[4] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %18 = llvm.alloca %1 x i64 {alignment = 8 : i64} : (i64) -> !llvm.ptr
          %19 = llvm.load %17 : !llvm.ptr -> i64
          %20 = llvm.or %19, %0 : i64
          llvm.store %20, %18 : i64, !llvm.ptr
          %21 = llvm.getelementptr inbounds %17[1] : (!llvm.ptr) -> !llvm.ptr, i64
          %22 = llvm.load %21 : !llvm.ptr -> i64
          %23 = llvm.getelementptr inbounds %18[1] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %22, %23 : i64, !llvm.ptr
          %24 = llvm.getelementptr inbounds %17[2] : (!llvm.ptr) -> !llvm.ptr, i64
          %25 = llvm.load %24 : !llvm.ptr -> i64
          %26 = llvm.getelementptr inbounds %18[2] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %25, %26 : i64, !llvm.ptr
          %27 = llvm.getelementptr inbounds %17[3] : (!llvm.ptr) -> !llvm.ptr, i64
          %28 = llvm.load %27 : !llvm.ptr -> i64
          %29 = llvm.getelementptr inbounds %18[3] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %28, %29 : i64, !llvm.ptr
          %30 = llvm.getelementptr inbounds %17[4] : (!llvm.ptr) -> !llvm.ptr, i64
          %31 = llvm.load %30 : !llvm.ptr -> i64
          %32 = llvm.getelementptr inbounds %18[4] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %31, %32 : i64, !llvm.ptr
          %33 = llvm.getelementptr inbounds %17[5] : (!llvm.ptr) -> !llvm.ptr, i64
          %34 = llvm.load %33 : !llvm.ptr -> i64
          %35 = llvm.getelementptr inbounds %18[5] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %34, %35 : i64, !llvm.ptr
          %36 = llvm.getelementptr inbounds %17[6] : (!llvm.ptr) -> !llvm.ptr, i64
          %37 = llvm.load %36 : !llvm.ptr -> i64
          %38 = llvm.getelementptr inbounds %18[6] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %37, %38 : i64, !llvm.ptr
          %39 = llvm.getelementptr inbounds %17[7] : (!llvm.ptr) -> !llvm.ptr, i64
          %40 = llvm.load %39 : !llvm.ptr -> i64
          %41 = llvm.getelementptr inbounds %18[7] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %40, %41 : i64, !llvm.ptr
          %42 = llvm.call @iree_uk_mmt4d(%14, %11, %9, %14, %3, %5, %16, %5, %4, %10, %10, %9, %8, %7, %8, %6, %18) : (!llvm.ptr, i64, i64, !llvm.ptr, i64, i64, !llvm.ptr, i64, i64, i64, i64, i64, i32, i32, i32, i32, !llvm.ptr) -> i32
          llvm.return %2 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_20 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_20_unpack_elementwise_2_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_20_unpack_elementwise_2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(true) : i1
          %2 = llvm.mlir.constant(8 : index) : i64
          %3 = llvm.mlir.constant(8 : i64) : i64
          %4 = llvm.mlir.constant(32 : i64) : i64
          %5 = llvm.mlir.constant(1 : index) : i64
          %6 = llvm.mlir.constant(2 : index) : i64
          %7 = llvm.mlir.constant(0 : index) : i64
          %8 = llvm.mlir.constant(64 : index) : i64
          %9 = llvm.mlir.constant(dense<1.000000e-01> : vector<2xf32>) : vector<2xf32>
          %10 = llvm.alloca %6 x f32 {alignment = 64 : i64} : (i64) -> !llvm.ptr
          %11 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %12 = llvm.extractvalue %11[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %13 = llvm.load %12 : !llvm.ptr -> !llvm.ptr
          %14 = llvm.mul %8, %3 : i64
          %15 = llvm.udiv %14, %4 : i64
          %16 = llvm.getelementptr %13[%15] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %1 ["align"(%16, %8 : !llvm.ptr, i64)] : i1
          %17 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %18 = llvm.extractvalue %17[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %19 = llvm.load %18 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %1 ["align"(%19, %8 : !llvm.ptr, i64)] : i1
          %20 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %21 = llvm.extractvalue %20[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %22 = llvm.getelementptr %21[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %23 = llvm.load %22 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %1 ["align"(%23, %8 : !llvm.ptr, i64)] : i1
          %24 = llvm.alloca %2 x f32 {alignment = 32 : i64} : (i64) -> !llvm.ptr
          %25 = llvm.mul %7, %2 : i64
          %26 = llvm.add %25, %7 : i64
          %27 = llvm.getelementptr %16[%26] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %28 = llvm.load %27 {alignment = 4 : i64} : !llvm.ptr -> vector<8xf32>
          llvm.store %28, %24 {alignment = 4 : i64} : vector<8xf32>, !llvm.ptr
          llvm.br ^bb1(%7 : i64)
        ^bb1(%29: i64):  // 2 preds: ^bb0, ^bb2
          %30 = llvm.icmp "slt" %29, %6 : i64
          llvm.cond_br %30, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %31 = llvm.getelementptr inbounds|nuw %24[%29] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %32 = llvm.load %31 : !llvm.ptr -> f32
          %33 = llvm.getelementptr inbounds|nuw %10[%29] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %32, %33 : f32, !llvm.ptr
          %34 = llvm.add %29, %5 : i64
          llvm.br ^bb1(%34 : i64)
        ^bb3:  // pred: ^bb1
          %35 = llvm.load %19 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %36 = llvm.load %10 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %37 = llvm.fmul %36, %9 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %38 = llvm.fadd %35, %37 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          llvm.store %38, %23 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_21 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_21_reduction_2_f32 ordinal(0) layout(#pipeline_layout3) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_21_reduction_2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(8 : i64) : i64
          %2 = llvm.mlir.constant(32 : i64) : i64
          %3 = llvm.mlir.constant(true) : i1
          %4 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %5 = llvm.mlir.constant(64 : index) : i64
          %6 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %7 = llvm.extractvalue %6[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %8 = llvm.load %7 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %3 ["align"(%8, %5 : !llvm.ptr, i64)] : i1
          %9 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %10 = llvm.extractvalue %9[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %11 = llvm.getelementptr %10[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %12 = llvm.load %11 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %3 ["align"(%12, %5 : !llvm.ptr, i64)] : i1
          %13 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %14 = llvm.extractvalue %13[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %15 = llvm.getelementptr %14[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %16 = llvm.load %15 : !llvm.ptr -> !llvm.ptr
          %17 = llvm.mul %5, %1 : i64
          %18 = llvm.udiv %17, %2 : i64
          %19 = llvm.getelementptr %16[%18] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%19, %5 : !llvm.ptr, i64)] : i1
          %20 = llvm.load %8 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %21 = llvm.load %12 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %22 = llvm.fsub %20, %21 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %23 = llvm.fmul %22, %22 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %24 = "llvm.intr.vector.reduce.fadd"(%4, %23) <{fastmathFlags = #llvm.fastmath<reassoc>}> : (f32, vector<2xf32>) -> f32
          llvm.store %24, %19 : f32, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_22 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_22_elementwise_broadcast ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_22_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(64 : index) : i64
          %1 = llvm.mlir.constant(true) : i1
          %2 = llvm.mlir.constant(2 : i32) : i32
          %3 = llvm.mlir.constant(1 : i32) : i32
          %4 = llvm.mlir.constant(0 : i32) : i32
          %5 = llvm.mlir.constant(3 : i32) : i32
          %6 = llvm.mlir.constant(-2.59630184E-7 : f32) : f32
          %7 = llvm.mlir.constant(2.47562348E-5 : f32) : f32
          %8 = llvm.mlir.constant(-0.00138883304 : f32) : f32
          %9 = llvm.mlir.constant(0.0416666418 : f32) : f32
          %10 = llvm.mlir.constant(-5.000000e-01 : f32) : f32
          %11 = llvm.mlir.constant(-2.50293279E-8 : f32) : f32
          %12 = llvm.mlir.constant(2.76001265E-6 : f32) : f32
          %13 = llvm.mlir.constant(-1.98426045E-4 : f32) : f32
          %14 = llvm.mlir.constant(0.00833334774 : f32) : f32
          %15 = llvm.mlir.constant(-0.166666672 : f32) : f32
          %16 = llvm.mlir.constant(-1.000000e+00 : f32) : f32
          %17 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %18 = llvm.mlir.constant(1.57079637 : f32) : f32
          %19 = llvm.mlir.constant(0.636619746 : f32) : f32
          %20 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %21 = llvm.extractvalue %20[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %22 = llvm.load %21 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %1 ["align"(%22, %0 : !llvm.ptr, i64)] : i1
          %23 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %24 = llvm.extractvalue %23[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %25 = llvm.getelementptr %24[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %26 = llvm.load %25 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %1 ["align"(%26, %0 : !llvm.ptr, i64)] : i1
          %27 = llvm.getelementptr inbounds|nuw %22[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %28 = llvm.load %27 : !llvm.ptr -> f32
          %29 = llvm.load %22 : !llvm.ptr -> f32
          %30 = llvm.fadd %29, %28 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %31 = llvm.fmul %30, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %32 = llvm.intr.floor(%31) : (f32) -> f32
          %33 = llvm.fmul %32, %18 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %34 = llvm.fsub %30, %33 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %35 = llvm.fptosi %32 : f32 to i32
          %36 = llvm.and %35, %5 : i32
          %37 = llvm.icmp "eq" %36, %4 : i32
          %38 = llvm.icmp "eq" %36, %3 : i32
          %39 = llvm.icmp "eq" %36, %2 : i32
          %40 = llvm.or %37, %39 : i1
          %41 = llvm.or %38, %39 : i1
          %42 = llvm.fmul %34, %34 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %43 = llvm.select %40, %17, %34 : i1, f32
          %44 = llvm.select %40, %10, %15 : i1, f32
          %45 = llvm.select %40, %9, %14 : i1, f32
          %46 = llvm.select %40, %8, %13 : i1, f32
          %47 = llvm.select %40, %7, %12 : i1, f32
          %48 = llvm.select %40, %6, %11 : i1, f32
          %49 = llvm.intr.fma(%42, %48, %47) : (f32, f32, f32) -> f32
          %50 = llvm.intr.fma(%42, %49, %46) : (f32, f32, f32) -> f32
          %51 = llvm.intr.fma(%42, %50, %45) : (f32, f32, f32) -> f32
          %52 = llvm.intr.fma(%42, %51, %44) : (f32, f32, f32) -> f32
          %53 = llvm.intr.fma(%42, %52, %17) : (f32, f32, f32) -> f32
          %54 = llvm.fmul %43, %53 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %55 = llvm.fmul %54, %16 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %56 = llvm.select %41, %55, %54 : i1, f32
          %57 = llvm.fmul %29, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %58 = llvm.intr.floor(%57) : (f32) -> f32
          %59 = llvm.fmul %58, %18 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %60 = llvm.fsub %29, %59 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %61 = llvm.fptosi %58 : f32 to i32
          %62 = llvm.and %61, %5 : i32
          %63 = llvm.icmp "eq" %62, %4 : i32
          %64 = llvm.icmp "eq" %62, %3 : i32
          %65 = llvm.icmp "eq" %62, %2 : i32
          %66 = llvm.or %63, %65 : i1
          %67 = llvm.or %64, %65 : i1
          %68 = llvm.fmul %60, %60 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %69 = llvm.select %66, %17, %60 : i1, f32
          %70 = llvm.select %66, %10, %15 : i1, f32
          %71 = llvm.select %66, %9, %14 : i1, f32
          %72 = llvm.select %66, %8, %13 : i1, f32
          %73 = llvm.select %66, %7, %12 : i1, f32
          %74 = llvm.select %66, %6, %11 : i1, f32
          %75 = llvm.intr.fma(%68, %74, %73) : (f32, f32, f32) -> f32
          %76 = llvm.intr.fma(%68, %75, %72) : (f32, f32, f32) -> f32
          %77 = llvm.intr.fma(%68, %76, %71) : (f32, f32, f32) -> f32
          %78 = llvm.intr.fma(%68, %77, %70) : (f32, f32, f32) -> f32
          %79 = llvm.intr.fma(%68, %78, %17) : (f32, f32, f32) -> f32
          %80 = llvm.fmul %69, %79 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %81 = llvm.fmul %80, %16 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %82 = llvm.select %67, %81, %80 : i1, f32
          %83 = llvm.fadd %82, %56 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %83, %26 : f32, !llvm.ptr
          llvm.return %4 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_23 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_23_elementwise_broadcast ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @_main$async_dispatch_23_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(8 : i64) : i64
          %2 = llvm.mlir.constant(32 : i64) : i64
          %3 = llvm.mlir.constant(64 : index) : i64
          %4 = llvm.mlir.constant(true) : i1
          %5 = llvm.mlir.constant(1 : i32) : i32
          %6 = llvm.mlir.constant(3 : i32) : i32
          %7 = llvm.mlir.constant(-2.59630184E-7 : f32) : f32
          %8 = llvm.mlir.constant(2.47562348E-5 : f32) : f32
          %9 = llvm.mlir.constant(-0.00138883304 : f32) : f32
          %10 = llvm.mlir.constant(0.0416666418 : f32) : f32
          %11 = llvm.mlir.constant(-5.000000e-01 : f32) : f32
          %12 = llvm.mlir.constant(-2.50293279E-8 : f32) : f32
          %13 = llvm.mlir.constant(2.76001265E-6 : f32) : f32
          %14 = llvm.mlir.constant(-1.98426045E-4 : f32) : f32
          %15 = llvm.mlir.constant(0.00833334774 : f32) : f32
          %16 = llvm.mlir.constant(-0.166666672 : f32) : f32
          %17 = llvm.mlir.constant(-1.000000e+00 : f32) : f32
          %18 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %19 = llvm.mlir.constant(1.57079637 : f32) : f32
          %20 = llvm.mlir.constant(0.636619746 : f32) : f32
          %21 = llvm.mlir.constant(4 : index) : i64
          %22 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %23 = llvm.extractvalue %22[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %24 = llvm.load %23 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %4 ["align"(%24, %3 : !llvm.ptr, i64)] : i1
          %25 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %26 = llvm.extractvalue %25[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %27 = llvm.getelementptr %26[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %28 = llvm.load %27 : !llvm.ptr -> !llvm.ptr
          %29 = llvm.mul %21, %1 : i64
          %30 = llvm.udiv %29, %2 : i64
          %31 = llvm.getelementptr %28[%30] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%31, %21 : !llvm.ptr, i64)] : i1
          %32 = llvm.getelementptr inbounds|nuw %24[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %33 = llvm.load %32 : !llvm.ptr -> f32
          %34 = llvm.load %24 : !llvm.ptr -> f32
          %35 = llvm.fadd %34, %33 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %36 = llvm.fmul %35, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %37 = llvm.intr.floor(%36) : (f32) -> f32
          %38 = llvm.fmul %37, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %39 = llvm.fsub %35, %38 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %40 = llvm.fptosi %37 : f32 to i32
          %41 = llvm.and %40, %6 : i32
          %42 = llvm.icmp "eq" %41, %5 : i32
          %43 = llvm.icmp "eq" %41, %6 : i32
          %44 = llvm.or %42, %43 : i1
          %45 = llvm.icmp "sgt" %41, %5 : i32
          %46 = llvm.fmul %39, %39 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %47 = llvm.select %44, %18, %39 : i1, f32
          %48 = llvm.select %44, %11, %16 : i1, f32
          %49 = llvm.select %44, %10, %15 : i1, f32
          %50 = llvm.select %44, %9, %14 : i1, f32
          %51 = llvm.select %44, %8, %13 : i1, f32
          %52 = llvm.select %44, %7, %12 : i1, f32
          %53 = llvm.intr.fma(%46, %52, %51) : (f32, f32, f32) -> f32
          %54 = llvm.intr.fma(%46, %53, %50) : (f32, f32, f32) -> f32
          %55 = llvm.intr.fma(%46, %54, %49) : (f32, f32, f32) -> f32
          %56 = llvm.intr.fma(%46, %55, %48) : (f32, f32, f32) -> f32
          %57 = llvm.intr.fma(%46, %56, %18) : (f32, f32, f32) -> f32
          %58 = llvm.fmul %47, %57 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %59 = llvm.fmul %58, %17 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %60 = llvm.select %45, %59, %58 : i1, f32
          %61 = llvm.fmul %34, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %62 = llvm.intr.floor(%61) : (f32) -> f32
          %63 = llvm.fmul %62, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %64 = llvm.fsub %34, %63 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %65 = llvm.fptosi %62 : f32 to i32
          %66 = llvm.and %65, %6 : i32
          %67 = llvm.icmp "eq" %66, %5 : i32
          %68 = llvm.icmp "eq" %66, %6 : i32
          %69 = llvm.or %67, %68 : i1
          %70 = llvm.icmp "sgt" %66, %5 : i32
          %71 = llvm.fmul %64, %64 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %72 = llvm.select %69, %18, %64 : i1, f32
          %73 = llvm.select %69, %11, %16 : i1, f32
          %74 = llvm.select %69, %10, %15 : i1, f32
          %75 = llvm.select %69, %9, %14 : i1, f32
          %76 = llvm.select %69, %8, %13 : i1, f32
          %77 = llvm.select %69, %7, %12 : i1, f32
          %78 = llvm.intr.fma(%71, %77, %76) : (f32, f32, f32) -> f32
          %79 = llvm.intr.fma(%71, %78, %75) : (f32, f32, f32) -> f32
          %80 = llvm.intr.fma(%71, %79, %74) : (f32, f32, f32) -> f32
          %81 = llvm.intr.fma(%71, %80, %73) : (f32, f32, f32) -> f32
          %82 = llvm.intr.fma(%71, %81, %18) : (f32, f32, f32) -> f32
          %83 = llvm.fmul %72, %82 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %84 = llvm.fmul %83, %17 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %85 = llvm.select %70, %84, %83 : i1, f32
          %86 = llvm.fadd %85, %60 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %86, %31 : f32, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_24 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_24_elementwise_broadcast_10x2_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.mlir.global private constant @__constant_10xf32_0(dense<[1.000000e+00, 0.888888895, 0.777777791, 0.666666627, 0.555555582, 0.444444418, 0.333333313, 0.222222209, 0.111111104, 0.000000e+00]> : tensor<10xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<10 x f32>
        llvm.mlir.global private constant @__constant_2xf32(dense<[0.000000e+00, -1.000000e-01]> : tensor<2xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<2 x f32>
        llvm.mlir.global private constant @__constant_10xf32(dense<[0.000000e+00, 0.111111112, 0.222222224, 0.333333343, 0.444444448, 0.555555582, 0.666666686, 0.777777791, 0.888888895, 1.000000e+00]> : tensor<10xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<10 x f32>
        llvm.func @_main$async_dispatch_24_elementwise_broadcast_10x2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.poison : vector<2xf32>
          %2 = llvm.mlir.constant(0 : i64) : i64
          %3 = llvm.mlir.constant(64 : index) : i64
          %4 = llvm.mlir.constant(true) : i1
          %5 = llvm.mlir.addressof @__constant_10xf32_0 : !llvm.ptr
          %6 = llvm.mlir.addressof @__constant_2xf32 : !llvm.ptr
          %7 = llvm.mlir.constant(2 : index) : i64
          %8 = llvm.mlir.addressof @__constant_10xf32 : !llvm.ptr
          %9 = llvm.mlir.constant(10 : index) : i64
          %10 = llvm.mlir.constant(1 : index) : i64
          %11 = llvm.mlir.constant(0 : index) : i64
          %12 = llvm.getelementptr %8[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<10 x f32>
          %13 = llvm.getelementptr %6[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<2 x f32>
          %14 = llvm.getelementptr %5[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<10 x f32>
          %15 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %16 = llvm.extractvalue %15[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %17 = llvm.load %16 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %4 ["align"(%17, %3 : !llvm.ptr, i64)] : i1
          %18 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %19 = llvm.extractvalue %18[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %20 = llvm.getelementptr %19[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %21 = llvm.load %20 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %4 ["align"(%21, %3 : !llvm.ptr, i64)] : i1
          %22 = llvm.load %17 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %23 = llvm.load %13 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %24 = llvm.fadd %22, %23 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          llvm.br ^bb1(%11 : i64)
        ^bb1(%25: i64):  // 2 preds: ^bb0, ^bb2
          %26 = llvm.icmp "slt" %25, %9 : i64
          llvm.cond_br %26, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %27 = llvm.getelementptr %14[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %28 = llvm.load %27 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %29 = llvm.getelementptr %12[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %30 = llvm.load %29 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %31 = llvm.extractelement %30[%2 : i64] : vector<1xf32>
          %32 = llvm.insertelement %31, %1[%0 : i32] : vector<2xf32>
          %33 = llvm.shufflevector %32, %1 [0, 0] : vector<2xf32> 
          %34 = llvm.fmul %24, %33 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %35 = llvm.extractelement %28[%2 : i64] : vector<1xf32>
          %36 = llvm.insertelement %35, %1[%0 : i32] : vector<2xf32>
          %37 = llvm.shufflevector %36, %1 [0, 0] : vector<2xf32> 
          %38 = llvm.fmul %22, %37 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %39 = llvm.fadd %38, %34 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %40 = llvm.mul %25, %7 : i64
          %41 = llvm.add %40, %11 : i64
          %42 = llvm.getelementptr %21[%41] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %39, %42 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          %43 = llvm.add %25, %10 : i64
          llvm.br ^bb1(%43 : i64)
        ^bb3:  // pred: ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_27 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_27_elementwise_2_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.mlir.global private constant @__constant_2xf32(dense<[-2.000000e-01, 0.000000e+00]> : tensor<2xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<2 x f32>
        llvm.func @_main$async_dispatch_27_elementwise_2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(8 : i64) : i64
          %2 = llvm.mlir.constant(32 : i64) : i64
          %3 = llvm.mlir.constant(true) : i1
          %4 = llvm.mlir.addressof @__constant_2xf32 : !llvm.ptr
          %5 = llvm.mlir.constant(64 : index) : i64
          %6 = llvm.getelementptr %4[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<2 x f32>
          %7 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %8 = llvm.extractvalue %7[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %9 = llvm.load %8 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %3 ["align"(%9, %5 : !llvm.ptr, i64)] : i1
          %10 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %11 = llvm.extractvalue %10[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %12 = llvm.getelementptr %11[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %13 = llvm.load %12 : !llvm.ptr -> !llvm.ptr
          %14 = llvm.mul %5, %1 : i64
          %15 = llvm.udiv %14, %2 : i64
          %16 = llvm.getelementptr %13[%15] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%16, %5 : !llvm.ptr, i64)] : i1
          %17 = llvm.load %9 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %18 = llvm.load %6 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %19 = llvm.fadd %17, %18 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          llvm.store %19, %16 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_28 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_28_elementwise_broadcast_10x2_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.mlir.global private constant @__constant_10xf32_0(dense<[1.000000e+00, 0.888888895, 0.777777791, 0.666666627, 0.555555582, 0.444444418, 0.333333313, 0.222222209, 0.111111104, 0.000000e+00]> : tensor<10xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<10 x f32>
        llvm.mlir.global private constant @__constant_10xf32(dense<[0.000000e+00, 0.111111112, 0.222222224, 0.333333343, 0.444444448, 0.555555582, 0.666666686, 0.777777791, 0.888888895, 1.000000e+00]> : tensor<10xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<10 x f32>
        llvm.func @_main$async_dispatch_28_elementwise_broadcast_10x2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.poison : vector<2xf32>
          %2 = llvm.mlir.constant(0 : i64) : i64
          %3 = llvm.mlir.constant(8 : i64) : i64
          %4 = llvm.mlir.constant(32 : i64) : i64
          %5 = llvm.mlir.constant(true) : i1
          %6 = llvm.mlir.constant(2 : index) : i64
          %7 = llvm.mlir.addressof @__constant_10xf32_0 : !llvm.ptr
          %8 = llvm.mlir.addressof @__constant_10xf32 : !llvm.ptr
          %9 = llvm.mlir.constant(10 : index) : i64
          %10 = llvm.mlir.constant(1 : index) : i64
          %11 = llvm.mlir.constant(64 : index) : i64
          %12 = llvm.mlir.constant(0 : index) : i64
          %13 = llvm.getelementptr %8[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<10 x f32>
          %14 = llvm.getelementptr %7[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<10 x f32>
          %15 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %16 = llvm.extractvalue %15[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %17 = llvm.load %16 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %5 ["align"(%17, %11 : !llvm.ptr, i64)] : i1
          %18 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %19 = llvm.extractvalue %18[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %20 = llvm.load %19 : !llvm.ptr -> !llvm.ptr
          %21 = llvm.mul %11, %3 : i64
          %22 = llvm.udiv %21, %4 : i64
          %23 = llvm.getelementptr %20[%22] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %5 ["align"(%23, %11 : !llvm.ptr, i64)] : i1
          %24 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %25 = llvm.extractvalue %24[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %26 = llvm.getelementptr %25[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %27 = llvm.load %26 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %5 ["align"(%27, %11 : !llvm.ptr, i64)] : i1
          %28 = llvm.load %17 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %29 = llvm.load %23 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          llvm.br ^bb1(%12 : i64)
        ^bb1(%30: i64):  // 2 preds: ^bb0, ^bb2
          %31 = llvm.icmp "slt" %30, %9 : i64
          llvm.cond_br %31, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %32 = llvm.getelementptr %14[%30] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %33 = llvm.load %32 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %34 = llvm.getelementptr %13[%30] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %35 = llvm.load %34 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %36 = llvm.extractelement %35[%2 : i64] : vector<1xf32>
          %37 = llvm.insertelement %36, %1[%0 : i32] : vector<2xf32>
          %38 = llvm.shufflevector %37, %1 [0, 0] : vector<2xf32> 
          %39 = llvm.fmul %29, %38 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %40 = llvm.extractelement %33[%2 : i64] : vector<1xf32>
          %41 = llvm.insertelement %40, %1[%0 : i32] : vector<2xf32>
          %42 = llvm.shufflevector %41, %1 [0, 0] : vector<2xf32> 
          %43 = llvm.fmul %28, %42 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %44 = llvm.fadd %43, %39 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %45 = llvm.mul %30, %6 : i64
          %46 = llvm.add %45, %12 : i64
          %47 = llvm.getelementptr %27[%46] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %44, %47 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          %48 = llvm.add %30, %10 : i64
          llvm.br ^bb1(%48 : i64)
        ^bb3:  // pred: ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @_main$async_dispatch_29 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @_main$async_dispatch_29_elementwise_broadcast_9x2_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.mlir.global private constant @__constant_10xf32_0(dense<[1.000000e+00, 0.888888895, 0.777777791, 0.666666627, 0.555555582, 0.444444418, 0.333333313, 0.222222209, 0.111111104, 0.000000e+00]> : tensor<10xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<10 x f32>
        llvm.mlir.global private constant @__constant_2xf32(dense<[0.000000e+00, -1.000000e-01]> : tensor<2xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<2 x f32>
        llvm.mlir.global private constant @__constant_10xf32(dense<[0.000000e+00, 0.111111112, 0.222222224, 0.333333343, 0.444444448, 0.555555582, 0.666666686, 0.777777791, 0.888888895, 1.000000e+00]> : tensor<10xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<10 x f32>
        llvm.func @_main$async_dispatch_29_elementwise_broadcast_9x2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.poison : vector<2xf32>
          %2 = llvm.mlir.constant(0 : i64) : i64
          %3 = llvm.mlir.constant(16 : index) : i64
          %4 = llvm.mlir.constant(true) : i1
          %5 = llvm.mlir.constant(8 : i64) : i64
          %6 = llvm.mlir.constant(32 : i64) : i64
          %7 = llvm.mlir.addressof @__constant_10xf32_0 : !llvm.ptr
          %8 = llvm.mlir.addressof @__constant_2xf32 : !llvm.ptr
          %9 = llvm.mlir.constant(2 : index) : i64
          %10 = llvm.mlir.addressof @__constant_10xf32 : !llvm.ptr
          %11 = llvm.mlir.constant(0 : index) : i64
          %12 = llvm.mlir.constant(9 : index) : i64
          %13 = llvm.mlir.constant(1 : index) : i64
          %14 = llvm.mlir.constant(80 : index) : i64
          %15 = llvm.mlir.constant(64 : index) : i64
          %16 = llvm.getelementptr %10[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<10 x f32>
          %17 = llvm.getelementptr %8[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<2 x f32>
          %18 = llvm.getelementptr %7[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<10 x f32>
          %19 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %20 = llvm.extractvalue %19[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %21 = llvm.load %20 : !llvm.ptr -> !llvm.ptr
          %22 = llvm.mul %15, %5 : i64
          %23 = llvm.udiv %22, %6 : i64
          %24 = llvm.getelementptr %21[%23] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%24, %15 : !llvm.ptr, i64)] : i1
          %25 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %26 = llvm.extractvalue %25[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %27 = llvm.getelementptr %26[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %28 = llvm.load %27 : !llvm.ptr -> !llvm.ptr
          %29 = llvm.mul %14, %5 : i64
          %30 = llvm.udiv %29, %6 : i64
          %31 = llvm.getelementptr %28[%30] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%31, %3 : !llvm.ptr, i64)] : i1
          %32 = llvm.load %24 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %33 = llvm.load %17 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %34 = llvm.fadd %32, %33 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          llvm.br ^bb1(%11 : i64)
        ^bb1(%35: i64):  // 2 preds: ^bb0, ^bb2
          %36 = llvm.icmp "slt" %35, %12 : i64
          llvm.cond_br %36, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %37 = llvm.add %35, %13 : i64
          %38 = llvm.getelementptr %18[%37] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %39 = llvm.load %38 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %40 = llvm.getelementptr %16[%37] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %41 = llvm.load %40 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %42 = llvm.extractelement %41[%2 : i64] : vector<1xf32>
          %43 = llvm.insertelement %42, %1[%0 : i32] : vector<2xf32>
          %44 = llvm.shufflevector %43, %1 [0, 0] : vector<2xf32> 
          %45 = llvm.fmul %34, %44 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %46 = llvm.extractelement %39[%2 : i64] : vector<1xf32>
          %47 = llvm.insertelement %46, %1[%0 : i32] : vector<2xf32>
          %48 = llvm.shufflevector %47, %1 [0, 0] : vector<2xf32> 
          %49 = llvm.fmul %32, %48 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %50 = llvm.fadd %49, %45 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %51 = llvm.mul %35, %9 : i64
          %52 = llvm.add %51, %11 : i64
          %53 = llvm.getelementptr %31[%52] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %50, %53 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.br ^bb1(%37 : i64)
        ^bb3:  // pred: ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  util.global private @__constant_tensor_4x3x4x4xf32 : !stream.resource<constant>
  util.initializer {
    %c0 = arith.constant 0 : index
    %c0_i64 = arith.constant 0 : i64
    %c8960 = arith.constant 8960 : index
    %0 = stream.timepoint.immediate => !stream.timepoint
    %buffer_cst = util.buffer.constant {alignment = 64 : index} : !util.buffer = #composite_of_8960b
    %did_map, %result = stream.resource.try_map on(#hal.device.affinity<@__device_0>) %buffer_cst[%c0] : !util.buffer -> i1, !stream.resource<constant>{%c8960}
    cf.cond_br %did_map, ^bb2(%0, %result : !stream.timepoint, !stream.resource<constant>), ^bb1
  ^bb1:  // pred: ^bb0
    %1 = stream.resource.alloc uninitialized on(#hal.device.affinity<@__device_0>) : !stream.resource<constant>{%c8960}
    %file = stream.file.constant on(#hal.device.affinity<@__device_0>) %buffer_cst[%c0 for %c8960] : !util.buffer{%c8960} -> !stream.file
    %2 = stream.file.read on(#hal.device.affinity<@__device_0>) await(%0) => %file[%c0_i64], %1[%c0], %c8960 : !stream.file -> !stream.resource<constant>{%c8960} => !stream.timepoint
    cf.br ^bb2(%2, %1 : !stream.timepoint, !stream.resource<constant>)
  ^bb2(%3: !stream.timepoint, %4: !stream.resource<constant>):  // 2 preds: ^bb0, ^bb1
    %5 = stream.timepoint.await sync %3 => %4 : !stream.resource<constant>{%c8960}
    util.global.store %5, @__constant_tensor_4x3x4x4xf32 : !stream.resource<constant>
    util.return
  }
  util.func private @_main$async(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.fence, %arg5: !hal.fence) -> (!hal.buffer_view, !hal.buffer_view) attributes {inlining_policy = #util.inline.never} {
    %c152 = arith.constant 152 : index
    %c52272 = arith.constant 52272 : index
    %c4 = arith.constant 4 : index
    %c8 = arith.constant 8 : index
    %c12 = arith.constant 12 : index
    %c49152 = arith.constant 49152 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1 = arith.constant 1 : index
    %cst_0 = arith.constant 9.99999993E-9 : f32
    %c2 = arith.constant 2 : index
    %c3 = arith.constant 3 : index
    %c64 = arith.constant 64 : index
    %c0_i8 = arith.constant 0 : i8
    %c0 = arith.constant 0 : index
    %c56384 = arith.constant 56384 : index
    %c128 = arith.constant 128 : index
    %c192 = arith.constant 192 : index
    %c256 = arith.constant 256 : index
    %c320 = arith.constant 320 : index
    %c384 = arith.constant 384 : index
    %c328 = arith.constant 328 : index
    %c136 = arith.constant 136 : index
    %c8960 = arith.constant 8960 : index
    %__constant_tensor_4x3x4x4xf32 = util.global.load immutable @__constant_tensor_4x3x4x4xf32 : !stream.resource<constant>
    %element_type_f32 = hal.element_type<f32> : i32
    %dense_row_major = hal.encoding_type<dense_row_major> : i32
    hal.buffer_view.assert<%arg0 : !hal.buffer_view> message("tensor") shape([%c1, %c3, %c64, %c64]) type(%element_type_f32) encoding(%dense_row_major)
    %0 = stream.tensor.import on(#hal.device.affinity<@__device_0>) %arg0 : !hal.buffer_view -> tensor<1x3x64x64xf32> in !stream.resource<external>{%c49152}
    %1 = stream.timepoint.import on(#hal.device.affinity<@__device_0>) %arg4 : (!hal.fence) => !stream.timepoint
    hal.buffer_view.assert<%arg1 : !hal.buffer_view> message("tensor") shape([%c3]) type(%element_type_f32) encoding(%dense_row_major)
    %2 = stream.tensor.import on(#hal.device.affinity<@__device_0>) %arg1 : !hal.buffer_view -> tensor<3xf32> in !stream.resource<external>{%c12}
    hal.buffer_view.assert<%arg2 : !hal.buffer_view> message("tensor") shape([%c2]) type(%element_type_f32) encoding(%dense_row_major)
    %3 = stream.tensor.import on(#hal.device.affinity<@__device_0>) %arg2 : !hal.buffer_view -> tensor<2xf32> in !stream.resource<external>{%c8}
    hal.buffer_view.assert<%arg3 : !hal.buffer_view> message("tensor") shape([%c2]) type(%element_type_f32) encoding(%dense_row_major)
    %4 = stream.tensor.import on(#hal.device.affinity<@__device_0>) %arg3 : !hal.buffer_view -> tensor<2xf32> in !stream.resource<external>{%c8}
    %result, %result_timepoint = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) await(%1) => !stream.resource<external>{%c12} => !stream.timepoint
    %result_1, %result_timepoint_2 = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) await(%1) => !stream.resource<transient>{%c8} => !stream.timepoint
    %result_3, %result_timepoint_4 = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) await(%1) => !stream.resource<transient>{%c56384} => !stream.timepoint
    %5 = stream.timepoint.join max(%result_timepoint, %result_timepoint_2, %result_timepoint_4) => !stream.timepoint
    %6 = stream.cmd.execute on(#hal.device.affinity<@__device_0>) await(%5) => with(%4 as %arg6: !stream.resource<external>{%c8}, %2 as %arg7: !stream.resource<external>{%c12}, %0 as %arg8: !stream.resource<external>{%c49152}, %__constant_tensor_4x3x4x4xf32 as %arg9: !stream.resource<constant>{%c8960}, %result as %arg10: !stream.resource<external>{%c12}, %result_1 as %arg11: !stream.resource<transient>{%c8}, %result_3 as %arg12: !stream.resource<transient>{%c56384}) {
      stream.cmd.concurrent {
        stream.cmd.dispatch @_main$async_dispatch_0::@embedded_elf_x86_64::@_main$async_dispatch_0_elementwise_broadcast {
          ro %arg6[%c0 for %c8] : !stream.resource<external>{%c8},
          ro %arg7[%c0 for %c12] : !stream.resource<external>{%c12},
          rw %arg10[%c0 for %c12] : !stream.resource<external>{%c12},
          rw %arg10[%c0 for %c12] : !stream.resource<external>{%c12},
          rw %arg10[%c0 for %c12] : !stream.resource<external>{%c12}
        }
        stream.cmd.fill %c0_i8, %arg12[%c0 for %c52272] : i8 -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @_main$async_dispatch_1::@embedded_elf_x86_64::@_main$async_dispatch_1_slow_memcpy {
        ro %arg8[%c0 for %c49152] : !stream.resource<external>{%c49152},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @_main$async_dispatch_2::@embedded_elf_x86_64::@_main$async_dispatch_2_conv_4x16x16x3x4x4_f32 {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        ro %arg9[%c0 for %c8960] : !stream.resource<constant>{%c8960},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @_main$async_dispatch_3::@embedded_elf_x86_64::@_main$async_dispatch_3_conv_4x8x8x2x2_f32 {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @_main$async_dispatch_4::@embedded_elf_x86_64::@_main$async_dispatch_4_mmt4d_1x1x256x1x8x1_f32 {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        ro %arg9[%c0 for %c8960] : !stream.resource<constant>{%c8960},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @_main$async_dispatch_5::@embedded_elf_x86_64::@_main$async_dispatch_5_unpack_f32 {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg11[%c0 for %c8] : !stream.resource<transient>{%c8}
      }
    } => !stream.timepoint
    %7 = stream.resource.dealloca on(#hal.device.affinity<@__device_0>) await(%6) => %result_3 : !stream.resource<transient>{%c56384} => !stream.timepoint
    %8:4 = stream.timepoint.await %1 => %4, %2, %0, %3 : !stream.resource<external>{%c8}, !stream.resource<external>{%c12}, !stream.resource<external>{%c49152}, !stream.resource<external>{%c8}
    cf.br ^bb1(%8#3 : !stream.resource<external>)
  ^bb1(%9: !stream.resource<external>):  // 2 preds: ^bb0, ^bb1
    %result_5, %result_timepoint_6 = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) await(%7) => !stream.resource<external>{%c8} => !stream.timepoint
    %result_7, %result_timepoint_8 = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) await(%7) => !stream.resource<staging>{%c4} => !stream.timepoint
    %result_9, %result_timepoint_10 = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) await(%7) => !stream.resource<transient>{%c384} => !stream.timepoint
    %10 = stream.timepoint.join max(%result_timepoint_6, %result_timepoint_8, %result_timepoint_10) => !stream.timepoint
    %11 = stream.cmd.execute on(#hal.device.affinity<@__device_0>) await(%10) => with(%9 as %arg6: !stream.resource<external>{%c8}, %result_1 as %arg7: !stream.resource<transient>{%c8}, %result_5 as %arg8: !stream.resource<external>{%c8}, %result_7 as %arg9: !stream.resource<staging>{%c4}, %result_9 as %arg10: !stream.resource<transient>{%c384}) {
      stream.cmd.copy %arg6[%c0], %arg10[%c0], %c8 : !stream.resource<external>{%c8} -> !stream.resource<transient>{%c384}
      stream.cmd.copy %arg6[%c0], %arg10[%c64], %c8 : !stream.resource<external>{%c8} -> !stream.resource<transient>{%c384}
      stream.cmd.dispatch @_main$async_dispatch_7::@embedded_elf_x86_64::@_main$async_dispatch_7_elementwise_broadcast {
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        wo %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.copy %arg10[%c128], %arg10[%c64], %c4 : !stream.resource<transient>{%c384} -> !stream.resource<transient>{%c384}
      stream.cmd.dispatch @_main$async_dispatch_6::@embedded_elf_x86_64::@_main$async_dispatch_6_elementwise_broadcast {
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        rw %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.copy %arg6[%c0], %arg10[%c0], %c8 : !stream.resource<external>{%c8} -> !stream.resource<transient>{%c384}
      stream.cmd.copy %arg10[%c64], %arg10[%c128], %c8 : !stream.resource<transient>{%c384} -> !stream.resource<transient>{%c384}
      stream.cmd.dispatch @_main$async_dispatch_8::@embedded_elf_x86_64::@_main$async_dispatch_8_elementwise_broadcast {
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        rw %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.dispatch @_main$async_dispatch_9::@embedded_elf_x86_64::@_main$async_dispatch_9_elementwise_1x2_f32 {
        ro %arg7[%c0 for %c8] : !stream.resource<transient>{%c8},
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        wo %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.copy %arg6[%c0], %arg10[%c128], %c8 : !stream.resource<external>{%c8} -> !stream.resource<transient>{%c384}
      stream.cmd.dispatch @_main$async_dispatch_10::@embedded_elf_x86_64::@_main$async_dispatch_10_elementwise_broadcast {
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        rw %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.copy %arg6[%c0], %arg10[%c128], %c8 : !stream.resource<external>{%c8} -> !stream.resource<transient>{%c384}
      stream.cmd.dispatch @_main$async_dispatch_11::@embedded_elf_x86_64::@_main$async_dispatch_11_elementwise_broadcast {
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        rw %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.copy %arg10[%c192], %arg10[%c128], %c8 : !stream.resource<transient>{%c384} -> !stream.resource<transient>{%c384}
      stream.cmd.copy %arg10[%c64], %arg10[%c136], %c8 : !stream.resource<transient>{%c384} -> !stream.resource<transient>{%c384}
      stream.cmd.dispatch @_main$async_dispatch_12::@embedded_elf_x86_64::@_main$async_dispatch_12_elementwise_broadcast_2_f32 {
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        wo %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.dispatch @_main$async_dispatch_14::@embedded_elf_x86_64::@_main$async_dispatch_14_elementwise_broadcast_2_f32 {
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        wo %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.dispatch @_main$async_dispatch_17::@embedded_elf_x86_64::@_main$async_dispatch_17_elementwise_broadcast {
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        wo %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.copy %arg10[%c128], %arg10[%c256], %c4 : !stream.resource<transient>{%c384} -> !stream.resource<transient>{%c384}
      stream.cmd.dispatch @_main$async_dispatch_13::@embedded_elf_x86_64::@_main$async_dispatch_13_elementwise_broadcast {
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        rw %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.dispatch @_main$async_dispatch_15::@embedded_elf_x86_64::@_main$async_dispatch_15_elementwise_broadcast {
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        rw %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.dispatch @_main$async_dispatch_16::@embedded_elf_x86_64::@_main$async_dispatch_16_elementwise_broadcast {
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        rw %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.copy %arg10[%c128], %arg10[%c320], %c8 : !stream.resource<transient>{%c384} -> !stream.resource<transient>{%c384}
      stream.cmd.copy %arg10[%c256], %arg10[%c328], %c8 : !stream.resource<transient>{%c384} -> !stream.resource<transient>{%c384}
      stream.cmd.dispatch @_main$async_dispatch_18::@embedded_elf_x86_64::@_main$async_dispatch_18_elementwise_2x2_f32_pack {
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        wo %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.dispatch @_main$async_dispatch_19::@embedded_elf_x86_64::@_main$async_dispatch_19_mmt4d_1x1x2x1x8x1_f32 {
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        wo %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.copy %arg6[%c0], %arg10[%c0], %c8 : !stream.resource<external>{%c8} -> !stream.resource<transient>{%c384}
      stream.cmd.dispatch @_main$async_dispatch_20::@embedded_elf_x86_64::@_main$async_dispatch_20_unpack_elementwise_2_f32 {
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        wo %arg8[%c0 for %c8] : !stream.resource<external>{%c8}
      }
      stream.cmd.copy %arg6[%c0], %arg10[%c0], %c8 : !stream.resource<external>{%c8} -> !stream.resource<transient>{%c384}
      stream.cmd.dispatch @_main$async_dispatch_21::@embedded_elf_x86_64::@_main$async_dispatch_21_reduction_2_f32 {
        ro %arg8[%c0 for %c8] : !stream.resource<external>{%c8},
        ro %arg10[%c0 for %c384] : !stream.resource<transient>{%c384},
        wo %arg10[%c0 for %c384] : !stream.resource<transient>{%c384}
      }
      stream.cmd.copy %arg10[%c64], %arg9[%c0], %c4 : !stream.resource<transient>{%c384} -> !stream.resource<staging>{%c4}
      stream.cmd.flush %arg9[%c0 for %c4] : !stream.resource<staging>{%c4}
    } => !stream.timepoint
    %12 = stream.resource.dealloca on(#hal.device.affinity<@__device_0>) await(%11) => %result_9 : !stream.resource<transient>{%c384} => !stream.timepoint
    %13:2 = stream.timepoint.await %12 => %result_7, %result_5 : !stream.resource<staging>{%c4}, !stream.resource<external>{%c8}
    %14 = stream.resource.load %13#0[%c0] : !stream.resource<staging>{%c4} -> f32
    %15 = arith.cmpf ogt, %14, %cst_0 : f32
    cf.cond_br %15, ^bb1(%13#1 : !stream.resource<external>), ^bb2
  ^bb2:  // pred: ^bb1
    %result_11, %result_timepoint_12 = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) : !stream.resource<staging>{%c4} => !stream.timepoint
    %result_13, %result_timepoint_14 = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) : !stream.resource<transient>{%c64} => !stream.timepoint
    %16 = stream.timepoint.join max(%result_timepoint_12, %result_timepoint_14, %12) => !stream.timepoint
    %17 = stream.cmd.execute on(#hal.device.affinity<@__device_0>) await(%16) => with(%result_5 as %arg6: !stream.resource<external>{%c8}, %result_11 as %arg7: !stream.resource<staging>{%c4}, %result_13 as %arg8: !stream.resource<transient>{%c64}) {
      stream.cmd.copy %arg6[%c4], %arg8[%c0], %c4 : !stream.resource<external>{%c8} -> !stream.resource<transient>{%c64}
      stream.cmd.copy %arg8[%c0], %arg7[%c0], %c4 : !stream.resource<transient>{%c64} -> !stream.resource<staging>{%c4}
      stream.cmd.flush %arg7[%c0 for %c4] : !stream.resource<staging>{%c4}
    } => !stream.timepoint
    %18 = stream.resource.dealloca on(#hal.device.affinity<@__device_0>) await(%17) => %result_13 : !stream.resource<transient>{%c64} => !stream.timepoint
    %19 = stream.timepoint.await %18 => %result_11 : !stream.resource<staging>{%c4}
    %20 = stream.resource.load %19[%c0] : !stream.resource<staging>{%c4} -> f32
    %21 = arith.cmpf ogt, %20, %cst : f32
    cf.cond_br %21, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %result_15, %result_timepoint_16 = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) : !stream.resource<external>{%c152} => !stream.timepoint
    %result_17, %result_timepoint_18 = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) : !stream.resource<transient>{%c64} => !stream.timepoint
    %22 = stream.timepoint.join max(%result_timepoint_16, %result_timepoint_18, %12) => !stream.timepoint
    %23 = stream.cmd.execute on(#hal.device.affinity<@__device_0>) await(%22) => with(%result_5 as %arg6: !stream.resource<external>{%c8}, %result_15 as %arg7: !stream.resource<external>{%c152}, %result_17 as %arg8: !stream.resource<transient>{%c64}) {
      stream.cmd.dispatch @_main$async_dispatch_22::@embedded_elf_x86_64::@_main$async_dispatch_22_elementwise_broadcast {
        ro %arg6[%c0 for %c8] : !stream.resource<external>{%c8},
        rw %arg8[%c0 for %c64] : !stream.resource<transient>{%c64}
      }
      stream.cmd.dispatch @_main$async_dispatch_23::@embedded_elf_x86_64::@_main$async_dispatch_23_elementwise_broadcast {
        ro %arg6[%c0 for %c8] : !stream.resource<external>{%c8},
        rw %arg8[%c0 for %c64] : !stream.resource<transient>{%c64}
      }
      stream.cmd.fill %c0_i8, %arg7[%c0 for %c152] : i8 -> !stream.resource<external>{%c152}
      stream.cmd.dispatch @_main$async_dispatch_24::@embedded_elf_x86_64::@_main$async_dispatch_24_elementwise_broadcast_10x2_f32 {
        ro %arg8[%c0 for %c64] : !stream.resource<transient>{%c64},
        rw %arg7[%c0 for %c152] : !stream.resource<external>{%c152}
      }
    } => !stream.timepoint
    %24 = stream.resource.dealloca on(#hal.device.affinity<@__device_0>) await(%23) => %result_17 : !stream.resource<transient>{%c64} => !stream.timepoint
    %25 = stream.timepoint.await %24 => %result_15 : !stream.resource<external>{%c152}
    cf.br ^bb5(%25 : !stream.resource<external>)
  ^bb4:  // pred: ^bb2
    %result_19, %result_timepoint_20 = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) : !stream.resource<external>{%c152} => !stream.timepoint
    %result_21, %result_timepoint_22 = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) : !stream.resource<transient>{%c128} => !stream.timepoint
    %26 = stream.timepoint.join max(%result_timepoint_20, %result_timepoint_22, %12) => !stream.timepoint
    %27 = stream.cmd.execute on(#hal.device.affinity<@__device_0>) await(%26) => with(%result_5 as %arg6: !stream.resource<external>{%c8}, %result_19 as %arg7: !stream.resource<external>{%c152}, %result_21 as %arg8: !stream.resource<transient>{%c128}) {
      stream.cmd.dispatch @_main$async_dispatch_22::@embedded_elf_x86_64::@_main$async_dispatch_22_elementwise_broadcast {
        ro %arg6[%c0 for %c8] : !stream.resource<external>{%c8},
        rw %arg8[%c0 for %c128] : !stream.resource<transient>{%c128}
      }
      stream.cmd.dispatch @_main$async_dispatch_23::@embedded_elf_x86_64::@_main$async_dispatch_23_elementwise_broadcast {
        ro %arg6[%c0 for %c8] : !stream.resource<external>{%c8},
        rw %arg8[%c0 for %c128] : !stream.resource<transient>{%c128}
      }
      stream.cmd.dispatch @_main$async_dispatch_27::@embedded_elf_x86_64::@_main$async_dispatch_27_elementwise_2_f32 {
        ro %arg8[%c0 for %c128] : !stream.resource<transient>{%c128},
        wo %arg8[%c0 for %c128] : !stream.resource<transient>{%c128}
      }
      stream.cmd.dispatch @_main$async_dispatch_28::@embedded_elf_x86_64::@_main$async_dispatch_28_elementwise_broadcast_10x2_f32 {
        ro %arg8[%c0 for %c128] : !stream.resource<transient>{%c128},
        rw %arg7[%c0 for %c152] : !stream.resource<external>{%c152}
      }
      stream.cmd.dispatch @_main$async_dispatch_29::@embedded_elf_x86_64::@_main$async_dispatch_29_elementwise_broadcast_9x2_f32 {
        ro %arg8[%c0 for %c128] : !stream.resource<transient>{%c128},
        rw %arg7[%c0 for %c152] : !stream.resource<external>{%c152}
      }
    } => !stream.timepoint
    %28 = stream.resource.dealloca on(#hal.device.affinity<@__device_0>) await(%27) => %result_21 : !stream.resource<transient>{%c128} => !stream.timepoint
    %29 = stream.timepoint.await %28 => %result_19 : !stream.resource<external>{%c152}
    cf.br ^bb5(%29 : !stream.resource<external>)
  ^bb5(%30: !stream.resource<external>):  // 2 preds: ^bb3, ^bb4
    %31 = stream.tensor.export on(#hal.device.affinity<@__device_0>) %30 : tensor<19x2xf32> in !stream.resource<external>{%c152} -> !hal.buffer_view
    %32 = stream.timepoint.await %7 => %result : !stream.resource<external>{%c12}
    %33 = stream.tensor.export on(#hal.device.affinity<@__device_0>) %32 : tensor<3xf32> in !stream.resource<external>{%c12} -> !hal.buffer_view
    hal.fence.signal<%arg5 : !hal.fence>
    util.return %31, %33 : !hal.buffer_view, !hal.buffer_view
  }
  util.func public @main(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view) -> (!hal.buffer_view, !hal.buffer_view) attributes {iree.abi.stub} {
    %c-1_i32 = arith.constant -1 : i32
    %0 = util.null : !hal.fence
    %c0 = arith.constant 0 : index
    %device_0 = hal.devices.get %c0 : !hal.device
    %fence = hal.fence.create device(%device_0 : !hal.device) flags("None") : !hal.fence
    %1:2 = util.call @_main$async(%arg0, %arg1, %arg2, %arg3, %0, %fence) : (!hal.buffer_view, !hal.buffer_view, !hal.buffer_view, !hal.buffer_view, !hal.fence, !hal.fence) -> (!hal.buffer_view, !hal.buffer_view)
    %status = hal.fence.await until([%fence]) timeout_millis(%c-1_i32) flags("None") : i32
    util.return %1#0, %1#1 : !hal.buffer_view, !hal.buffer_view
  }
}
