#composite_of_8960b = #util.composite<8960xi8, [
    dense<"0xA4E062BD6F10A2BDF988443C9D175DBDC10D0BBEE2788DBD3D23A9BD501B7A3DA06B673DC090123EF900C63D2A100ABEC0E7D43D7E941CBC25580B3ECD8EBABD075D0E3EA3222C3D1ADEF53D6FAFC0BCE158683DC8F0F03BAD63CBBD0E57183DBEEE97BDDAE7F3BA769EDC3C7374EB3D4E39B33D106142BD382EA7BC892A01BEC026C63D1087BB3DA69D783D32427B3D4213F93D30DA0CBEC15A803DF17AB63D8A1A043EB867E7BDC529363D951A0CBE2FA62C3B565E043E93A9C5BC14469A3B0C6CA6BD2E66EEBD108FEDBDF4DAAA3DF64DA6BD55D2463C0EAE90BD2ECE43BD0402B7BD4844D8BC6FEF45BD8F289ABD724E2DBD35E2F53DD861BDBD345DAF3DBCD10E3E38A27F3C7362293D0C6787BD20FA3CBD035807BE2FA4EEBD66790DBCE11EA53DFADE123EB6D10C3E0BBD13BE6545C63D6335D93D3D61033E6D6313BDFDE110BE6E7C403DBF1E653BF4A2603D250A513D106844BD843DA53D1EE2823DECBBC4BD3035AFBC2A51A63D959BB63D03F5183D25A672BDE20DE33DEA84133EB5EFB1BC290708BEBC93E9BB850E793BAD14FDBDE95801BE330F883DD6C4E83DF8E2F0BD204E84BDFE1802BEC88B8A3C4F33AA3D706DA93CB7B0EF3D6DA8E9BD819AE23D24AF903DC74412BE545F0A3E52894C3D993BAC3D01D7453DAB55D03D34A2373DDDAD8CBD9FFE25BDBEF4CB3D3B399BBDE380CEBD195A2CBD5990CDBDC062AEBDBEE2E2BD96D8543D963567BC07AFE23CE3069F3D99A7013EF655EEBDE95BB5BB57B72BBD1A3AEDBD6ED50C3EA362E2BDBAE2BD3C7886133E4D0F7E3C3EA8F93CAA7AECBD0B22933BF532A0BD3CEE07BE9653ADBD3F8FA6BD9D507EBC8FF6C0BC19C801BE67E590BDA26D3FBC72EEA33D0902DE3D12F202BE97988B3D4FFB15BCD53E803DC446B9BC82C31B3D47FFD4BD581A843D8623133EE83DB6BD58094ABDDC2CE23DEDBC133E3172CE3D21125EBD29347B3D386DFBBDD03723BD11A8B4396362003ECBE981BC8A04A5BC947CC43DA4E7873DC3AFF8BC490EDF3CD3388BBDC1773B3D12F16FBDBECEE1BDB86F18BDB030243CD6E4E2BDCF2D7B3C"> : tensor<4x3x4x4xf32>,
    dense<"0x8800513D90CB91BC000000000000000000000000000000000000000000000000587D7D3D8CE6C33C000000000000000000000000000000000000000000000000A2654FBDA4CA443D00000000000000000000000000000000000000000000000092003D3D002AF3BA000000000000000000000000000000000000000000000000A051473D3C04263D0000000000000000000000000000000000000000000000005EC04ABD189B60BD0000000000000000000000000000000000000000000000006A8B0CBDF0CA64BD00000000000000000000000000000000000000000000000024D915BD445727BD000000000000000000000000000000000000000000000000D8974D3C14997DBD0000000000000000000000000000000000000000000000001029F3BBF8602ABC0000000000000000000000000000000000000000000000002C48AA3CDE5269BD00000000000000000000000000000000000000000000000080DC47BC4433B43C0000000000000000000000000000000000000000000000004AEF113D9CD882BC000000000000000000000000000000000000000000000000384EB23CF4408BBC00000000000000000000000000000000000000000000000004E760BDDAB55B3D000000000000000000000000000000000000000000000000F845C4BCA040893C000000000000000000000000000000000000000000000000943F593D647796BC000000000000000000000000000000000000000000000000B29F1BBD307FF4BC0000000000000000000000000000000000000000000000004827E53C08B0493D000000000000000000000000000000000000000000000000C6975F3DA0831EBC000000000000000000000000000000000000000000000000BCD0F43C58B62B3C000000000000000000000000000000000000000000000000143D94BCE43A2F3D000000000000000000000000000000000000000000000000A0745B3B4088CE3C0000000000000000000000000000000000000000000000006CB6843C300CDCBC00000000000000000000000000000000000000000000000070D1EA3CA29D57BD000000000000000000000000000000000000000000000000C06C15BC82A8543D000000000000000000000000000000000000000000000000708A483D001CA439000000000000000000000000000000000000000000000000E8501FBC963745BD000000000000000000000000000000000000000000000000004CD838D42CD13C000000000000000000000000000000000000000000000000807BB4BC809D2C3B000000000000000000000000000000000000000000000000D877703D941CEFBC00000000000000000000000000000000000000000000000034F2A8BC660A24BD000000000000000000000000000000000000000000000000740C093D56D8463D00000000000000000000000000000000000000000000000030D68F3C402C03BC000000000000000000000000000000000000000000000000C0DDAFBAA4FEFB3C0000000000000000000000000000000000000000000000006884F53C80C2F4BC00000000000000000000000000000000000000000000000094BFA7BC9CF60DBD0000000000000000000000000000000000000000000000008A3E1CBD60C9453B0000000000000000000000000000000000000000000000008062753AC0F334BB000000000000000000000000000000000000000000000000F065543C3C3422BD00000000000000000000000000000000000000000000000064FF76BD5A1E3D3D0000000000000000000000000000000000000000000000001436253DC025353B000000000000000000000000000000000000000000000000ACB803BD14372ABD0000000000000000000000000000000000000000000000003050A73B0AE554BD000000000000000000000000000000000000000000000000520D423DA8D50EBC00000000000000000000000000000000000000000000000074A2C5BC7098503D000000000000000000000000000000000000000000000000A4C8D53CD81685BC00000000000000000000000000000000000000000000000000CC223C7CB2AA3C00000000000000000000000000000000000000000000000040621ABD7A75653D000000000000000000000000000000000000000000000000C029CEBB3048CD3B000000000000000000000000000000000000000000000000D8D22F3DF030623D00000000000000000000000000000000000000000000000054F4E0BC66332A3D000000000000000000000000000000000000000000000000784F63BD4A46123D000000000000000000000000000000000000000000000000A04B4F3CF000033D0000000000000000000000000000000000000000000000000277443DC49378BD000000000000000000000000000000000000000000000000804CD73A364E323D000000000000000000000000000000000000000000000000603F71BDF8D60E3C000000000000000000000000000000000000000000000000145A563D8092AA3C000000000000000000000000000000000000000000000000ACF850BDC2E5013D0000000000000000000000000000000000000000000000003AE1023D5C4C85BC000000000000000000000000000000000000000000000000FC9A4ABD942F453D00000000000000000000000000000000000000000000000080BA4A3CE06A6BBC000000000000000000000000000000000000000000000000BC508BBCAA0A4ABD0000000000000000000000000000000000000000000000000CE1B13C9A086ABD0000000000000000000000000000000000000000000000004C15F6BCDE273E3D00000000000000000000000000000000000000000000000008FBF0BC3CECB4BC000000000000000000000000000000000000000000000000F09F1CBD0C2A883C000000000000000000000000000000000000000000000000B4A1ED3C40D16DBB0000000000000000000000000000000000000000000000003024133D90FFAABC0000000000000000000000000000000000000000000000005AA269BD247B9ABC000000000000000000000000000000000000000000000000D0E22E3C30F3A23C00000000000000000000000000000000000000000000000052486DBD04853B3D0000000000000000000000000000000000000000000000008CFBC73CEC42683D0000000000000000000000000000000000000000000000008403EA3CC87E83BC0000000000000000000000000000000000000000000000005884F4BC381C123D000000000000000000000000000000000000000000000000CA397C3D2CA2CB3C000000000000000000000000000000000000000000000000A6E569BDFA8050BD000000000000000000000000000000000000000000000000168A00BD8A23213D000000000000000000000000000000000000000000000000BEDA6FBD86CF2CBD0000000000000000000000000000000000000000000000009E5654BD3443393D000000000000000000000000000000000000000000000000346AC7BC345A883C000000000000000000000000000000000000000000000000205D3FBC48CC263C000000000000000000000000000000000000000000000000B053063D1AF131BD000000000000000000000000000000000000000000000000BCAA7EBD9E753FBD000000000000000000000000000000000000000000000000D03EABBCE07FB43B000000000000000000000000000000000000000000000000844339BD84D745BD000000000000000000000000000000000000000000000000463A093D986AD23C0000000000000000000000000000000000000000000000008CB5243DA8EC293C00000000000000000000000000000000000000000000000092827EBDB2E0623D000000000000000000000000000000000000000000000000508DE9BC28597ABC000000000000000000000000000000000000000000000000FA7C22BD260F42BD000000000000000000000000000000000000000000000000D46FCD3CC86108BD000000000000000000000000000000000000000000000000B00D78BC18D3443C000000000000000000000000000000000000000000000000A8693A3DA074933C000000000000000000000000000000000000000000000000682370BC98E83C3D00000000000000000000000000000000000000000000000090D04A3C5CE0DC3C000000000000000000000000000000000000000000000000FC473C3D8C3D77BD00000000000000000000000000000000000000000000000060AE9CBCD6A0403D000000000000000000000000000000000000000000000000A00DDEBC9E2912BD000000000000000000000000000000000000000000000000F0D05CBC90A8A2BB000000000000000000000000000000000000000000000000207FB3BB7C6582BC000000000000000000000000000000000000000000000000D4F8AF3C286B4E3D000000000000000000000000000000000000000000000000001692391E7F39BD0000000000000000000000000000000000000000000000008CCC453D2CF021BD000000000000000000000000000000000000000000000000E4F2F0BCFC8522BD000000000000000000000000000000000000000000000000FAF1543DE450A9BC000000000000000000000000000000000000000000000000B06BEFBBEC98423D000000000000000000000000000000000000000000000000FCAF4C3D80467EBB000000000000000000000000000000000000000000000000D431B3BC48F6513D000000000000000000000000000000000000000000000000380B45BCBE02133D00000000000000000000000000000000000000000000000060DB6B3C209CAABC00000000000000000000000000000000000000000000000068393EBD605606BD000000000000000000000000000000000000000000000000E89CA3BC1612323D0000000000000000000000000000000000000000000000001C98483DB07D673D000000000000000000000000000000000000000000000000906A57BDE4FEB9BC000000000000000000000000000000000000000000000000B0ABA7BB801A75BA000000000000000000000000000000000000000000000000524D343DE4CE34BD000000000000000000000000000000000000000000000000426074BD1E605B3D0000000000000000000000000000000000000000000000005469393D40B1B9BC0000000000000000000000000000000000000000000000000A9922BD566C2E3D00000000000000000000000000000000000000000000000030418DBBA8EB253C000000000000000000000000000000000000000000000000924119BD60578DBC0000000000000000000000000000000000000000000000003422D0BC1004BC3C000000000000000000000000000000000000000000000000003D443C40AF1EBC0000000000000000000000000000000000000000000000004CEAFBBC30F9FA3C0000000000000000000000000000000000000000000000001C339EBC00B1B03C000000000000000000000000000000000000000000000000E468143DB49A883C0000000000000000000000000000000000000000000000008C10B3BC1C46773D000000000000000000000000000000000000000000000000C0638BBA969343BD000000000000000000000000000000000000000000000000C2C61BBD20A0723D0000000000000000000000000000000000000000000000001C30103D7066E13C00000000000000000000000000000000000000000000000020BD7A3BD82628BD000000000000000000000000000000000000000000000000B84FE63C5A261B3D0000000000000000000000000000000000000000000000002082DD3CB6A71DBD00000000000000000000000000000000000000000000000046C3533D3C313A3D0000000000000000000000000000000000000000000000008CE002BDD883503C00000000000000000000000000000000000000000000000064017BBD50AA98BB00000000000000000000000000000000000000000000000028BB283C18A27FBC00000000000000000000000000000000000000000000000000041B3B10D43B3C00000000000000000000000000000000000000000000000002972B3DDA8C28BD00000000000000000000000000000000000000000000000030A4BCBB441643BD00000000000000000000000000000000000000000000000020FD2BBD00E3A1B9000000000000000000000000000000000000000000000000800423BDFC7985BC000000000000000000000000000000000000000000000000BE2239BD98C5B3BC000000000000000000000000000000000000000000000000380718BDC090DBBA000000000000000000000000000000000000000000000000F0E03ABC4A9229BD000000000000000000000000000000000000000000000000004E6F3D120C173D000000000000000000000000000000000000000000000000389E4B3D609F59BB000000000000000000000000000000000000000000000000A22B6BBD48CA643D0000000000000000000000000000000000000000000000001079B3BBF871A53C0000000000000000000000000000000000000000000000003C6BD43C16E219BD000000000000000000000000000000000000000000000000C6E800BD148F2BBD000000000000000000000000000000000000000000000000E02908BC34CDA23C00000000000000000000000000000000000000000000000000E9FF3B861F623D00000000000000000000000000000000000000000000000010E4E13BACCD54BD000000000000000000000000000000000000000000000000C06F643CF06597BB000000000000000000000000000000000000000000000000741A25BD8E4E23BD0000000000000000000000000000000000000000000000001A8262BDA00B003C000000000000000000000000000000000000000000000000CA2C3EBDF41F04BD000000000000000000000000000000000000000000000000F05950BC305165BC000000000000000000000000000000000000000000000000A8083E3CD61610BD0000000000000000000000000000000000000000000000007CF8D43CA84945BD000000000000000000000000000000000000000000000000D8EFC23C2CDF8EBC00000000000000000000000000000000000000000000000074D8AEBC283C903C000000000000000000000000000000000000000000000000F0230BBD60AB12BB000000000000000000000000000000000000000000000000F23F04BDAC108BBC000000000000000000000000000000000000000000000000683D2EBC7A225B3D000000000000000000000000000000000000000000000000806062BD6C1F1DBD000000000000000000000000000000000000000000000000905DFEBCF0CF34BC000000000000000000000000000000000000000000000000A092D33B3068CD3C000000000000000000000000000000000000000000000000303A593C542BF33C0000000000000000000000000000000000000000000000004EC0283DC8C9773D00000000000000000000000000000000000000000000000028A6763CFA6533BD0000000000000000000000000000000000000000000000003E72263D34CE093D000000000000000000000000000000000000000000000000B43E5F3DC0B5C13A0000000000000000000000000000000000000000000000007A4F0DBD0CF3BCBC000000000000000000000000000000000000000000000000A69403BDEEC353BD00000000000000000000000000000000000000000000000010EE85BCE09CA8BB000000000000000000000000000000000000000000000000C02FC8BC903EBDBB000000000000000000000000000000000000000000000000D8EB833CE022673C0000000000000000000000000000000000000000000000006059CF3BB01F36BC0000000000000000000000000000000000000000000000005411373D926E323D000000000000000000000000000000000000000000000000A042B03CD42E5B3D0000000000000000000000000000000000000000000000008CF34B3DFA0558BD000000000000000000000000000000000000000000000000707A733CE82261BD000000000000000000000000000000000000000000000000D039963C580BC23C000000000000000000000000000000000000000000000000E8E4523C209137BD00000000000000000000000000000000000000000000000036B02E3DC0E501BD0000000000000000000000000000000000000000000000009C30823C6414BCBC00000000000000000000000000000000000000000000000002FE05BD00207D39000000000000000000000000000000000000000000000000903EDA3C6A31253D000000000000000000000000000000000000000000000000388DCABC7AB8473D0000000000000000000000000000000000000000000000006008DDBB40075FBB00000000000000000000000000000000000000000000000030D8233D2C91D13C000000000000000000000000000000000000000000000000E8A42A3D00BF543D000000000000000000000000000000000000000000000000D461E8BC34AEF8BC00000000000000000000000000000000000000000000000060F833BC4EC812BD000000000000000000000000000000000000000000000000C024963CA492E53C0000000000000000000000000000000000000000000000008E8175BD3A5F123D000000000000000000000000000000000000000000000000602F9EBCB8F076BD0000000000000000000000000000000000000000000000004031E73AAC737C3D000000000000000000000000000000000000000000000000A8B72F3C00F62FBA00000000000000000000000000000000000000000000000008CB653D607246BD000000000000000000000000000000000000000000000000D4D5743DEACF5FBD000000000000000000000000000000000000000000000000DC687E3DF4ECC03C000000000000000000000000000000000000000000000000D040763C387581BC0000000000000000000000000000000000000000000000005018A3BC5A102A3D0000000000000000000000000000000000000000000000008E4A143D80473E3D000000000000000000000000000000000000000000000000B87248BD906ADA3C0000000000000000000000000000000000000000000000008E4D743DD8C9103C000000000000000000000000000000000000000000000000529341BDDED3153D0000000000000000000000000000000000000000000000000EF84A3DB07346BD000000000000000000000000000000000000000000000000D86C4B3C44633BBD00000000000000000000000000000000000000000000000040CC753C8034B13A000000000000000000000000000000000000000000000000C0E9BA3C4499FB3C000000000000000000000000000000000000000000000000CA3C193D340918BD000000000000000000000000000000000000000000000000C20A473D3ADC7FBD00000000000000000000000000000000000000000000000050951EBD52504F3D000000000000000000000000000000000000000000000000CC96B5BC00B29BBC00000000000000000000000000000000000000000000000056466B3DB4B6763D000000000000000000000000000000000000000000000000A82472BD7C7C3CBD00000000000000000000000000000000000000000000000050AA513C50CFB7BB0000000000000000000000000000000000000000000000007A9E1FBD78CB5ABD000000000000000000000000000000000000000000000000104486BBA0F314BB0000000000000000000000000000000000000000000000001052A23CB81EB33C000000000000000000000000000000000000000000000000D2DD79BDD098BF3B000000000000000000000000000000000000000000000000B00EB6BC7436F63C00000000000000000000000000000000000000000000000036CC2CBDB227063D000000000000000000000000000000000000000000000000E80470BD4C7F333D000000000000000000000000000000000000000000000000181468BDC032EEBC00000000000000000000000000000000000000000000000008D17DBDBAED04BD000000000000000000000000000000000000000000000000B83743BCCC41793D0000000000000000000000000000000000000000000000005073AEBB90E485BC0000000000000000000000000000000000000000000000007410A83CD0B733BD000000000000000000000000000000000000000000000000842BA93C307145BD000000000000000000000000000000000000000000000000D822EABC10D5F23B00000000000000000000000000000000000000000000000040CB9CBAC84ED03C000000000000000000000000000000000000000000000000C490903C54F9D13C000000000000000000000000000000000000000000000000EC2A21BD3078423D00000000000000000000000000000000000000000000000006D552BD24DEF3BC000000000000000000000000000000000000000000000000B4F1E03CB84EAF3C0000000000000000000000000000000000000000000000003C6945BD584FE7BC000000000000000000000000000000000000000000000000E25B72BDFC47E1BC00000000000000000000000000000000000000000000000048436D3C0C59953C000000000000000000000000000000000000000000000000E039593C10E12E3C00000000000000000000000000000000000000000000000062141EBD40AE8D3A0000000000000000000000000000000000000000000000003E6835BDDC59153D000000000000000000000000000000000000000000000000A8D1D1BCB84666BC000000000000000000000000000000000000000000000000F01CD0BC8E400ABD000000000000000000000000000000000000000000000000C0821EBB48A9093D000000000000000000000000000000000000000000000000006213BCC437EDBC00000000000000000000000000000000000000000000000070DA8CBCFC62CB3C000000000000000000000000000000000000000000000000B4C42ABDB81824BC000000000000000000000000000000000000000000000000B24E32BD50865EBD000000000000000000000000000000000000000000000000743147BD2C6B9A3C000000000000000000000000000000000000000000000000E0466A3B001C06BB000000000000000000000000000000000000000000000000"> : tensor<1x256x8x1xf32>,
]>
#executable_target_embedded_elf_x86_64 = #hal.executable.target<"llvm-cpu", "embedded-elf-x86_64", {cpu = "znver3", cpu_features = "+prfchw,-cldemote,+avx,+aes,+sahf,+pclmul,-xop,+crc32,-amx-fp8,+xsaves,-avx512fp16,-usermsr,-sm4,-egpr,+sse4.1,-avx512ifma,+xsave,+sse4.2,-tsxldtrk,-sm3,-ptwrite,-widekl,-movrs,+invpcid,+64bit,+xsavec,-avx10.1-512,-avx512vpopcntdq,+cmov,-avx512vp2intersect,-avx512cd,+movbe,-avxvnniint8,-ccmp,-amx-int8,-kl,-avx10.1-256,-sha512,-avxvnni,-rtm,+adx,+avx2,-hreset,-movdiri,-serialize,+vpclmulqdq,-avx512vl,-uintr,-cf,+clflushopt,-raoint,-cmpccxadd,+bmi,-amx-tile,+sse,-avx10.2-256,-gfni,-avxvnniint16,-amx-fp16,-zu,-ndd,+xsaveopt,+rdrnd,-avx512f,-amx-bf16,-avx512bf16,-avx512vnni,-push2pop2,+cx8,-avx512bw,+sse3,+pku,-nf,-amx-tf32,-amx-avx512,+fsgsbase,+clzero,+mwaitx,-lwp,+lzcnt,+sha,-movdir64b,-ppx,+wbnoinvd,-enqcmd,-amx-transpose,-avx10.2-512,-avxneconvert,-tbm,-pconfig,-amx-complex,+ssse3,+cx16,+bmi2,+fma,+popcnt,-avxifma,+f16c,-avx512bitalg,+rdpru,+clwb,+mmx,+sse2,+rdseed,-avx512vbmi2,-prefetchi,-amx-movrs,+rdpid,-fma4,-avx512vbmi,+shstk,+vaes,-waitpkg,-sgx,+fxsr,-avx512dq,+sse4a", data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", iree.encoding.resolver = #iree_cpu.cpu_encoding_resolver<>, max_stack_allocation_size = 32768 : i64, native_vector_size = 32 : i64, target_triple = "x86_64-unknown-unknown-eabi-elf"}>
#pipeline_layout = #hal.pipeline.layout<bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, Indirect>, #hal.pipeline.binding<storage_buffer, Indirect>, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#pipeline_layout1 = #hal.pipeline.layout<bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#pipeline_layout2 = #hal.pipeline.layout<bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, ReadOnly>, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#pipeline_layout3 = #hal.pipeline.layout<constants = 4, bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, Indirect>, #hal.pipeline.binding<storage_buffer, Indirect>, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#pipeline_layout4 = #hal.pipeline.layout<bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, Indirect>, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#pipeline_layout5 = #hal.pipeline.layout<constants = 3, bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, Indirect>, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#pipeline_layout6 = #hal.pipeline.layout<constants = 2, bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#pipeline_layout7 = #hal.pipeline.layout<constants = 3, bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#pipeline_layout8 = #hal.pipeline.layout<constants = 4, bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#pipeline_layout9 = #hal.pipeline.layout<constants = 3, bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#device_target_local = #hal.device.target<"local", [#executable_target_embedded_elf_x86_64]> : !hal.device
module attributes {stream.affinity.default = #hal.device.affinity<@__device_0>} {
  util.global private @__device_0 = #device_target_local
  hal.executable private @main_graph$async_dispatch_0 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_0_elementwise_broadcast ordinal(0) layout(#pipeline_layout) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        hal.return %c1, %c1, %c1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_0_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(8 : i64) : i64
          %1 = llvm.mlir.constant(32 : i64) : i64
          %2 = llvm.mlir.constant(64 : index) : i64
          %3 = llvm.mlir.constant(true) : i1
          %4 = llvm.mlir.constant(2 : i32) : i32
          %5 = llvm.mlir.constant(0 : i32) : i32
          %6 = llvm.mlir.constant(1 : i32) : i32
          %7 = llvm.mlir.constant(3 : i32) : i32
          %8 = llvm.mlir.constant(-2.59630184E-7 : f32) : f32
          %9 = llvm.mlir.constant(2.47562348E-5 : f32) : f32
          %10 = llvm.mlir.constant(-0.00138883304 : f32) : f32
          %11 = llvm.mlir.constant(0.0416666418 : f32) : f32
          %12 = llvm.mlir.constant(-5.000000e-01 : f32) : f32
          %13 = llvm.mlir.constant(-2.50293279E-8 : f32) : f32
          %14 = llvm.mlir.constant(2.76001265E-6 : f32) : f32
          %15 = llvm.mlir.constant(-1.98426045E-4 : f32) : f32
          %16 = llvm.mlir.constant(0.00833334774 : f32) : f32
          %17 = llvm.mlir.constant(-0.166666672 : f32) : f32
          %18 = llvm.mlir.constant(-1.000000e+00 : f32) : f32
          %19 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %20 = llvm.mlir.constant(1.57079637 : f32) : f32
          %21 = llvm.mlir.constant(0.636619746 : f32) : f32
          %22 = llvm.mlir.constant(9.99999974E-5 : f32) : f32
          %23 = llvm.mlir.constant(2.000000e+00 : f32) : f32
          %24 = llvm.mlir.constant(5.000000e-01 : f32) : f32
          %25 = llvm.mlir.constant(8 : index) : i64
          %26 = llvm.mlir.constant(4 : index) : i64
          %27 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %28 = llvm.extractvalue %27[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %29 = llvm.load %28 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %3 ["align"(%29, %2 : !llvm.ptr, i64)] : i1
          %30 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %31 = llvm.extractvalue %30[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %32 = llvm.getelementptr %31[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %33 = llvm.load %32 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %3 ["align"(%33, %2 : !llvm.ptr, i64)] : i1
          %34 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %35 = llvm.extractvalue %34[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %36 = llvm.getelementptr %35[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %37 = llvm.load %36 : !llvm.ptr -> !llvm.ptr
          %38 = llvm.mul %25, %0 : i64
          %39 = llvm.udiv %38, %1 : i64
          %40 = llvm.getelementptr %37[%39] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%40, %25 : !llvm.ptr, i64)] : i1
          %41 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %42 = llvm.extractvalue %41[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %43 = llvm.getelementptr %42[3] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %44 = llvm.load %43 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %3 ["align"(%44, %2 : !llvm.ptr, i64)] : i1
          %45 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %46 = llvm.extractvalue %45[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %47 = llvm.getelementptr %46[4] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %48 = llvm.load %47 : !llvm.ptr -> !llvm.ptr
          %49 = llvm.mul %26, %0 : i64
          %50 = llvm.udiv %49, %1 : i64
          %51 = llvm.getelementptr %48[%50] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%51, %26 : !llvm.ptr, i64)] : i1
          %52 = llvm.load %29 : !llvm.ptr -> f32
          %53 = llvm.fmul %52, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %54 = llvm.getelementptr inbounds|nuw %29[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %55 = llvm.load %54 : !llvm.ptr -> f32
          %56 = llvm.fmul %55, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %57 = llvm.fadd %53, %56 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %58 = llvm.fdiv %57, %23 : f32
          %59 = llvm.fsub %56, %53 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %60 = llvm.fdiv %59, %24 : f32
          %61 = llvm.getelementptr inbounds|nuw %33[2] : (!llvm.ptr) -> !llvm.ptr, f32
          %62 = llvm.load %61 : !llvm.ptr -> f32
          %63 = llvm.fdiv %60, %23 : f32
          %64 = llvm.fadd %62, %63 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %65 = llvm.fmul %64, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %66 = llvm.intr.floor(%65) : (f32) -> f32
          %67 = llvm.fmul %66, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %68 = llvm.fsub %64, %67 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %69 = llvm.fptosi %66 : f32 to i32
          %70 = llvm.and %69, %7 : i32
          %71 = llvm.icmp "eq" %70, %6 : i32
          %72 = llvm.icmp "eq" %70, %7 : i32
          %73 = llvm.or %71, %72 : i1
          %74 = llvm.icmp "sgt" %70, %6 : i32
          %75 = llvm.fmul %68, %68 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %76 = llvm.select %73, %19, %68 : i1, f32
          %77 = llvm.select %73, %12, %17 : i1, f32
          %78 = llvm.select %73, %11, %16 : i1, f32
          %79 = llvm.select %73, %10, %15 : i1, f32
          %80 = llvm.select %73, %9, %14 : i1, f32
          %81 = llvm.select %73, %8, %13 : i1, f32
          %82 = llvm.intr.fma(%75, %81, %80) : (f32, f32, f32) -> f32
          %83 = llvm.intr.fma(%75, %82, %79) : (f32, f32, f32) -> f32
          %84 = llvm.intr.fma(%75, %83, %78) : (f32, f32, f32) -> f32
          %85 = llvm.intr.fma(%75, %84, %77) : (f32, f32, f32) -> f32
          %86 = llvm.intr.fma(%75, %85, %19) : (f32, f32, f32) -> f32
          %87 = llvm.fmul %76, %86 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %88 = llvm.fmul %87, %18 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %89 = llvm.select %74, %88, %87 : i1, f32
          %90 = llvm.fmul %58, %89 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %91 = llvm.getelementptr inbounds|nuw %33[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %92 = llvm.load %91 : !llvm.ptr -> f32
          %93 = llvm.fadd %92, %90 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %93, %51 : f32, !llvm.ptr
          %94 = llvm.load %29 : !llvm.ptr -> f32
          %95 = llvm.fmul %94, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %96 = llvm.load %54 : !llvm.ptr -> f32
          %97 = llvm.fmul %96, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %98 = llvm.fadd %95, %97 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %99 = llvm.fdiv %98, %23 : f32
          %100 = llvm.fsub %97, %95 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %101 = llvm.fdiv %100, %24 : f32
          %102 = llvm.load %61 : !llvm.ptr -> f32
          %103 = llvm.fdiv %101, %23 : f32
          %104 = llvm.fadd %102, %103 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %105 = llvm.fmul %104, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %106 = llvm.intr.floor(%105) : (f32) -> f32
          %107 = llvm.fmul %106, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %108 = llvm.fsub %104, %107 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %109 = llvm.fptosi %106 : f32 to i32
          %110 = llvm.and %109, %7 : i32
          %111 = llvm.icmp "eq" %110, %5 : i32
          %112 = llvm.icmp "eq" %110, %6 : i32
          %113 = llvm.icmp "eq" %110, %4 : i32
          %114 = llvm.or %111, %113 : i1
          %115 = llvm.or %112, %113 : i1
          %116 = llvm.fmul %108, %108 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %117 = llvm.select %114, %19, %108 : i1, f32
          %118 = llvm.select %114, %12, %17 : i1, f32
          %119 = llvm.select %114, %11, %16 : i1, f32
          %120 = llvm.select %114, %10, %15 : i1, f32
          %121 = llvm.select %114, %9, %14 : i1, f32
          %122 = llvm.select %114, %8, %13 : i1, f32
          %123 = llvm.intr.fma(%116, %122, %121) : (f32, f32, f32) -> f32
          %124 = llvm.intr.fma(%116, %123, %120) : (f32, f32, f32) -> f32
          %125 = llvm.intr.fma(%116, %124, %119) : (f32, f32, f32) -> f32
          %126 = llvm.intr.fma(%116, %125, %118) : (f32, f32, f32) -> f32
          %127 = llvm.intr.fma(%116, %126, %19) : (f32, f32, f32) -> f32
          %128 = llvm.fmul %117, %127 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %129 = llvm.fmul %128, %18 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %130 = llvm.select %115, %129, %128 : i1, f32
          %131 = llvm.fmul %99, %130 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %132 = llvm.load %33 : !llvm.ptr -> f32
          %133 = llvm.fadd %132, %131 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %133, %44 : f32, !llvm.ptr
          %134 = llvm.load %29 : !llvm.ptr -> f32
          %135 = llvm.fmul %134, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %136 = llvm.load %54 : !llvm.ptr -> f32
          %137 = llvm.fmul %136, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %138 = llvm.fsub %137, %135 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %139 = llvm.fdiv %138, %24 : f32
          %140 = llvm.load %61 : !llvm.ptr -> f32
          %141 = llvm.fadd %140, %139 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %141, %40 : f32, !llvm.ptr
          llvm.return %5 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_1 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_1_slow_memcpy ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c2 = arith.constant 2 : index
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        hal.return %c2, %c1, %c1_0 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_1_slow_memcpy(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(66 : index) : i64
          %2 = llvm.mlir.constant(4356 : index) : i64
          %3 = llvm.mlir.constant(true) : i1
          %4 = llvm.mlir.constant(4096 : index) : i64
          %5 = llvm.mlir.constant(8 : index) : i64
          %6 = llvm.mlir.constant(1 : index) : i64
          %7 = llvm.mlir.constant(64 : index) : i64
          %8 = llvm.mlir.constant(32 : index) : i64
          %9 = llvm.mlir.constant(3 : index) : i64
          %10 = llvm.mlir.constant(0 : index) : i64
          %11 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %12 = llvm.extractvalue %11[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %13 = llvm.load %12 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %3 ["align"(%13, %7 : !llvm.ptr, i64)] : i1
          %14 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %15 = llvm.extractvalue %14[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %16 = llvm.getelementptr %15[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %17 = llvm.load %16 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %3 ["align"(%17, %7 : !llvm.ptr, i64)] : i1
          %18 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)>
          %19 = llvm.extractvalue %18[0] : !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)> 
          %20 = llvm.zext %19 : i32 to i64
          %21 = llvm.mul %20, %8 overflow<nsw> : i64
          llvm.br ^bb1(%10 : i64)
        ^bb1(%22: i64):  // 2 preds: ^bb0, ^bb6
          %23 = llvm.icmp "slt" %22, %9 : i64
          llvm.cond_br %23, ^bb2(%10 : i64), ^bb7
        ^bb2(%24: i64):  // 2 preds: ^bb1, ^bb5
          %25 = llvm.icmp "slt" %24, %8 : i64
          llvm.cond_br %25, ^bb3(%10 : i64), ^bb6
        ^bb3(%26: i64):  // 2 preds: ^bb2, ^bb4
          %27 = llvm.icmp "slt" %26, %7 : i64
          llvm.cond_br %27, ^bb4, ^bb5
        ^bb4:  // pred: ^bb3
          %28 = llvm.add %21, %24 : i64
          %29 = llvm.mul %22, %4 : i64
          %30 = llvm.mul %28, %7 : i64
          %31 = llvm.add %29, %30 : i64
          %32 = llvm.add %31, %26 : i64
          %33 = llvm.getelementptr %13[%32] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %34 = llvm.load %33 {alignment = 4 : i64} : !llvm.ptr -> vector<8xf32>
          %35 = llvm.add %28, %6 : i64
          %36 = llvm.add %26, %6 : i64
          %37 = llvm.mul %22, %2 : i64
          %38 = llvm.mul %35, %1 : i64
          %39 = llvm.add %37, %38 : i64
          %40 = llvm.add %39, %36 : i64
          %41 = llvm.getelementptr %17[%40] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %34, %41 {alignment = 4 : i64} : vector<8xf32>, !llvm.ptr
          %42 = llvm.add %26, %5 : i64
          llvm.br ^bb3(%42 : i64)
        ^bb5:  // pred: ^bb3
          %43 = llvm.add %24, %6 : i64
          llvm.br ^bb2(%43 : i64)
        ^bb6:  // pred: ^bb2
          %44 = llvm.add %22, %6 : i64
          llvm.br ^bb1(%44 : i64)
        ^bb7:  // pred: ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_2 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_2_conv_4x16x16x3x4x4_f32 ordinal(0) layout(#pipeline_layout2) count(%arg0: !hal.device) -> (index, index, index) {
        %c16 = arith.constant 16 : index
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        hal.return %c16, %c1, %c1_0 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.mlir.global private constant @__constant_4xf32(dense<[-0.0291617829, 0.0185516253, -0.0336317755, 0.0323117375]> : tensor<4xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<4 x f32>
        llvm.func @main_graph$async_dispatch_2_conv_4x16x16x3x4x4_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.poison : vector<8xf32>
          %2 = llvm.mlir.constant(0 : i64) : i64
          %3 = llvm.mlir.constant(256 : index) : i64
          %4 = llvm.mlir.constant(8 : i64) : i64
          %5 = llvm.mlir.constant(32 : i64) : i64
          %6 = llvm.mlir.constant(48 : index) : i64
          %7 = llvm.mlir.constant(64 : index) : i64
          %8 = llvm.mlir.constant(true) : i1
          %9 = llvm.mlir.constant(66 : index) : i64
          %10 = llvm.mlir.constant(4356 : index) : i64
          %11 = llvm.mlir.addressof @__constant_4xf32 : !llvm.ptr
          %12 = llvm.mlir.constant(-1 : index) : i64
          %13 = llvm.mlir.constant(8 : index) : i64
          %14 = llvm.mlir.constant(16 : index) : i64
          %15 = llvm.mlir.constant(1 : index) : i64
          %16 = llvm.mlir.constant(4 : index) : i64
          %17 = llvm.mlir.constant(3 : index) : i64
          %18 = llvm.mlir.constant(dense<0.000000e+00> : vector<8xf32>) : vector<8xf32>
          %19 = llvm.mlir.constant(52288 : index) : i64
          %20 = llvm.mlir.constant(0 : index) : i64
          %21 = llvm.getelementptr %11[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<4 x f32>
          %22 = llvm.alloca %13 x f32 {alignment = 64 : i64} : (i64) -> !llvm.ptr
          %23 = llvm.alloca %13 x f32 {alignment = 64 : i64} : (i64) -> !llvm.ptr
          %24 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %25 = llvm.extractvalue %24[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %26 = llvm.load %25 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %8 ["align"(%26, %7 : !llvm.ptr, i64)] : i1
          %27 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %28 = llvm.extractvalue %27[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %29 = llvm.getelementptr %28[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %30 = llvm.load %29 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %8 ["align"(%30, %7 : !llvm.ptr, i64)] : i1
          %31 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %32 = llvm.extractvalue %31[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %33 = llvm.getelementptr %32[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %34 = llvm.load %33 : !llvm.ptr -> !llvm.ptr
          %35 = llvm.mul %19, %4 : i64
          %36 = llvm.udiv %35, %5 : i64
          %37 = llvm.getelementptr %34[%36] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %8 ["align"(%37, %7 : !llvm.ptr, i64)] : i1
          %38 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)>
          %39 = llvm.extractvalue %38[0] : !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)> 
          %40 = llvm.zext %39 : i32 to i64
          %41 = llvm.sdiv %40, %16 : i64
          %42 = llvm.mul %41, %16 : i64
          %43 = llvm.icmp "ne" %40, %42 : i64
          %44 = llvm.icmp "slt" %40, %20 : i64
          %45 = llvm.and %43, %44 : i1
          %46 = llvm.add %41, %12 : i64
          %47 = llvm.select %45, %46, %41 : i1, i64
          %48 = llvm.srem %40, %16 : i64
          %49 = llvm.icmp "slt" %48, %20 : i64
          %50 = llvm.add %48, %16 overflow<nsw> : i64
          %51 = llvm.select %49, %50, %48 : i1, i64
          %52 = llvm.mul %51, %16 overflow<nsw> : i64
          %53 = llvm.mul %20, %13 : i64
          %54 = llvm.add %53, %53 : i64
          %55 = llvm.add %54, %20 : i64
          %56 = llvm.getelementptr %23[%55] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %18, %56 {alignment = 4 : i64} : vector<8xf32>, !llvm.ptr
          %57 = llvm.getelementptr %21[%47] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %58 = llvm.load %57 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          llvm.br ^bb1(%20 : i64)
        ^bb1(%59: i64):  // 2 preds: ^bb0, ^bb16
          %60 = llvm.icmp "slt" %59, %16 : i64
          llvm.cond_br %60, ^bb2(%20 : i64), ^bb17
        ^bb2(%61: i64):  // 2 preds: ^bb1, ^bb15
          %62 = llvm.icmp "slt" %61, %14 : i64
          llvm.cond_br %62, ^bb3, ^bb16
        ^bb3:  // pred: ^bb2
          %63 = llvm.mul %61, %16 overflow<nsw> : i64
          llvm.br ^bb4(%20 : i64)
        ^bb4(%64: i64):  // 2 preds: ^bb3, ^bb5
          %65 = llvm.icmp "slt" %64, %13 : i64
          llvm.cond_br %65, ^bb5, ^bb6(%20 : i64)
        ^bb5:  // pred: ^bb4
          %66 = llvm.mul %20, %13 overflow<nsw, nuw> : i64
          %67 = llvm.add %66, %66 overflow<nsw, nuw> : i64
          %68 = llvm.add %67, %64 overflow<nsw, nuw> : i64
          %69 = llvm.getelementptr inbounds|nuw %23[%68] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %70 = llvm.load %69 : !llvm.ptr -> f32
          %71 = llvm.getelementptr inbounds|nuw %22[%68] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %70, %71 : f32, !llvm.ptr
          %72 = llvm.add %64, %15 : i64
          llvm.br ^bb4(%72 : i64)
        ^bb6(%73: i64):  // 2 preds: ^bb4, ^bb14
          %74 = llvm.icmp "slt" %73, %17 : i64
          llvm.cond_br %74, ^bb7(%20 : i64), ^bb15
        ^bb7(%75: i64):  // 2 preds: ^bb6, ^bb13
          %76 = llvm.icmp "slt" %75, %16 : i64
          llvm.cond_br %76, ^bb8, ^bb14
        ^bb8:  // pred: ^bb7
          %77 = llvm.mul %59, %16 overflow<nsw> : i64
          %78 = llvm.mul %51, %14 overflow<nsw> : i64
          %79 = llvm.add %77, %78 : i64
          %80 = llvm.add %79, %75 : i64
          llvm.br ^bb9(%20 : i64)
        ^bb9(%81: i64):  // 2 preds: ^bb8, ^bb12
          %82 = llvm.icmp "slt" %81, %13 : i64
          llvm.cond_br %82, ^bb10(%20 : i64), ^bb13
        ^bb10(%83: i64):  // 2 preds: ^bb9, ^bb11
          %84 = llvm.icmp "slt" %83, %16 : i64
          llvm.cond_br %84, ^bb11, ^bb12
        ^bb11:  // pred: ^bb10
          %85 = llvm.mul %81, %16 overflow<nsw> : i64
          %86 = llvm.add %63, %85 : i64
          %87 = llvm.add %86, %83 : i64
          %88 = llvm.mul %73, %10 overflow<nsw, nuw> : i64
          %89 = llvm.mul %80, %9 overflow<nsw, nuw> : i64
          %90 = llvm.add %88, %89 overflow<nsw, nuw> : i64
          %91 = llvm.add %90, %87 overflow<nsw, nuw> : i64
          %92 = llvm.getelementptr inbounds|nuw %26[%91] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %93 = llvm.load %92 : !llvm.ptr -> f32
          %94 = llvm.mul %47, %6 overflow<nsw, nuw> : i64
          %95 = llvm.mul %73, %14 overflow<nsw, nuw> : i64
          %96 = llvm.add %94, %95 overflow<nsw, nuw> : i64
          %97 = llvm.mul %75, %16 overflow<nsw, nuw> : i64
          %98 = llvm.add %96, %97 overflow<nsw, nuw> : i64
          %99 = llvm.add %98, %83 overflow<nsw, nuw> : i64
          %100 = llvm.getelementptr inbounds|nuw %30[%99] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %101 = llvm.load %100 : !llvm.ptr -> f32
          %102 = llvm.mul %20, %13 overflow<nsw, nuw> : i64
          %103 = llvm.add %102, %102 overflow<nsw, nuw> : i64
          %104 = llvm.add %103, %81 overflow<nsw, nuw> : i64
          %105 = llvm.getelementptr inbounds|nuw %22[%104] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %106 = llvm.load %105 : !llvm.ptr -> f32
          %107 = llvm.fmul %93, %101 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %108 = llvm.fadd %106, %107 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %108, %105 : f32, !llvm.ptr
          %109 = llvm.add %83, %15 : i64
          llvm.br ^bb10(%109 : i64)
        ^bb12:  // pred: ^bb10
          %110 = llvm.add %81, %15 : i64
          llvm.br ^bb9(%110 : i64)
        ^bb13:  // pred: ^bb9
          %111 = llvm.add %75, %15 : i64
          llvm.br ^bb7(%111 : i64)
        ^bb14:  // pred: ^bb7
          %112 = llvm.add %73, %15 : i64
          llvm.br ^bb6(%112 : i64)
        ^bb15:  // pred: ^bb6
          %113 = llvm.getelementptr %22[%55] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %114 = llvm.load %113 {alignment = 4 : i64} : !llvm.ptr -> vector<8xf32>
          %115 = llvm.extractelement %58[%2 : i64] : vector<1xf32>
          %116 = llvm.insertelement %115, %1[%0 : i32] : vector<8xf32>
          %117 = llvm.shufflevector %116, %1 [0, 0, 0, 0, 0, 0, 0, 0] : vector<8xf32> 
          %118 = llvm.fadd %114, %117 {fastmathFlags = #llvm.fastmath<contract>} : vector<8xf32>
          %119 = llvm.fcmp "ugt" %118, %18 : vector<8xf32>
          %120 = llvm.select %119, %118, %18 : vector<8xi1>, vector<8xf32>
          %121 = llvm.add %52, %59 : i64
          %122 = llvm.mul %47, %3 : i64
          %123 = llvm.mul %121, %14 : i64
          %124 = llvm.add %122, %123 : i64
          %125 = llvm.add %124, %61 : i64
          %126 = llvm.getelementptr %37[%125] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %120, %126 {alignment = 4 : i64} : vector<8xf32>, !llvm.ptr
          %127 = llvm.add %61, %13 : i64
          llvm.br ^bb2(%127 : i64)
        ^bb16:  // pred: ^bb2
          %128 = llvm.add %59, %15 : i64
          llvm.br ^bb1(%128 : i64)
        ^bb17:  // pred: ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_3 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_3_conv_4x8x8x2x2_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c16 = arith.constant 16 : index
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        hal.return %c16, %c1, %c1_0 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_3_conv_4x8x8x2x2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(64 : index) : i64
          %2 = llvm.mlir.constant(true) : i1
          %3 = llvm.mlir.constant(256 : index) : i64
          %4 = llvm.mlir.constant(16 : index) : i64
          %5 = llvm.mlir.constant(8 : i64) : i64
          %6 = llvm.mlir.constant(32 : i64) : i64
          %7 = llvm.mlir.constant(-1 : index) : i64
          %8 = llvm.mlir.constant(8 : index) : i64
          %9 = llvm.mlir.constant(4 : index) : i64
          %10 = llvm.mlir.constant(dense<0xFF800000> : vector<8xf32>) : vector<8xf32>
          %11 = llvm.mlir.constant(0 : index) : i64
          %12 = llvm.mlir.constant(52288 : index) : i64
          %13 = llvm.mlir.constant(2 : index) : i64
          %14 = llvm.mlir.constant(1 : index) : i64
          %15 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %16 = llvm.extractvalue %15[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %17 = llvm.load %16 : !llvm.ptr -> !llvm.ptr
          %18 = llvm.mul %12, %5 : i64
          %19 = llvm.udiv %18, %6 : i64
          %20 = llvm.getelementptr %17[%19] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%20, %1 : !llvm.ptr, i64)] : i1
          %21 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %22 = llvm.extractvalue %21[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %23 = llvm.getelementptr %22[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %24 = llvm.load %23 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %2 ["align"(%24, %1 : !llvm.ptr, i64)] : i1
          %25 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)>
          %26 = llvm.extractvalue %25[0] : !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)> 
          %27 = llvm.zext %26 : i32 to i64
          %28 = llvm.sdiv %27, %9 : i64
          %29 = llvm.mul %28, %9 : i64
          %30 = llvm.icmp "ne" %27, %29 : i64
          %31 = llvm.icmp "slt" %27, %11 : i64
          %32 = llvm.and %30, %31 : i1
          %33 = llvm.add %28, %7 : i64
          %34 = llvm.select %32, %33, %28 : i1, i64
          %35 = llvm.srem %27, %9 : i64
          %36 = llvm.icmp "slt" %35, %11 : i64
          %37 = llvm.add %35, %9 overflow<nsw> : i64
          %38 = llvm.select %36, %37, %35 : i1, i64
          %39 = llvm.mul %38, %13 overflow<nsw> : i64
          llvm.br ^bb1(%11 : i64)
        ^bb1(%40: i64):  // 2 preds: ^bb0, ^bb10
          %41 = llvm.icmp "slt" %40, %13 : i64
          llvm.cond_br %41, ^bb2, ^bb11
        ^bb2:  // pred: ^bb1
          %42 = llvm.add %39, %40 : i64
          %43 = llvm.mul %34, %1 : i64
          %44 = llvm.mul %42, %8 : i64
          %45 = llvm.add %43, %44 : i64
          %46 = llvm.add %45, %11 : i64
          %47 = llvm.getelementptr %24[%46] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %10, %47 {alignment = 4 : i64} : vector<8xf32>, !llvm.ptr
          llvm.br ^bb3(%11 : i64)
        ^bb3(%48: i64):  // 2 preds: ^bb2, ^bb9
          %49 = llvm.icmp "slt" %48, %13 : i64
          llvm.cond_br %49, ^bb4, ^bb10
        ^bb4:  // pred: ^bb3
          %50 = llvm.mul %40, %13 overflow<nsw> : i64
          %51 = llvm.mul %38, %9 overflow<nsw> : i64
          %52 = llvm.add %50, %51 : i64
          %53 = llvm.add %52, %48 : i64
          llvm.br ^bb5(%11 : i64)
        ^bb5(%54: i64):  // 2 preds: ^bb4, ^bb8
          %55 = llvm.icmp "slt" %54, %8 : i64
          llvm.cond_br %55, ^bb6(%11 : i64), ^bb9
        ^bb6(%56: i64):  // 2 preds: ^bb5, ^bb7
          %57 = llvm.icmp "slt" %56, %13 : i64
          llvm.cond_br %57, ^bb7, ^bb8
        ^bb7:  // pred: ^bb6
          %58 = llvm.mul %54, %13 overflow<nsw> : i64
          %59 = llvm.add %58, %56 : i64
          %60 = llvm.mul %34, %3 overflow<nsw, nuw> : i64
          %61 = llvm.mul %53, %4 overflow<nsw, nuw> : i64
          %62 = llvm.add %60, %61 overflow<nsw, nuw> : i64
          %63 = llvm.add %62, %59 overflow<nsw, nuw> : i64
          %64 = llvm.getelementptr inbounds|nuw %20[%63] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %65 = llvm.load %64 : !llvm.ptr -> f32
          %66 = llvm.mul %34, %1 overflow<nsw, nuw> : i64
          %67 = llvm.mul %42, %8 overflow<nsw, nuw> : i64
          %68 = llvm.add %66, %67 overflow<nsw, nuw> : i64
          %69 = llvm.add %68, %54 overflow<nsw, nuw> : i64
          %70 = llvm.getelementptr inbounds|nuw %24[%69] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %71 = llvm.load %70 : !llvm.ptr -> f32
          %72 = llvm.fcmp "ugt" %71, %65 : f32
          %73 = llvm.select %72, %71, %65 : i1, f32
          %74 = llvm.fcmp "uno" %65, %65 : f32
          %75 = llvm.select %74, %65, %73 : i1, f32
          llvm.store %75, %70 : f32, !llvm.ptr
          %76 = llvm.add %56, %14 : i64
          llvm.br ^bb6(%76 : i64)
        ^bb8:  // pred: ^bb6
          %77 = llvm.add %54, %14 : i64
          llvm.br ^bb5(%77 : i64)
        ^bb9:  // pred: ^bb5
          %78 = llvm.add %48, %14 : i64
          llvm.br ^bb3(%78 : i64)
        ^bb10:  // pred: ^bb3
          %79 = llvm.add %40, %14 : i64
          llvm.br ^bb1(%79 : i64)
        ^bb11:  // pred: ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_4 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_4_mmt4d_1x1x256x1x8x1_f32 ordinal(0) layout(#pipeline_layout2) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @iree_uk_mmt4d(!llvm.ptr, i64, i64, !llvm.ptr, i64, i64, !llvm.ptr, i64, i64, i64, i64, i64, i32, i32, i32, i32, !llvm.ptr) -> i32 attributes {hal.import.bitcode = true, hal.import.fields = ["processor_data"], llvm.bareptr = true}
        llvm.func @main_graph$async_dispatch_4_mmt4d_1x1x256x1x8x1_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(52255 : i64) : i64
          %1 = llvm.mlir.constant(8 : i64) : i64
          %2 = llvm.mlir.constant(0 : i32) : i32
          %3 = llvm.mlir.constant(288 : index) : i64
          %4 = llvm.mlir.constant(192 : index) : i64
          %5 = llvm.mlir.constant(8 : index) : i64
          %6 = llvm.mlir.constant(2048 : index) : i64
          %7 = llvm.mlir.constant(1537 : i32) : i32
          %8 = llvm.mlir.constant(8 : i32) : i32
          %9 = llvm.mlir.constant(1 : i32) : i32
          %10 = llvm.mlir.constant(256 : index) : i64
          %11 = llvm.mlir.constant(1 : index) : i64
          %12 = llvm.mlir.constant(0 : index) : i64
          %13 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %14 = llvm.extractvalue %13[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %15 = llvm.load %14 : !llvm.ptr -> !llvm.ptr
          %16 = llvm.getelementptr %14[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %17 = llvm.load %16 : !llvm.ptr -> !llvm.ptr
          %18 = llvm.getelementptr %14[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %19 = llvm.load %18 : !llvm.ptr -> !llvm.ptr
          %20 = llvm.getelementptr inbounds %arg0[4] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %21 = llvm.alloca %1 x i64 {alignment = 8 : i64} : (i64) -> !llvm.ptr
          %22 = llvm.load %20 : !llvm.ptr -> i64
          %23 = llvm.or %22, %0 : i64
          llvm.store %23, %21 : i64, !llvm.ptr
          %24 = llvm.getelementptr inbounds %20[1] : (!llvm.ptr) -> !llvm.ptr, i64
          %25 = llvm.load %24 : !llvm.ptr -> i64
          %26 = llvm.getelementptr inbounds %21[1] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %25, %26 : i64, !llvm.ptr
          %27 = llvm.getelementptr inbounds %20[2] : (!llvm.ptr) -> !llvm.ptr, i64
          %28 = llvm.load %27 : !llvm.ptr -> i64
          %29 = llvm.getelementptr inbounds %21[2] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %28, %29 : i64, !llvm.ptr
          %30 = llvm.getelementptr inbounds %20[3] : (!llvm.ptr) -> !llvm.ptr, i64
          %31 = llvm.load %30 : !llvm.ptr -> i64
          %32 = llvm.getelementptr inbounds %21[3] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %31, %32 : i64, !llvm.ptr
          %33 = llvm.getelementptr inbounds %20[4] : (!llvm.ptr) -> !llvm.ptr, i64
          %34 = llvm.load %33 : !llvm.ptr -> i64
          %35 = llvm.getelementptr inbounds %21[4] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %34, %35 : i64, !llvm.ptr
          %36 = llvm.getelementptr inbounds %20[5] : (!llvm.ptr) -> !llvm.ptr, i64
          %37 = llvm.load %36 : !llvm.ptr -> i64
          %38 = llvm.getelementptr inbounds %21[5] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %37, %38 : i64, !llvm.ptr
          %39 = llvm.getelementptr inbounds %20[6] : (!llvm.ptr) -> !llvm.ptr, i64
          %40 = llvm.load %39 : !llvm.ptr -> i64
          %41 = llvm.getelementptr inbounds %21[6] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %40, %41 : i64, !llvm.ptr
          %42 = llvm.getelementptr inbounds %20[7] : (!llvm.ptr) -> !llvm.ptr, i64
          %43 = llvm.load %42 : !llvm.ptr -> i64
          %44 = llvm.getelementptr inbounds %21[7] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %43, %44 : i64, !llvm.ptr
          %45 = llvm.call @iree_uk_mmt4d(%15, %12, %10, %17, %4, %6, %19, %3, %5, %11, %11, %10, %9, %8, %9, %7, %21) : (!llvm.ptr, i64, i64, !llvm.ptr, i64, i64, !llvm.ptr, i64, i64, i64, i64, i64, i32, i32, i32, i32, !llvm.ptr) -> i32
          llvm.return %2 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_5 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_5_elementwise_broadcast ordinal(0) layout(#pipeline_layout3) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        hal.return %c1, %c1, %c1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_5_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(4 : index) : i64
          %1 = llvm.mlir.constant(64 : index) : i64
          %2 = llvm.mlir.constant(true) : i1
          %3 = llvm.mlir.constant(8 : i64) : i64
          %4 = llvm.mlir.constant(32 : i64) : i64
          %5 = llvm.mlir.constant(2 : i32) : i32
          %6 = llvm.mlir.constant(1 : i32) : i32
          %7 = llvm.mlir.constant(0 : i32) : i32
          %8 = llvm.mlir.constant(3 : i32) : i32
          %9 = llvm.mlir.constant(-2.59630184E-7 : f32) : f32
          %10 = llvm.mlir.constant(2.47562348E-5 : f32) : f32
          %11 = llvm.mlir.constant(-0.00138883304 : f32) : f32
          %12 = llvm.mlir.constant(0.0416666418 : f32) : f32
          %13 = llvm.mlir.constant(-5.000000e-01 : f32) : f32
          %14 = llvm.mlir.constant(-2.50293279E-8 : f32) : f32
          %15 = llvm.mlir.constant(2.76001265E-6 : f32) : f32
          %16 = llvm.mlir.constant(-1.98426045E-4 : f32) : f32
          %17 = llvm.mlir.constant(0.00833334774 : f32) : f32
          %18 = llvm.mlir.constant(-0.166666672 : f32) : f32
          %19 = llvm.mlir.constant(-1.000000e+00 : f32) : f32
          %20 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %21 = llvm.mlir.constant(1.57079637 : f32) : f32
          %22 = llvm.mlir.constant(0.636619746 : f32) : f32
          %23 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %24 = llvm.extractvalue %23[9] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %25 = llvm.load %24 : !llvm.ptr -> i32
          %26 = llvm.getelementptr %24[1] : (!llvm.ptr) -> !llvm.ptr, i32
          %27 = llvm.load %26 : !llvm.ptr -> i32
          %28 = llvm.getelementptr %24[2] : (!llvm.ptr) -> !llvm.ptr, i32
          %29 = llvm.load %28 : !llvm.ptr -> i32
          %30 = llvm.getelementptr %24[3] : (!llvm.ptr) -> !llvm.ptr, i32
          %31 = llvm.load %30 : !llvm.ptr -> i32
          %32 = llvm.zext %25 : i32 to i64
          %33 = llvm.zext %27 : i32 to i64
          %34 = llvm.zext %29 : i32 to i64
          %35 = llvm.zext %31 : i32 to i64
          %36 = llvm.extractvalue %23[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %37 = llvm.load %36 : !llvm.ptr -> !llvm.ptr
          %38 = llvm.mul %32, %3 : i64
          %39 = llvm.udiv %38, %4 : i64
          %40 = llvm.getelementptr %37[%39] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%40, %1 : !llvm.ptr, i64)] : i1
          %41 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %42 = llvm.extractvalue %41[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %43 = llvm.getelementptr %42[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %44 = llvm.load %43 : !llvm.ptr -> !llvm.ptr
          %45 = llvm.mul %33, %3 : i64
          %46 = llvm.udiv %45, %4 : i64
          %47 = llvm.getelementptr %44[%46] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%47, %1 : !llvm.ptr, i64)] : i1
          %48 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %49 = llvm.extractvalue %48[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %50 = llvm.getelementptr %49[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %51 = llvm.load %50 : !llvm.ptr -> !llvm.ptr
          %52 = llvm.mul %34, %3 : i64
          %53 = llvm.udiv %52, %4 : i64
          %54 = llvm.getelementptr %51[%53] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%54, %0 : !llvm.ptr, i64)] : i1
          %55 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %56 = llvm.extractvalue %55[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %57 = llvm.getelementptr %56[3] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %58 = llvm.load %57 : !llvm.ptr -> !llvm.ptr
          %59 = llvm.mul %35, %3 : i64
          %60 = llvm.udiv %59, %4 : i64
          %61 = llvm.getelementptr %58[%60] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%61, %1 : !llvm.ptr, i64)] : i1
          %62 = llvm.load %40 : !llvm.ptr -> f32
          %63 = llvm.getelementptr inbounds|nuw %40[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %64 = llvm.load %63 : !llvm.ptr -> f32
          %65 = llvm.fadd %62, %64 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %66 = llvm.fmul %65, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %67 = llvm.intr.floor(%66) : (f32) -> f32
          %68 = llvm.fmul %67, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %69 = llvm.fsub %65, %68 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %70 = llvm.fptosi %67 : f32 to i32
          %71 = llvm.and %70, %8 : i32
          %72 = llvm.icmp "eq" %71, %7 : i32
          %73 = llvm.icmp "eq" %71, %6 : i32
          %74 = llvm.icmp "eq" %71, %5 : i32
          %75 = llvm.or %72, %74 : i1
          %76 = llvm.or %73, %74 : i1
          %77 = llvm.fmul %69, %69 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %78 = llvm.select %75, %20, %69 : i1, f32
          %79 = llvm.select %75, %13, %18 : i1, f32
          %80 = llvm.select %75, %12, %17 : i1, f32
          %81 = llvm.select %75, %11, %16 : i1, f32
          %82 = llvm.select %75, %10, %15 : i1, f32
          %83 = llvm.select %75, %9, %14 : i1, f32
          %84 = llvm.intr.fma(%77, %83, %82) : (f32, f32, f32) -> f32
          %85 = llvm.intr.fma(%77, %84, %81) : (f32, f32, f32) -> f32
          %86 = llvm.intr.fma(%77, %85, %80) : (f32, f32, f32) -> f32
          %87 = llvm.intr.fma(%77, %86, %79) : (f32, f32, f32) -> f32
          %88 = llvm.intr.fma(%77, %87, %20) : (f32, f32, f32) -> f32
          %89 = llvm.fmul %78, %88 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %90 = llvm.fmul %89, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %91 = llvm.select %76, %90, %89 : i1, f32
          %92 = llvm.fmul %62, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %93 = llvm.intr.floor(%92) : (f32) -> f32
          %94 = llvm.fmul %93, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %95 = llvm.fsub %62, %94 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %96 = llvm.fptosi %93 : f32 to i32
          %97 = llvm.and %96, %8 : i32
          %98 = llvm.icmp "eq" %97, %7 : i32
          %99 = llvm.icmp "eq" %97, %6 : i32
          %100 = llvm.icmp "eq" %97, %5 : i32
          %101 = llvm.or %98, %100 : i1
          %102 = llvm.or %99, %100 : i1
          %103 = llvm.fmul %95, %95 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %104 = llvm.select %101, %20, %95 : i1, f32
          %105 = llvm.select %101, %13, %18 : i1, f32
          %106 = llvm.select %101, %12, %17 : i1, f32
          %107 = llvm.select %101, %11, %16 : i1, f32
          %108 = llvm.select %101, %10, %15 : i1, f32
          %109 = llvm.select %101, %9, %14 : i1, f32
          %110 = llvm.intr.fma(%103, %109, %108) : (f32, f32, f32) -> f32
          %111 = llvm.intr.fma(%103, %110, %107) : (f32, f32, f32) -> f32
          %112 = llvm.intr.fma(%103, %111, %106) : (f32, f32, f32) -> f32
          %113 = llvm.intr.fma(%103, %112, %105) : (f32, f32, f32) -> f32
          %114 = llvm.intr.fma(%103, %113, %20) : (f32, f32, f32) -> f32
          %115 = llvm.fmul %104, %114 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %116 = llvm.fmul %115, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %117 = llvm.select %102, %116, %115 : i1, f32
          %118 = llvm.fadd %117, %91 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %118, %61 : f32, !llvm.ptr
          %119 = llvm.load %40 : !llvm.ptr -> f32
          %120 = llvm.load %63 : !llvm.ptr -> f32
          %121 = llvm.fadd %119, %120 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %122 = llvm.fmul %121, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %123 = llvm.intr.floor(%122) : (f32) -> f32
          %124 = llvm.fmul %123, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %125 = llvm.fsub %121, %124 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %126 = llvm.fptosi %123 : f32 to i32
          %127 = llvm.and %126, %8 : i32
          %128 = llvm.icmp "eq" %127, %7 : i32
          %129 = llvm.icmp "eq" %127, %6 : i32
          %130 = llvm.icmp "eq" %127, %5 : i32
          %131 = llvm.or %128, %130 : i1
          %132 = llvm.or %129, %130 : i1
          %133 = llvm.fmul %125, %125 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %134 = llvm.select %131, %20, %125 : i1, f32
          %135 = llvm.select %131, %13, %18 : i1, f32
          %136 = llvm.select %131, %12, %17 : i1, f32
          %137 = llvm.select %131, %11, %16 : i1, f32
          %138 = llvm.select %131, %10, %15 : i1, f32
          %139 = llvm.select %131, %9, %14 : i1, f32
          %140 = llvm.intr.fma(%133, %139, %138) : (f32, f32, f32) -> f32
          %141 = llvm.intr.fma(%133, %140, %137) : (f32, f32, f32) -> f32
          %142 = llvm.intr.fma(%133, %141, %136) : (f32, f32, f32) -> f32
          %143 = llvm.intr.fma(%133, %142, %135) : (f32, f32, f32) -> f32
          %144 = llvm.intr.fma(%133, %143, %20) : (f32, f32, f32) -> f32
          %145 = llvm.fmul %134, %144 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %146 = llvm.fmul %145, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %147 = llvm.select %132, %146, %145 : i1, f32
          llvm.store %147, %54 : f32, !llvm.ptr
          %148 = llvm.load %40 : !llvm.ptr -> f32
          %149 = llvm.load %63 : !llvm.ptr -> f32
          %150 = llvm.fadd %148, %149 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %151 = llvm.fmul %150, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %152 = llvm.intr.floor(%151) : (f32) -> f32
          %153 = llvm.fmul %152, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %154 = llvm.fsub %150, %153 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %155 = llvm.fptosi %152 : f32 to i32
          %156 = llvm.and %155, %8 : i32
          %157 = llvm.icmp "eq" %156, %6 : i32
          %158 = llvm.icmp "eq" %156, %8 : i32
          %159 = llvm.or %157, %158 : i1
          %160 = llvm.icmp "sgt" %156, %6 : i32
          %161 = llvm.fmul %154, %154 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %162 = llvm.select %159, %20, %154 : i1, f32
          %163 = llvm.select %159, %13, %18 : i1, f32
          %164 = llvm.select %159, %12, %17 : i1, f32
          %165 = llvm.select %159, %11, %16 : i1, f32
          %166 = llvm.select %159, %10, %15 : i1, f32
          %167 = llvm.select %159, %9, %14 : i1, f32
          %168 = llvm.intr.fma(%161, %167, %166) : (f32, f32, f32) -> f32
          %169 = llvm.intr.fma(%161, %168, %165) : (f32, f32, f32) -> f32
          %170 = llvm.intr.fma(%161, %169, %164) : (f32, f32, f32) -> f32
          %171 = llvm.intr.fma(%161, %170, %163) : (f32, f32, f32) -> f32
          %172 = llvm.intr.fma(%161, %171, %20) : (f32, f32, f32) -> f32
          %173 = llvm.fmul %162, %172 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %174 = llvm.fmul %173, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %175 = llvm.select %160, %174, %173 : i1, f32
          %176 = llvm.fmul %148, %22 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %177 = llvm.intr.floor(%176) : (f32) -> f32
          %178 = llvm.fmul %177, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %179 = llvm.fsub %148, %178 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %180 = llvm.fptosi %177 : f32 to i32
          %181 = llvm.and %180, %8 : i32
          %182 = llvm.icmp "eq" %181, %6 : i32
          %183 = llvm.icmp "eq" %181, %8 : i32
          %184 = llvm.or %182, %183 : i1
          %185 = llvm.icmp "sgt" %181, %6 : i32
          %186 = llvm.fmul %179, %179 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %187 = llvm.select %184, %20, %179 : i1, f32
          %188 = llvm.select %184, %13, %18 : i1, f32
          %189 = llvm.select %184, %12, %17 : i1, f32
          %190 = llvm.select %184, %11, %16 : i1, f32
          %191 = llvm.select %184, %10, %15 : i1, f32
          %192 = llvm.select %184, %9, %14 : i1, f32
          %193 = llvm.intr.fma(%186, %192, %191) : (f32, f32, f32) -> f32
          %194 = llvm.intr.fma(%186, %193, %190) : (f32, f32, f32) -> f32
          %195 = llvm.intr.fma(%186, %194, %189) : (f32, f32, f32) -> f32
          %196 = llvm.intr.fma(%186, %195, %188) : (f32, f32, f32) -> f32
          %197 = llvm.intr.fma(%186, %196, %20) : (f32, f32, f32) -> f32
          %198 = llvm.fmul %187, %197 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %199 = llvm.fmul %198, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %200 = llvm.select %185, %199, %198 : i1, f32
          %201 = llvm.fadd %200, %175 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %201, %47 : f32, !llvm.ptr
          llvm.return %7 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_6 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_6_unpack_elementwise_1x2_f32 ordinal(0) layout(#pipeline_layout4) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.mlir.global private constant @__constant_1x2xf32(dense<[[-0.0322122052, -0.0469594523]]> : tensor<1x2xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<1 x array<2 x f32>>
        llvm.func @main_graph$async_dispatch_6_unpack_elementwise_1x2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(64 : index) : i64
          %2 = llvm.mlir.constant(true) : i1
          %3 = llvm.mlir.constant(8 : index) : i64
          %4 = llvm.mlir.constant(8 : i64) : i64
          %5 = llvm.mlir.constant(32 : i64) : i64
          %6 = llvm.mlir.addressof @__constant_1x2xf32 : !llvm.ptr
          %7 = llvm.mlir.constant(dense<[true, true, false, false, false, false, false, false]> : vector<8xi1>) : vector<8xi1>
          %8 = llvm.mlir.constant(192 : index) : i64
          %9 = llvm.mlir.constant(128 : index) : i64
          %10 = llvm.mlir.constant(0 : index) : i64
          %11 = llvm.mlir.constant(1152 : index) : i64
          %12 = llvm.mlir.constant(2 : index) : i64
          %13 = llvm.getelementptr %6[0, 0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<1 x array<2 x f32>>
          %14 = llvm.alloca %12 x f32 {alignment = 64 : i64} : (i64) -> !llvm.ptr
          %15 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %16 = llvm.extractvalue %15[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %17 = llvm.load %16 : !llvm.ptr -> !llvm.ptr
          %18 = llvm.mul %11, %4 : i64
          %19 = llvm.udiv %18, %5 : i64
          %20 = llvm.getelementptr %17[%19] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%20, %1 : !llvm.ptr, i64)] : i1
          %21 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %22 = llvm.extractvalue %21[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %23 = llvm.load %22 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %2 ["align"(%23, %1 : !llvm.ptr, i64)] : i1
          %24 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %25 = llvm.extractvalue %24[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %26 = llvm.getelementptr %25[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %27 = llvm.load %26 : !llvm.ptr -> !llvm.ptr
          %28 = llvm.mul %9, %4 : i64
          %29 = llvm.udiv %28, %5 : i64
          %30 = llvm.getelementptr %27[%29] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%30, %1 : !llvm.ptr, i64)] : i1
          %31 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %32 = llvm.extractvalue %31[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %33 = llvm.getelementptr %32[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %34 = llvm.load %33 : !llvm.ptr -> !llvm.ptr
          %35 = llvm.mul %8, %4 : i64
          %36 = llvm.udiv %35, %5 : i64
          %37 = llvm.getelementptr %34[%36] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%37, %1 : !llvm.ptr, i64)] : i1
          %38 = llvm.mul %10, %3 : i64
          %39 = llvm.add %38, %38 : i64
          %40 = llvm.add %39, %38 : i64
          %41 = llvm.add %40, %10 : i64
          %42 = llvm.getelementptr %20[%41] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %43 = llvm.load %42 {alignment = 4 : i64} : !llvm.ptr -> vector<8xf32>
          %44 = llvm.mul %10, %12 : i64
          %45 = llvm.add %44, %10 : i64
          %46 = llvm.getelementptr %14[%45] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.masked.store %43, %46, %7 {alignment = 4 : i32} : vector<8xf32>, vector<8xi1> into !llvm.ptr
          %47 = llvm.load %46 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %48 = llvm.getelementptr %13[%45] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %49 = llvm.load %48 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %50 = llvm.getelementptr %23[%45] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %51 = llvm.load %50 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %52 = llvm.fadd %47, %49 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %53 = llvm.fsub %52, %51 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %54 = llvm.getelementptr %30[%45] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %52, %54 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          %55 = llvm.getelementptr %37[%45] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %53, %55 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_7 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_7_elementwise_broadcast ordinal(0) layout(#pipeline_layout5) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        hal.return %c1, %c1, %c1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_7_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(4 : index) : i64
          %2 = llvm.mlir.constant(64 : index) : i64
          %3 = llvm.mlir.constant(true) : i1
          %4 = llvm.mlir.constant(8 : i64) : i64
          %5 = llvm.mlir.constant(32 : i64) : i64
          %6 = llvm.mlir.constant(1 : i32) : i32
          %7 = llvm.mlir.constant(3 : i32) : i32
          %8 = llvm.mlir.constant(-2.59630184E-7 : f32) : f32
          %9 = llvm.mlir.constant(2.47562348E-5 : f32) : f32
          %10 = llvm.mlir.constant(-0.00138883304 : f32) : f32
          %11 = llvm.mlir.constant(0.0416666418 : f32) : f32
          %12 = llvm.mlir.constant(-5.000000e-01 : f32) : f32
          %13 = llvm.mlir.constant(-2.50293279E-8 : f32) : f32
          %14 = llvm.mlir.constant(2.76001265E-6 : f32) : f32
          %15 = llvm.mlir.constant(-1.98426045E-4 : f32) : f32
          %16 = llvm.mlir.constant(0.00833334774 : f32) : f32
          %17 = llvm.mlir.constant(-0.166666672 : f32) : f32
          %18 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %19 = llvm.mlir.constant(1.57079637 : f32) : f32
          %20 = llvm.mlir.constant(0.636619746 : f32) : f32
          %21 = llvm.mlir.constant(-1.000000e+00 : f32) : f32
          %22 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %23 = llvm.extractvalue %22[9] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %24 = llvm.load %23 : !llvm.ptr -> i32
          %25 = llvm.getelementptr %23[1] : (!llvm.ptr) -> !llvm.ptr, i32
          %26 = llvm.load %25 : !llvm.ptr -> i32
          %27 = llvm.getelementptr %23[2] : (!llvm.ptr) -> !llvm.ptr, i32
          %28 = llvm.load %27 : !llvm.ptr -> i32
          %29 = llvm.zext %24 : i32 to i64
          %30 = llvm.zext %26 : i32 to i64
          %31 = llvm.zext %28 : i32 to i64
          %32 = llvm.extractvalue %22[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %33 = llvm.load %32 : !llvm.ptr -> !llvm.ptr
          %34 = llvm.mul %29, %4 : i64
          %35 = llvm.udiv %34, %5 : i64
          %36 = llvm.getelementptr %33[%35] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%36, %2 : !llvm.ptr, i64)] : i1
          %37 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %38 = llvm.extractvalue %37[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %39 = llvm.getelementptr %38[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %40 = llvm.load %39 : !llvm.ptr -> !llvm.ptr
          %41 = llvm.mul %30, %4 : i64
          %42 = llvm.udiv %41, %5 : i64
          %43 = llvm.getelementptr %40[%42] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%43, %1 : !llvm.ptr, i64)] : i1
          %44 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %45 = llvm.extractvalue %44[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %46 = llvm.getelementptr %45[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %47 = llvm.load %46 : !llvm.ptr -> !llvm.ptr
          %48 = llvm.mul %31, %4 : i64
          %49 = llvm.udiv %48, %5 : i64
          %50 = llvm.getelementptr %47[%49] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%50, %2 : !llvm.ptr, i64)] : i1
          %51 = llvm.load %36 : !llvm.ptr -> f32
          %52 = llvm.getelementptr inbounds|nuw %36[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %53 = llvm.load %52 : !llvm.ptr -> f32
          %54 = llvm.fadd %51, %53 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %55 = llvm.fmul %54, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %56 = llvm.intr.floor(%55) : (f32) -> f32
          %57 = llvm.fmul %56, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %58 = llvm.fsub %54, %57 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %59 = llvm.fptosi %56 : f32 to i32
          %60 = llvm.and %59, %7 : i32
          %61 = llvm.icmp "eq" %60, %6 : i32
          %62 = llvm.icmp "eq" %60, %7 : i32
          %63 = llvm.or %61, %62 : i1
          %64 = llvm.icmp "sgt" %60, %6 : i32
          %65 = llvm.fmul %58, %58 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %66 = llvm.select %63, %18, %58 : i1, f32
          %67 = llvm.select %63, %12, %17 : i1, f32
          %68 = llvm.select %63, %11, %16 : i1, f32
          %69 = llvm.select %63, %10, %15 : i1, f32
          %70 = llvm.select %63, %9, %14 : i1, f32
          %71 = llvm.select %63, %8, %13 : i1, f32
          %72 = llvm.intr.fma(%65, %71, %70) : (f32, f32, f32) -> f32
          %73 = llvm.intr.fma(%65, %72, %69) : (f32, f32, f32) -> f32
          %74 = llvm.intr.fma(%65, %73, %68) : (f32, f32, f32) -> f32
          %75 = llvm.intr.fma(%65, %74, %67) : (f32, f32, f32) -> f32
          %76 = llvm.intr.fma(%65, %75, %18) : (f32, f32, f32) -> f32
          %77 = llvm.fmul %66, %76 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %78 = llvm.fmul %77, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %79 = llvm.select %64, %78, %77 : i1, f32
          %80 = llvm.fmul %51, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %81 = llvm.intr.floor(%80) : (f32) -> f32
          %82 = llvm.fmul %81, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %83 = llvm.fsub %51, %82 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %84 = llvm.fptosi %81 : f32 to i32
          %85 = llvm.and %84, %7 : i32
          %86 = llvm.icmp "eq" %85, %6 : i32
          %87 = llvm.icmp "eq" %85, %7 : i32
          %88 = llvm.or %86, %87 : i1
          %89 = llvm.icmp "sgt" %85, %6 : i32
          %90 = llvm.fmul %83, %83 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %91 = llvm.select %88, %18, %83 : i1, f32
          %92 = llvm.select %88, %12, %17 : i1, f32
          %93 = llvm.select %88, %11, %16 : i1, f32
          %94 = llvm.select %88, %10, %15 : i1, f32
          %95 = llvm.select %88, %9, %14 : i1, f32
          %96 = llvm.select %88, %8, %13 : i1, f32
          %97 = llvm.intr.fma(%90, %96, %95) : (f32, f32, f32) -> f32
          %98 = llvm.intr.fma(%90, %97, %94) : (f32, f32, f32) -> f32
          %99 = llvm.intr.fma(%90, %98, %93) : (f32, f32, f32) -> f32
          %100 = llvm.intr.fma(%90, %99, %92) : (f32, f32, f32) -> f32
          %101 = llvm.intr.fma(%90, %100, %18) : (f32, f32, f32) -> f32
          %102 = llvm.fmul %91, %101 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %103 = llvm.fmul %102, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %104 = llvm.select %89, %103, %102 : i1, f32
          %105 = llvm.fmul %104, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %106 = llvm.fsub %105, %79 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %106, %50 : f32, !llvm.ptr
          %107 = llvm.load %36 : !llvm.ptr -> f32
          %108 = llvm.load %52 : !llvm.ptr -> f32
          %109 = llvm.fadd %107, %108 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %110 = llvm.fmul %109, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %111 = llvm.intr.floor(%110) : (f32) -> f32
          %112 = llvm.fmul %111, %19 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %113 = llvm.fsub %109, %112 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %114 = llvm.fptosi %111 : f32 to i32
          %115 = llvm.and %114, %7 : i32
          %116 = llvm.icmp "eq" %115, %6 : i32
          %117 = llvm.icmp "eq" %115, %7 : i32
          %118 = llvm.or %116, %117 : i1
          %119 = llvm.icmp "sgt" %115, %6 : i32
          %120 = llvm.fmul %113, %113 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %121 = llvm.select %118, %18, %113 : i1, f32
          %122 = llvm.select %118, %12, %17 : i1, f32
          %123 = llvm.select %118, %11, %16 : i1, f32
          %124 = llvm.select %118, %10, %15 : i1, f32
          %125 = llvm.select %118, %9, %14 : i1, f32
          %126 = llvm.select %118, %8, %13 : i1, f32
          %127 = llvm.intr.fma(%120, %126, %125) : (f32, f32, f32) -> f32
          %128 = llvm.intr.fma(%120, %127, %124) : (f32, f32, f32) -> f32
          %129 = llvm.intr.fma(%120, %128, %123) : (f32, f32, f32) -> f32
          %130 = llvm.intr.fma(%120, %129, %122) : (f32, f32, f32) -> f32
          %131 = llvm.intr.fma(%120, %130, %18) : (f32, f32, f32) -> f32
          %132 = llvm.fmul %121, %131 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %133 = llvm.fmul %132, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %134 = llvm.select %119, %133, %132 : i1, f32
          %135 = llvm.fmul %134, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %135, %43 : f32, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_8 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_8_elementwise_broadcast_2_f32 ordinal(0) layout(#pipeline_layout6) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_8_elementwise_broadcast_2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(0 : i64) : i64
          %2 = llvm.mlir.constant(dense<[0, 1]> : vector<2xindex>) : vector<2xi64>
          %3 = llvm.mlir.constant(64 : index) : i64
          %4 = llvm.mlir.constant(true) : i1
          %5 = llvm.mlir.constant(2 : index) : i64
          %6 = llvm.mlir.constant(8 : i64) : i64
          %7 = llvm.mlir.constant(32 : i64) : i64
          %8 = llvm.mlir.constant(0 : index) : i64
          %9 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %10 = llvm.extractvalue %9[9] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %11 = llvm.load %10 : !llvm.ptr -> i32
          %12 = llvm.getelementptr %10[1] : (!llvm.ptr) -> !llvm.ptr, i32
          %13 = llvm.load %12 : !llvm.ptr -> i32
          %14 = llvm.zext %11 : i32 to i64
          %15 = llvm.zext %13 : i32 to i64
          %16 = llvm.extractvalue %9[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %17 = llvm.load %16 : !llvm.ptr -> !llvm.ptr
          %18 = llvm.mul %14, %6 : i64
          %19 = llvm.udiv %18, %7 : i64
          %20 = llvm.getelementptr %17[%19] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%20, %3 : !llvm.ptr, i64)] : i1
          %21 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %22 = llvm.extractvalue %21[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %23 = llvm.getelementptr %22[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %24 = llvm.load %23 : !llvm.ptr -> !llvm.ptr
          %25 = llvm.mul %15, %6 : i64
          %26 = llvm.udiv %25, %7 : i64
          %27 = llvm.getelementptr %24[%26] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%27, %3 : !llvm.ptr, i64)] : i1
          %28 = llvm.extractelement %2[%1 : i64] : vector<2xi64>
          %29 = llvm.mul %8, %5 : i64
          %30 = llvm.add %29, %28 : i64
          %31 = llvm.getelementptr %20[%30] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %32 = llvm.load %31 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          llvm.store %32, %27 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_9 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_9_elementwise_broadcast ordinal(0) layout(#pipeline_layout6) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        hal.return %c1, %c1, %c1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_9_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(4 : index) : i64
          %2 = llvm.mlir.constant(64 : index) : i64
          %3 = llvm.mlir.constant(true) : i1
          %4 = llvm.mlir.constant(8 : i64) : i64
          %5 = llvm.mlir.constant(32 : i64) : i64
          %6 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %7 = llvm.extractvalue %6[9] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %8 = llvm.load %7 : !llvm.ptr -> i32
          %9 = llvm.getelementptr %7[1] : (!llvm.ptr) -> !llvm.ptr, i32
          %10 = llvm.load %9 : !llvm.ptr -> i32
          %11 = llvm.zext %8 : i32 to i64
          %12 = llvm.zext %10 : i32 to i64
          %13 = llvm.extractvalue %6[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %14 = llvm.load %13 : !llvm.ptr -> !llvm.ptr
          %15 = llvm.mul %11, %4 : i64
          %16 = llvm.udiv %15, %5 : i64
          %17 = llvm.getelementptr %14[%16] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%17, %2 : !llvm.ptr, i64)] : i1
          %18 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %19 = llvm.extractvalue %18[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %20 = llvm.getelementptr %19[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %21 = llvm.load %20 : !llvm.ptr -> !llvm.ptr
          %22 = llvm.mul %12, %4 : i64
          %23 = llvm.udiv %22, %5 : i64
          %24 = llvm.getelementptr %21[%23] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%24, %1 : !llvm.ptr, i64)] : i1
          %25 = llvm.load %17 : !llvm.ptr -> f32
          llvm.store %25, %24 : f32, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_10 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_10_elementwise_broadcast_2_f32 ordinal(0) layout(#pipeline_layout6) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_10_elementwise_broadcast_2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(0 : i64) : i64
          %2 = llvm.mlir.constant(dense<[0, 1]> : vector<2xindex>) : vector<2xi64>
          %3 = llvm.mlir.constant(64 : index) : i64
          %4 = llvm.mlir.constant(true) : i1
          %5 = llvm.mlir.constant(2 : index) : i64
          %6 = llvm.mlir.constant(8 : i64) : i64
          %7 = llvm.mlir.constant(32 : i64) : i64
          %8 = llvm.mlir.constant(1 : index) : i64
          %9 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %10 = llvm.extractvalue %9[9] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %11 = llvm.load %10 : !llvm.ptr -> i32
          %12 = llvm.getelementptr %10[1] : (!llvm.ptr) -> !llvm.ptr, i32
          %13 = llvm.load %12 : !llvm.ptr -> i32
          %14 = llvm.zext %11 : i32 to i64
          %15 = llvm.zext %13 : i32 to i64
          %16 = llvm.extractvalue %9[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %17 = llvm.load %16 : !llvm.ptr -> !llvm.ptr
          %18 = llvm.mul %14, %6 : i64
          %19 = llvm.udiv %18, %7 : i64
          %20 = llvm.getelementptr %17[%19] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%20, %3 : !llvm.ptr, i64)] : i1
          %21 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %22 = llvm.extractvalue %21[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %23 = llvm.getelementptr %22[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %24 = llvm.load %23 : !llvm.ptr -> !llvm.ptr
          %25 = llvm.mul %15, %6 : i64
          %26 = llvm.udiv %25, %7 : i64
          %27 = llvm.getelementptr %24[%26] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%27, %3 : !llvm.ptr, i64)] : i1
          %28 = llvm.extractelement %2[%1 : i64] : vector<2xi64>
          %29 = llvm.mul %8, %5 : i64
          %30 = llvm.add %29, %28 : i64
          %31 = llvm.getelementptr %20[%30] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %32 = llvm.load %31 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          llvm.store %32, %27 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_11 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_11_elementwise_broadcast ordinal(0) layout(#pipeline_layout6) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        hal.return %c1, %c1, %c1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_11_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(64 : index) : i64
          %2 = llvm.mlir.constant(true) : i1
          %3 = llvm.mlir.constant(8 : i64) : i64
          %4 = llvm.mlir.constant(32 : i64) : i64
          %5 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %6 = llvm.extractvalue %5[9] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %7 = llvm.load %6 : !llvm.ptr -> i32
          %8 = llvm.getelementptr %6[1] : (!llvm.ptr) -> !llvm.ptr, i32
          %9 = llvm.load %8 : !llvm.ptr -> i32
          %10 = llvm.zext %7 : i32 to i64
          %11 = llvm.zext %9 : i32 to i64
          %12 = llvm.extractvalue %5[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %13 = llvm.load %12 : !llvm.ptr -> !llvm.ptr
          %14 = llvm.mul %10, %3 : i64
          %15 = llvm.udiv %14, %4 : i64
          %16 = llvm.getelementptr %13[%15] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%16, %1 : !llvm.ptr, i64)] : i1
          %17 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %18 = llvm.extractvalue %17[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %19 = llvm.getelementptr %18[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %20 = llvm.load %19 : !llvm.ptr -> !llvm.ptr
          %21 = llvm.mul %11, %3 : i64
          %22 = llvm.udiv %21, %4 : i64
          %23 = llvm.getelementptr %20[%22] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%23, %1 : !llvm.ptr, i64)] : i1
          %24 = llvm.getelementptr inbounds|nuw %16[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %25 = llvm.load %24 : !llvm.ptr -> f32
          llvm.store %25, %23 : f32, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_12 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_12_elementwise_broadcast ordinal(0) layout(#pipeline_layout7) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        hal.return %c1, %c1, %c1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_12_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(4 : index) : i64
          %2 = llvm.mlir.constant(64 : index) : i64
          %3 = llvm.mlir.constant(true) : i1
          %4 = llvm.mlir.constant(8 : i64) : i64
          %5 = llvm.mlir.constant(32 : i64) : i64
          %6 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %7 = llvm.extractvalue %6[9] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %8 = llvm.load %7 : !llvm.ptr -> i32
          %9 = llvm.getelementptr %7[2] : (!llvm.ptr) -> !llvm.ptr, i32
          %10 = llvm.load %9 : !llvm.ptr -> i32
          %11 = llvm.zext %8 : i32 to i64
          %12 = llvm.zext %10 : i32 to i64
          %13 = llvm.extractvalue %6[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %14 = llvm.load %13 : !llvm.ptr -> !llvm.ptr
          %15 = llvm.mul %11, %4 : i64
          %16 = llvm.udiv %15, %5 : i64
          %17 = llvm.getelementptr %14[%16] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%17, %2 : !llvm.ptr, i64)] : i1
          %18 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %19 = llvm.extractvalue %18[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %20 = llvm.getelementptr %19[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %21 = llvm.load %20 : !llvm.ptr -> !llvm.ptr
          %22 = llvm.mul %12, %4 : i64
          %23 = llvm.udiv %22, %5 : i64
          %24 = llvm.getelementptr %21[%23] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%24, %1 : !llvm.ptr, i64)] : i1
          %25 = llvm.getelementptr inbounds|nuw %17[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %26 = llvm.load %25 : !llvm.ptr -> f32
          %27 = llvm.fneg %26 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %27, %24 : f32, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_13 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_13_elementwise_broadcast ordinal(0) layout(#pipeline_layout6) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        hal.return %c1, %c1, %c1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_13_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(64 : index) : i64
          %2 = llvm.mlir.constant(true) : i1
          %3 = llvm.mlir.constant(8 : i64) : i64
          %4 = llvm.mlir.constant(32 : i64) : i64
          %5 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %6 = llvm.extractvalue %5[9] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %7 = llvm.load %6 : !llvm.ptr -> i32
          %8 = llvm.getelementptr %6[1] : (!llvm.ptr) -> !llvm.ptr, i32
          %9 = llvm.load %8 : !llvm.ptr -> i32
          %10 = llvm.zext %7 : i32 to i64
          %11 = llvm.zext %9 : i32 to i64
          %12 = llvm.extractvalue %5[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %13 = llvm.load %12 : !llvm.ptr -> !llvm.ptr
          %14 = llvm.mul %10, %3 : i64
          %15 = llvm.udiv %14, %4 : i64
          %16 = llvm.getelementptr %13[%15] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%16, %1 : !llvm.ptr, i64)] : i1
          %17 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %18 = llvm.extractvalue %17[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %19 = llvm.getelementptr %18[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %20 = llvm.load %19 : !llvm.ptr -> !llvm.ptr
          %21 = llvm.mul %11, %3 : i64
          %22 = llvm.udiv %21, %4 : i64
          %23 = llvm.getelementptr %20[%22] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%23, %1 : !llvm.ptr, i64)] : i1
          %24 = llvm.load %16 : !llvm.ptr -> f32
          %25 = llvm.fneg %24 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %25, %23 : f32, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_14 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_14_elementwise_2x2_f32_pack ordinal(0) layout(#pipeline_layout8) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_14_elementwise_2x2_f32_pack(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(1 : i64) : i64
          %2 = llvm.mlir.constant(0 : i64) : i64
          %3 = llvm.mlir.constant(16 : index) : i64
          %4 = llvm.mlir.constant(64 : index) : i64
          %5 = llvm.mlir.constant(true) : i1
          %6 = llvm.mlir.constant(8 : i64) : i64
          %7 = llvm.mlir.constant(32 : i64) : i64
          %8 = llvm.mlir.constant(8 : index) : i64
          %9 = llvm.mlir.poison : vector<2xf32>
          %10 = llvm.mlir.constant(0 : index) : i64
          %11 = llvm.mlir.constant(0.000000e+00 : f32) : f32
          %12 = llvm.mlir.constant(1 : index) : i64
          %13 = llvm.mlir.constant(2 : index) : i64
          %14 = llvm.mlir.constant(dense<9.99999997E-7> : vector<f32>) : vector<1xf32>
          %15 = llvm.mlir.constant(dense<1.000000e+00> : vector<f32>) : vector<1xf32>
          %16 = llvm.alloca %13 x f32 {alignment = 64 : i64} : (i64) -> !llvm.ptr
          %17 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %18 = llvm.extractvalue %17[9] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %19 = llvm.load %18 : !llvm.ptr -> i32
          %20 = llvm.getelementptr %18[1] : (!llvm.ptr) -> !llvm.ptr, i32
          %21 = llvm.load %20 : !llvm.ptr -> i32
          %22 = llvm.getelementptr %18[2] : (!llvm.ptr) -> !llvm.ptr, i32
          %23 = llvm.load %22 : !llvm.ptr -> i32
          %24 = llvm.getelementptr %18[3] : (!llvm.ptr) -> !llvm.ptr, i32
          %25 = llvm.load %24 : !llvm.ptr -> i32
          %26 = llvm.zext %19 : i32 to i64
          %27 = llvm.zext %21 : i32 to i64
          %28 = llvm.zext %23 : i32 to i64
          %29 = llvm.zext %25 : i32 to i64
          %30 = llvm.extractvalue %17[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %31 = llvm.load %30 : !llvm.ptr -> !llvm.ptr
          %32 = llvm.mul %26, %6 : i64
          %33 = llvm.udiv %32, %7 : i64
          %34 = llvm.getelementptr %31[%33] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %5 ["align"(%34, %4 : !llvm.ptr, i64)] : i1
          %35 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %36 = llvm.extractvalue %35[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %37 = llvm.load %36 : !llvm.ptr -> !llvm.ptr
          %38 = llvm.mul %27, %6 : i64
          %39 = llvm.udiv %38, %7 : i64
          %40 = llvm.getelementptr %37[%39] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %5 ["align"(%40, %4 : !llvm.ptr, i64)] : i1
          %41 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %42 = llvm.extractvalue %41[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %43 = llvm.load %42 : !llvm.ptr -> !llvm.ptr
          %44 = llvm.mul %28, %6 : i64
          %45 = llvm.udiv %44, %7 : i64
          %46 = llvm.getelementptr %43[%45] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %5 ["align"(%46, %4 : !llvm.ptr, i64)] : i1
          %47 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %48 = llvm.extractvalue %47[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %49 = llvm.getelementptr %48[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %50 = llvm.load %49 : !llvm.ptr -> !llvm.ptr
          %51 = llvm.mul %29, %6 : i64
          %52 = llvm.udiv %51, %7 : i64
          %53 = llvm.getelementptr %50[%52] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %5 ["align"(%53, %4 : !llvm.ptr, i64)] : i1
          %54 = llvm.alloca %8 x f32 {alignment = 32 : i64} : (i64) -> !llvm.ptr
          %55 = llvm.load %34 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %56 = llvm.getelementptr %40[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %57 = llvm.load %56 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %58 = llvm.getelementptr %34[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %59 = llvm.load %58 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %60 = llvm.load %40 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %61 = llvm.fmul %59, %60 {fastmathFlags = #llvm.fastmath<contract>} : vector<1xf32>
          %62 = llvm.fmul %55, %57 {fastmathFlags = #llvm.fastmath<contract>} : vector<1xf32>
          %63 = llvm.fsub %62, %61 {fastmathFlags = #llvm.fastmath<contract>} : vector<1xf32>
          %64 = llvm.fadd %63, %14 {fastmathFlags = #llvm.fastmath<contract>} : vector<1xf32>
          %65 = llvm.fdiv %15, %64 : vector<1xf32>
          llvm.br ^bb1(%10 : i64)
        ^bb1(%66: i64):  // 2 preds: ^bb0, ^bb7
          %67 = llvm.icmp "slt" %66, %13 : i64
          llvm.cond_br %67, ^bb2, ^bb8
        ^bb2:  // pred: ^bb1
          %68 = llvm.mul %10, %13 : i64
          %69 = llvm.add %68, %66 : i64
          %70 = llvm.getelementptr %46[%69] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %71 = llvm.load %70 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %72 = llvm.mul %12, %13 : i64
          %73 = llvm.add %72, %66 : i64
          %74 = llvm.getelementptr %46[%73] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %75 = llvm.load %74 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %76 = llvm.extractelement %71[%2 : i64] : vector<1xf32>
          %77 = llvm.insertelement %76, %9[%2 : i64] : vector<2xf32>
          %78 = llvm.extractelement %75[%2 : i64] : vector<1xf32>
          %79 = llvm.insertelement %78, %77[%1 : i64] : vector<2xf32>
          %80 = llvm.extractelement %65[%2 : i64] : vector<1xf32>
          %81 = llvm.insertelement %80, %9[%0 : i32] : vector<2xf32>
          %82 = llvm.shufflevector %81, %9 [0, 0] : vector<2xf32> 
          %83 = llvm.fmul %79, %82 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %84 = llvm.add %10, %10 : i64
          %85 = llvm.getelementptr %16[%84] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %83, %85 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.br ^bb3(%10 : i64)
        ^bb3(%86: i64):  // 2 preds: ^bb2, ^bb4
          %87 = llvm.icmp "slt" %86, %8 : i64
          llvm.cond_br %87, ^bb4, ^bb5(%10 : i64)
        ^bb4:  // pred: ^bb3
          %88 = llvm.getelementptr inbounds|nuw %54[%86] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %11, %88 : f32, !llvm.ptr
          %89 = llvm.add %86, %12 : i64
          llvm.br ^bb3(%89 : i64)
        ^bb5(%90: i64):  // 2 preds: ^bb3, ^bb6
          %91 = llvm.icmp "slt" %90, %13 : i64
          llvm.cond_br %91, ^bb6, ^bb7
        ^bb6:  // pred: ^bb5
          %92 = llvm.add %90, %10 overflow<nsw, nuw> : i64
          %93 = llvm.getelementptr inbounds|nuw %16[%92] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %94 = llvm.load %93 : !llvm.ptr -> f32
          %95 = llvm.getelementptr inbounds|nuw %54[%90] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %94, %95 : f32, !llvm.ptr
          %96 = llvm.add %90, %12 : i64
          llvm.br ^bb5(%96 : i64)
        ^bb7:  // pred: ^bb5
          %97 = llvm.load %54 {alignment = 4 : i64} : !llvm.ptr -> vector<8xf32>
          %98 = llvm.mul %10, %3 : i64
          %99 = llvm.mul %66, %8 : i64
          %100 = llvm.add %98, %99 : i64
          %101 = llvm.add %100, %10 : i64
          %102 = llvm.add %101, %10 : i64
          %103 = llvm.getelementptr %53[%102] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %97, %103 {alignment = 4 : i64} : vector<8xf32>, !llvm.ptr
          %104 = llvm.add %66, %12 : i64
          llvm.br ^bb1(%104 : i64)
        ^bb8:  // pred: ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_15 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_15_mmt4d_1x1x2x1x8x1_f32 ordinal(0) layout(#pipeline_layout7) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @iree_uk_mmt4d(!llvm.ptr, i64, i64, !llvm.ptr, i64, i64, !llvm.ptr, i64, i64, i64, i64, i64, i32, i32, i32, i32, !llvm.ptr) -> i32 attributes {hal.import.bitcode = true, hal.import.fields = ["processor_data"], llvm.bareptr = true}
        llvm.func @main_graph$async_dispatch_15_mmt4d_1x1x2x1x8x1_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(52255 : i64) : i64
          %1 = llvm.mlir.constant(8 : i64) : i64
          %2 = llvm.mlir.constant(0 : i32) : i32
          %3 = llvm.mlir.constant(-1 : index) : i64
          %4 = llvm.mlir.constant(4 : index) : i64
          %5 = llvm.mlir.constant(0 : index) : i64
          %6 = llvm.mlir.constant(8 : index) : i64
          %7 = llvm.mlir.constant(16 : index) : i64
          %8 = llvm.mlir.constant(1537 : i32) : i32
          %9 = llvm.mlir.constant(8 : i32) : i32
          %10 = llvm.mlir.constant(1 : i32) : i32
          %11 = llvm.mlir.constant(2 : index) : i64
          %12 = llvm.mlir.constant(1 : index) : i64
          %13 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %14 = llvm.extractvalue %13[9] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %15 = llvm.load %14 : !llvm.ptr -> i32
          %16 = llvm.getelementptr %14[1] : (!llvm.ptr) -> !llvm.ptr, i32
          %17 = llvm.load %16 : !llvm.ptr -> i32
          %18 = llvm.getelementptr %14[2] : (!llvm.ptr) -> !llvm.ptr, i32
          %19 = llvm.load %18 : !llvm.ptr -> i32
          %20 = llvm.zext %15 : i32 to i64
          %21 = llvm.zext %17 : i32 to i64
          %22 = llvm.zext %19 : i32 to i64
          %23 = llvm.icmp "slt" %20, %5 : i64
          %24 = llvm.sub %3, %20 : i64
          %25 = llvm.select %23, %24, %20 : i1, i64
          %26 = llvm.sdiv %25, %4 : i64
          %27 = llvm.sub %3, %26 : i64
          %28 = llvm.select %23, %27, %26 : i1, i64
          %29 = llvm.extractvalue %13[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %30 = llvm.load %29 : !llvm.ptr -> !llvm.ptr
          %31 = llvm.icmp "slt" %21, %5 : i64
          %32 = llvm.sub %3, %21 : i64
          %33 = llvm.select %31, %32, %21 : i1, i64
          %34 = llvm.sdiv %33, %4 : i64
          %35 = llvm.sub %3, %34 : i64
          %36 = llvm.select %31, %35, %34 : i1, i64
          %37 = llvm.icmp "slt" %22, %5 : i64
          %38 = llvm.sub %3, %22 : i64
          %39 = llvm.select %37, %38, %22 : i1, i64
          %40 = llvm.sdiv %39, %4 : i64
          %41 = llvm.sub %3, %40 : i64
          %42 = llvm.select %37, %41, %40 : i1, i64
          %43 = llvm.getelementptr %29[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %44 = llvm.load %43 : !llvm.ptr -> !llvm.ptr
          %45 = llvm.getelementptr inbounds %arg0[4] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %46 = llvm.alloca %1 x i64 {alignment = 8 : i64} : (i64) -> !llvm.ptr
          %47 = llvm.load %45 : !llvm.ptr -> i64
          %48 = llvm.or %47, %0 : i64
          llvm.store %48, %46 : i64, !llvm.ptr
          %49 = llvm.getelementptr inbounds %45[1] : (!llvm.ptr) -> !llvm.ptr, i64
          %50 = llvm.load %49 : !llvm.ptr -> i64
          %51 = llvm.getelementptr inbounds %46[1] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %50, %51 : i64, !llvm.ptr
          %52 = llvm.getelementptr inbounds %45[2] : (!llvm.ptr) -> !llvm.ptr, i64
          %53 = llvm.load %52 : !llvm.ptr -> i64
          %54 = llvm.getelementptr inbounds %46[2] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %53, %54 : i64, !llvm.ptr
          %55 = llvm.getelementptr inbounds %45[3] : (!llvm.ptr) -> !llvm.ptr, i64
          %56 = llvm.load %55 : !llvm.ptr -> i64
          %57 = llvm.getelementptr inbounds %46[3] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %56, %57 : i64, !llvm.ptr
          %58 = llvm.getelementptr inbounds %45[4] : (!llvm.ptr) -> !llvm.ptr, i64
          %59 = llvm.load %58 : !llvm.ptr -> i64
          %60 = llvm.getelementptr inbounds %46[4] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %59, %60 : i64, !llvm.ptr
          %61 = llvm.getelementptr inbounds %45[5] : (!llvm.ptr) -> !llvm.ptr, i64
          %62 = llvm.load %61 : !llvm.ptr -> i64
          %63 = llvm.getelementptr inbounds %46[5] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %62, %63 : i64, !llvm.ptr
          %64 = llvm.getelementptr inbounds %45[6] : (!llvm.ptr) -> !llvm.ptr, i64
          %65 = llvm.load %64 : !llvm.ptr -> i64
          %66 = llvm.getelementptr inbounds %46[6] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %65, %66 : i64, !llvm.ptr
          %67 = llvm.getelementptr inbounds %45[7] : (!llvm.ptr) -> !llvm.ptr, i64
          %68 = llvm.load %67 : !llvm.ptr -> i64
          %69 = llvm.getelementptr inbounds %46[7] : (!llvm.ptr) -> !llvm.ptr, i64
          llvm.store %68, %69 : i64, !llvm.ptr
          %70 = llvm.call @iree_uk_mmt4d(%30, %28, %11, %30, %36, %7, %44, %42, %6, %12, %12, %11, %10, %9, %10, %8, %46) : (!llvm.ptr, i64, i64, !llvm.ptr, i64, i64, !llvm.ptr, i64, i64, i64, i64, i64, i32, i32, i32, i32, !llvm.ptr) -> i32
          llvm.return %2 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_16 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_16_unpack_elementwise_2_f32 ordinal(0) layout(#pipeline_layout9) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_16_unpack_elementwise_2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(64 : index) : i64
          %2 = llvm.mlir.constant(true) : i1
          %3 = llvm.mlir.constant(8 : index) : i64
          %4 = llvm.mlir.constant(8 : i64) : i64
          %5 = llvm.mlir.constant(32 : i64) : i64
          %6 = llvm.mlir.constant(1 : index) : i64
          %7 = llvm.mlir.constant(2 : index) : i64
          %8 = llvm.mlir.constant(0 : index) : i64
          %9 = llvm.mlir.constant(dense<1.000000e-01> : vector<2xf32>) : vector<2xf32>
          %10 = llvm.alloca %7 x f32 {alignment = 64 : i64} : (i64) -> !llvm.ptr
          %11 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %12 = llvm.extractvalue %11[9] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %13 = llvm.load %12 : !llvm.ptr -> i32
          %14 = llvm.getelementptr %12[1] : (!llvm.ptr) -> !llvm.ptr, i32
          %15 = llvm.load %14 : !llvm.ptr -> i32
          %16 = llvm.getelementptr %12[2] : (!llvm.ptr) -> !llvm.ptr, i32
          %17 = llvm.load %16 : !llvm.ptr -> i32
          %18 = llvm.zext %13 : i32 to i64
          %19 = llvm.zext %15 : i32 to i64
          %20 = llvm.zext %17 : i32 to i64
          %21 = llvm.extractvalue %11[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %22 = llvm.load %21 : !llvm.ptr -> !llvm.ptr
          %23 = llvm.mul %18, %4 : i64
          %24 = llvm.udiv %23, %5 : i64
          %25 = llvm.getelementptr %22[%24] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%25, %1 : !llvm.ptr, i64)] : i1
          %26 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %27 = llvm.extractvalue %26[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %28 = llvm.getelementptr %27[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %29 = llvm.load %28 : !llvm.ptr -> !llvm.ptr
          %30 = llvm.mul %19, %4 : i64
          %31 = llvm.udiv %30, %5 : i64
          %32 = llvm.getelementptr %29[%31] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%32, %1 : !llvm.ptr, i64)] : i1
          %33 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %34 = llvm.extractvalue %33[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %35 = llvm.getelementptr %34[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %36 = llvm.load %35 : !llvm.ptr -> !llvm.ptr
          %37 = llvm.mul %20, %4 : i64
          %38 = llvm.udiv %37, %5 : i64
          %39 = llvm.getelementptr %36[%38] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%39, %1 : !llvm.ptr, i64)] : i1
          %40 = llvm.alloca %3 x f32 {alignment = 32 : i64} : (i64) -> !llvm.ptr
          %41 = llvm.mul %8, %3 : i64
          %42 = llvm.add %41, %8 : i64
          %43 = llvm.getelementptr %25[%42] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %44 = llvm.load %43 {alignment = 4 : i64} : !llvm.ptr -> vector<8xf32>
          llvm.store %44, %40 {alignment = 4 : i64} : vector<8xf32>, !llvm.ptr
          llvm.br ^bb1(%8 : i64)
        ^bb1(%45: i64):  // 2 preds: ^bb0, ^bb2
          %46 = llvm.icmp "slt" %45, %7 : i64
          llvm.cond_br %46, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %47 = llvm.getelementptr inbounds|nuw %40[%45] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %48 = llvm.load %47 : !llvm.ptr -> f32
          %49 = llvm.getelementptr inbounds|nuw %10[%45] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %48, %49 : f32, !llvm.ptr
          %50 = llvm.add %45, %6 : i64
          llvm.br ^bb1(%50 : i64)
        ^bb3:  // pred: ^bb1
          %51 = llvm.load %32 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %52 = llvm.load %10 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %53 = llvm.fmul %52, %9 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %54 = llvm.fadd %51, %53 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          llvm.store %54, %39 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_18 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_18_elementwise_2_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_18_elementwise_2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(64 : index) : i64
          %2 = llvm.mlir.constant(true) : i1
          %3 = llvm.mlir.constant(8 : i64) : i64
          %4 = llvm.mlir.constant(32 : i64) : i64
          %5 = llvm.mlir.constant(128 : index) : i64
          %6 = llvm.mlir.constant(256 : index) : i64
          %7 = llvm.mlir.constant(320 : index) : i64
          %8 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %9 = llvm.extractvalue %8[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %10 = llvm.load %9 : !llvm.ptr -> !llvm.ptr
          %11 = llvm.mul %5, %3 : i64
          %12 = llvm.udiv %11, %4 : i64
          %13 = llvm.getelementptr %10[%12] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%13, %1 : !llvm.ptr, i64)] : i1
          %14 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %15 = llvm.extractvalue %14[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %16 = llvm.load %15 : !llvm.ptr -> !llvm.ptr
          %17 = llvm.mul %6, %3 : i64
          %18 = llvm.udiv %17, %4 : i64
          %19 = llvm.getelementptr %16[%18] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%19, %1 : !llvm.ptr, i64)] : i1
          %20 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %21 = llvm.extractvalue %20[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %22 = llvm.getelementptr %21[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %23 = llvm.load %22 : !llvm.ptr -> !llvm.ptr
          %24 = llvm.mul %7, %3 : i64
          %25 = llvm.udiv %24, %4 : i64
          %26 = llvm.getelementptr %23[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %2 ["align"(%26, %1 : !llvm.ptr, i64)] : i1
          %27 = llvm.load %13 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %28 = llvm.load %19 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %29 = llvm.fsub %27, %28 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          llvm.store %29, %26 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_113 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_113_elementwise_broadcast ordinal(0) layout(#pipeline_layout4) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        hal.return %c1, %c1, %c1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.func @main_graph$async_dispatch_113_elementwise_broadcast(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(64 : index) : i64
          %1 = llvm.mlir.constant(true) : i1
          %2 = llvm.mlir.constant(8 : i64) : i64
          %3 = llvm.mlir.constant(32 : i64) : i64
          %4 = llvm.mlir.constant(2 : i32) : i32
          %5 = llvm.mlir.constant(1 : i32) : i32
          %6 = llvm.mlir.constant(0 : i32) : i32
          %7 = llvm.mlir.constant(3 : i32) : i32
          %8 = llvm.mlir.constant(-2.59630184E-7 : f32) : f32
          %9 = llvm.mlir.constant(2.47562348E-5 : f32) : f32
          %10 = llvm.mlir.constant(-0.00138883304 : f32) : f32
          %11 = llvm.mlir.constant(0.0416666418 : f32) : f32
          %12 = llvm.mlir.constant(-5.000000e-01 : f32) : f32
          %13 = llvm.mlir.constant(-2.50293279E-8 : f32) : f32
          %14 = llvm.mlir.constant(2.76001265E-6 : f32) : f32
          %15 = llvm.mlir.constant(-1.98426045E-4 : f32) : f32
          %16 = llvm.mlir.constant(0.00833334774 : f32) : f32
          %17 = llvm.mlir.constant(-0.166666672 : f32) : f32
          %18 = llvm.mlir.constant(-1.000000e+00 : f32) : f32
          %19 = llvm.mlir.constant(1.000000e+00 : f32) : f32
          %20 = llvm.mlir.constant(1.57079637 : f32) : f32
          %21 = llvm.mlir.constant(0.636619746 : f32) : f32
          %22 = llvm.mlir.constant(128 : index) : i64
          %23 = llvm.mlir.constant(4 : index) : i64
          %24 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %25 = llvm.extractvalue %24[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %26 = llvm.load %25 : !llvm.ptr -> !llvm.ptr
          %27 = llvm.mul %22, %2 : i64
          %28 = llvm.udiv %27, %3 : i64
          %29 = llvm.getelementptr %26[%28] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %1 ["align"(%29, %0 : !llvm.ptr, i64)] : i1
          %30 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %31 = llvm.extractvalue %30[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %32 = llvm.getelementptr %31[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %33 = llvm.load %32 : !llvm.ptr -> !llvm.ptr
          %34 = llvm.mul %23, %2 : i64
          %35 = llvm.udiv %34, %3 : i64
          %36 = llvm.getelementptr %33[%35] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %1 ["align"(%36, %23 : !llvm.ptr, i64)] : i1
          %37 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %38 = llvm.extractvalue %37[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %39 = llvm.getelementptr %38[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %40 = llvm.load %39 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %1 ["align"(%40, %0 : !llvm.ptr, i64)] : i1
          %41 = llvm.load %29 : !llvm.ptr -> f32
          %42 = llvm.getelementptr inbounds|nuw %29[1] : (!llvm.ptr) -> !llvm.ptr, f32
          %43 = llvm.load %42 : !llvm.ptr -> f32
          %44 = llvm.fadd %41, %43 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %45 = llvm.fmul %44, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %46 = llvm.intr.floor(%45) : (f32) -> f32
          %47 = llvm.fmul %46, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %48 = llvm.fsub %44, %47 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %49 = llvm.fptosi %46 : f32 to i32
          %50 = llvm.and %49, %7 : i32
          %51 = llvm.icmp "eq" %50, %6 : i32
          %52 = llvm.icmp "eq" %50, %5 : i32
          %53 = llvm.icmp "eq" %50, %4 : i32
          %54 = llvm.or %51, %53 : i1
          %55 = llvm.or %52, %53 : i1
          %56 = llvm.fmul %48, %48 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %57 = llvm.select %54, %19, %48 : i1, f32
          %58 = llvm.select %54, %12, %17 : i1, f32
          %59 = llvm.select %54, %11, %16 : i1, f32
          %60 = llvm.select %54, %10, %15 : i1, f32
          %61 = llvm.select %54, %9, %14 : i1, f32
          %62 = llvm.select %54, %8, %13 : i1, f32
          %63 = llvm.intr.fma(%56, %62, %61) : (f32, f32, f32) -> f32
          %64 = llvm.intr.fma(%56, %63, %60) : (f32, f32, f32) -> f32
          %65 = llvm.intr.fma(%56, %64, %59) : (f32, f32, f32) -> f32
          %66 = llvm.intr.fma(%56, %65, %58) : (f32, f32, f32) -> f32
          %67 = llvm.intr.fma(%56, %66, %19) : (f32, f32, f32) -> f32
          %68 = llvm.fmul %57, %67 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %69 = llvm.fmul %68, %18 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %70 = llvm.select %55, %69, %68 : i1, f32
          %71 = llvm.fmul %41, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %72 = llvm.intr.floor(%71) : (f32) -> f32
          %73 = llvm.fmul %72, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %74 = llvm.fsub %41, %73 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %75 = llvm.fptosi %72 : f32 to i32
          %76 = llvm.and %75, %7 : i32
          %77 = llvm.icmp "eq" %76, %6 : i32
          %78 = llvm.icmp "eq" %76, %5 : i32
          %79 = llvm.icmp "eq" %76, %4 : i32
          %80 = llvm.or %77, %79 : i1
          %81 = llvm.or %78, %79 : i1
          %82 = llvm.fmul %74, %74 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %83 = llvm.select %80, %19, %74 : i1, f32
          %84 = llvm.select %80, %12, %17 : i1, f32
          %85 = llvm.select %80, %11, %16 : i1, f32
          %86 = llvm.select %80, %10, %15 : i1, f32
          %87 = llvm.select %80, %9, %14 : i1, f32
          %88 = llvm.select %80, %8, %13 : i1, f32
          %89 = llvm.intr.fma(%82, %88, %87) : (f32, f32, f32) -> f32
          %90 = llvm.intr.fma(%82, %89, %86) : (f32, f32, f32) -> f32
          %91 = llvm.intr.fma(%82, %90, %85) : (f32, f32, f32) -> f32
          %92 = llvm.intr.fma(%82, %91, %84) : (f32, f32, f32) -> f32
          %93 = llvm.intr.fma(%82, %92, %19) : (f32, f32, f32) -> f32
          %94 = llvm.fmul %83, %93 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %95 = llvm.fmul %94, %18 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %96 = llvm.select %81, %95, %94 : i1, f32
          %97 = llvm.fadd %96, %70 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %97, %40 : f32, !llvm.ptr
          %98 = llvm.load %29 : !llvm.ptr -> f32
          %99 = llvm.load %42 : !llvm.ptr -> f32
          %100 = llvm.fadd %98, %99 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %101 = llvm.fmul %100, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %102 = llvm.intr.floor(%101) : (f32) -> f32
          %103 = llvm.fmul %102, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %104 = llvm.fsub %100, %103 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %105 = llvm.fptosi %102 : f32 to i32
          %106 = llvm.and %105, %7 : i32
          %107 = llvm.icmp "eq" %106, %5 : i32
          %108 = llvm.icmp "eq" %106, %7 : i32
          %109 = llvm.or %107, %108 : i1
          %110 = llvm.icmp "sgt" %106, %5 : i32
          %111 = llvm.fmul %104, %104 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %112 = llvm.select %109, %19, %104 : i1, f32
          %113 = llvm.select %109, %12, %17 : i1, f32
          %114 = llvm.select %109, %11, %16 : i1, f32
          %115 = llvm.select %109, %10, %15 : i1, f32
          %116 = llvm.select %109, %9, %14 : i1, f32
          %117 = llvm.select %109, %8, %13 : i1, f32
          %118 = llvm.intr.fma(%111, %117, %116) : (f32, f32, f32) -> f32
          %119 = llvm.intr.fma(%111, %118, %115) : (f32, f32, f32) -> f32
          %120 = llvm.intr.fma(%111, %119, %114) : (f32, f32, f32) -> f32
          %121 = llvm.intr.fma(%111, %120, %113) : (f32, f32, f32) -> f32
          %122 = llvm.intr.fma(%111, %121, %19) : (f32, f32, f32) -> f32
          %123 = llvm.fmul %112, %122 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %124 = llvm.fmul %123, %18 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %125 = llvm.select %110, %124, %123 : i1, f32
          %126 = llvm.fmul %98, %21 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %127 = llvm.intr.floor(%126) : (f32) -> f32
          %128 = llvm.fmul %127, %20 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %129 = llvm.fsub %98, %128 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %130 = llvm.fptosi %127 : f32 to i32
          %131 = llvm.and %130, %7 : i32
          %132 = llvm.icmp "eq" %131, %5 : i32
          %133 = llvm.icmp "eq" %131, %7 : i32
          %134 = llvm.or %132, %133 : i1
          %135 = llvm.icmp "sgt" %131, %5 : i32
          %136 = llvm.fmul %129, %129 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %137 = llvm.select %134, %19, %129 : i1, f32
          %138 = llvm.select %134, %12, %17 : i1, f32
          %139 = llvm.select %134, %11, %16 : i1, f32
          %140 = llvm.select %134, %10, %15 : i1, f32
          %141 = llvm.select %134, %9, %14 : i1, f32
          %142 = llvm.select %134, %8, %13 : i1, f32
          %143 = llvm.intr.fma(%136, %142, %141) : (f32, f32, f32) -> f32
          %144 = llvm.intr.fma(%136, %143, %140) : (f32, f32, f32) -> f32
          %145 = llvm.intr.fma(%136, %144, %139) : (f32, f32, f32) -> f32
          %146 = llvm.intr.fma(%136, %145, %138) : (f32, f32, f32) -> f32
          %147 = llvm.intr.fma(%136, %146, %19) : (f32, f32, f32) -> f32
          %148 = llvm.fmul %137, %147 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %149 = llvm.fmul %148, %18 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %150 = llvm.select %135, %149, %148 : i1, f32
          %151 = llvm.fadd %150, %125 {fastmathFlags = #llvm.fastmath<contract>} : f32
          llvm.store %151, %36 : f32, !llvm.ptr
          llvm.return %6 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_114 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_114_elementwise_2_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.mlir.global private constant @__constant_2xf32(dense<[-2.000000e-01, 0.000000e+00]> : tensor<2xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<2 x f32>
        llvm.func @main_graph$async_dispatch_114_elementwise_2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.constant(8 : i64) : i64
          %2 = llvm.mlir.constant(32 : i64) : i64
          %3 = llvm.mlir.constant(true) : i1
          %4 = llvm.mlir.addressof @__constant_2xf32 : !llvm.ptr
          %5 = llvm.mlir.constant(64 : index) : i64
          %6 = llvm.getelementptr %4[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<2 x f32>
          %7 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %8 = llvm.extractvalue %7[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %9 = llvm.load %8 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %3 ["align"(%9, %5 : !llvm.ptr, i64)] : i1
          %10 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %11 = llvm.extractvalue %10[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %12 = llvm.getelementptr %11[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %13 = llvm.load %12 : !llvm.ptr -> !llvm.ptr
          %14 = llvm.mul %5, %1 : i64
          %15 = llvm.udiv %14, %2 : i64
          %16 = llvm.getelementptr %13[%15] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %3 ["align"(%16, %5 : !llvm.ptr, i64)] : i1
          %17 = llvm.load %9 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %18 = llvm.load %6 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %19 = llvm.fadd %17, %18 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          llvm.store %19, %16 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_115 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_115_elementwise_broadcast_10x2_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.mlir.global private constant @__constant_10xf32_0(dense<[1.000000e+00, 0.888888895, 0.777777791, 0.666666627, 0.555555582, 0.444444418, 0.333333313, 0.222222209, 0.111111104, 0.000000e+00]> : tensor<10xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<10 x f32>
        llvm.mlir.global private constant @__constant_10xf32(dense<[0.000000e+00, 0.111111112, 0.222222224, 0.333333343, 0.444444448, 0.555555582, 0.666666686, 0.777777791, 0.888888895, 1.000000e+00]> : tensor<10xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<10 x f32>
        llvm.func @main_graph$async_dispatch_115_elementwise_broadcast_10x2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.poison : vector<2xf32>
          %2 = llvm.mlir.constant(0 : i64) : i64
          %3 = llvm.mlir.constant(8 : i64) : i64
          %4 = llvm.mlir.constant(32 : i64) : i64
          %5 = llvm.mlir.constant(true) : i1
          %6 = llvm.mlir.constant(2 : index) : i64
          %7 = llvm.mlir.addressof @__constant_10xf32_0 : !llvm.ptr
          %8 = llvm.mlir.addressof @__constant_10xf32 : !llvm.ptr
          %9 = llvm.mlir.constant(10 : index) : i64
          %10 = llvm.mlir.constant(1 : index) : i64
          %11 = llvm.mlir.constant(64 : index) : i64
          %12 = llvm.mlir.constant(0 : index) : i64
          %13 = llvm.getelementptr %8[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<10 x f32>
          %14 = llvm.getelementptr %7[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<10 x f32>
          %15 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %16 = llvm.extractvalue %15[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %17 = llvm.load %16 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %5 ["align"(%17, %11 : !llvm.ptr, i64)] : i1
          %18 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %19 = llvm.extractvalue %18[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %20 = llvm.load %19 : !llvm.ptr -> !llvm.ptr
          %21 = llvm.mul %11, %3 : i64
          %22 = llvm.udiv %21, %4 : i64
          %23 = llvm.getelementptr %20[%22] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %5 ["align"(%23, %11 : !llvm.ptr, i64)] : i1
          %24 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %25 = llvm.extractvalue %24[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %26 = llvm.getelementptr %25[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %27 = llvm.load %26 : !llvm.ptr -> !llvm.ptr
          %28 = llvm.getelementptr %27[%22] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %5 ["align"(%28, %11 : !llvm.ptr, i64)] : i1
          %29 = llvm.load %17 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %30 = llvm.load %23 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          llvm.br ^bb1(%12 : i64)
        ^bb1(%31: i64):  // 2 preds: ^bb0, ^bb2
          %32 = llvm.icmp "slt" %31, %9 : i64
          llvm.cond_br %32, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %33 = llvm.getelementptr %14[%31] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %34 = llvm.load %33 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %35 = llvm.getelementptr %13[%31] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %36 = llvm.load %35 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %37 = llvm.extractelement %36[%2 : i64] : vector<1xf32>
          %38 = llvm.insertelement %37, %1[%0 : i32] : vector<2xf32>
          %39 = llvm.shufflevector %38, %1 [0, 0] : vector<2xf32> 
          %40 = llvm.fmul %30, %39 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %41 = llvm.extractelement %34[%2 : i64] : vector<1xf32>
          %42 = llvm.insertelement %41, %1[%0 : i32] : vector<2xf32>
          %43 = llvm.shufflevector %42, %1 [0, 0] : vector<2xf32> 
          %44 = llvm.fmul %29, %43 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %45 = llvm.fadd %44, %40 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %46 = llvm.mul %31, %6 : i64
          %47 = llvm.add %46, %12 : i64
          %48 = llvm.getelementptr %28[%47] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %45, %48 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          %49 = llvm.add %31, %10 : i64
          llvm.br ^bb1(%49 : i64)
        ^bb3:  // pred: ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_116 {
    hal.executable.variant public @embedded_elf_x86_64 target(#executable_target_embedded_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_116_elementwise_broadcast_9x2_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device) -> (index, index, index) {
        %c1 = arith.constant 1 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %c1, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-unknown-eabi-elf"} {
        llvm.mlir.global private constant @__constant_10xf32_0(dense<[1.000000e+00, 0.888888895, 0.777777791, 0.666666627, 0.555555582, 0.444444418, 0.333333313, 0.222222209, 0.111111104, 0.000000e+00]> : tensor<10xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<10 x f32>
        llvm.mlir.global private constant @__constant_2xf32(dense<[0.000000e+00, -1.000000e-01]> : tensor<2xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<2 x f32>
        llvm.mlir.global private constant @__constant_10xf32(dense<[0.000000e+00, 0.111111112, 0.222222224, 0.333333343, 0.444444448, 0.555555582, 0.666666686, 0.777777791, 0.888888895, 1.000000e+00]> : tensor<10xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<10 x f32>
        llvm.func @main_graph$async_dispatch_116_elementwise_broadcast_9x2_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.poison : vector<2xf32>
          %2 = llvm.mlir.constant(0 : i64) : i64
          %3 = llvm.mlir.constant(16 : index) : i64
          %4 = llvm.mlir.constant(true) : i1
          %5 = llvm.mlir.constant(8 : i64) : i64
          %6 = llvm.mlir.constant(32 : i64) : i64
          %7 = llvm.mlir.addressof @__constant_10xf32_0 : !llvm.ptr
          %8 = llvm.mlir.addressof @__constant_2xf32 : !llvm.ptr
          %9 = llvm.mlir.constant(2 : index) : i64
          %10 = llvm.mlir.addressof @__constant_10xf32 : !llvm.ptr
          %11 = llvm.mlir.constant(0 : index) : i64
          %12 = llvm.mlir.constant(9 : index) : i64
          %13 = llvm.mlir.constant(1 : index) : i64
          %14 = llvm.mlir.constant(144 : index) : i64
          %15 = llvm.mlir.constant(64 : index) : i64
          %16 = llvm.getelementptr %10[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<10 x f32>
          %17 = llvm.getelementptr %8[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<2 x f32>
          %18 = llvm.getelementptr %7[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<10 x f32>
          %19 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %20 = llvm.extractvalue %19[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %21 = llvm.load %20 : !llvm.ptr -> !llvm.ptr
          %22 = llvm.mul %15, %5 : i64
          %23 = llvm.udiv %22, %6 : i64
          %24 = llvm.getelementptr %21[%23] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%24, %15 : !llvm.ptr, i64)] : i1
          %25 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %26 = llvm.extractvalue %25[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %27 = llvm.getelementptr %26[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %28 = llvm.load %27 : !llvm.ptr -> !llvm.ptr
          %29 = llvm.mul %14, %5 : i64
          %30 = llvm.udiv %29, %6 : i64
          %31 = llvm.getelementptr %28[%30] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %4 ["align"(%31, %3 : !llvm.ptr, i64)] : i1
          %32 = llvm.load %24 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %33 = llvm.load %17 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %34 = llvm.fadd %32, %33 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          llvm.br ^bb1(%11 : i64)
        ^bb1(%35: i64):  // 2 preds: ^bb0, ^bb2
          %36 = llvm.icmp "slt" %35, %12 : i64
          llvm.cond_br %36, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %37 = llvm.add %35, %13 : i64
          %38 = llvm.getelementptr %18[%37] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %39 = llvm.load %38 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %40 = llvm.getelementptr %16[%37] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %41 = llvm.load %40 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %42 = llvm.extractelement %41[%2 : i64] : vector<1xf32>
          %43 = llvm.insertelement %42, %1[%0 : i32] : vector<2xf32>
          %44 = llvm.shufflevector %43, %1 [0, 0] : vector<2xf32> 
          %45 = llvm.fmul %34, %44 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %46 = llvm.extractelement %39[%2 : i64] : vector<1xf32>
          %47 = llvm.insertelement %46, %1[%0 : i32] : vector<2xf32>
          %48 = llvm.shufflevector %47, %1 [0, 0] : vector<2xf32> 
          %49 = llvm.fmul %32, %48 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %50 = llvm.fadd %49, %45 {fastmathFlags = #llvm.fastmath<contract>} : vector<2xf32>
          %51 = llvm.mul %35, %9 : i64
          %52 = llvm.add %51, %11 : i64
          %53 = llvm.getelementptr %31[%52] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %50, %53 {alignment = 4 : i64} : vector<2xf32>, !llvm.ptr
          llvm.br ^bb1(%37 : i64)
        ^bb3:  // pred: ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  util.global private @__constant_tensor_4x3x4x4xf32 : !stream.resource<constant>
  util.initializer {
    %c0 = arith.constant 0 : index
    %c0_i64 = arith.constant 0 : i64
    %c8960 = arith.constant 8960 : index
    %0 = stream.timepoint.immediate => !stream.timepoint
    %buffer_cst = util.buffer.constant {alignment = 64 : index} : !util.buffer = #composite_of_8960b
    %did_map, %result = stream.resource.try_map on(#hal.device.affinity<@__device_0>) %buffer_cst[%c0] : !util.buffer -> i1, !stream.resource<constant>{%c8960}
    cf.cond_br %did_map, ^bb2(%0, %result : !stream.timepoint, !stream.resource<constant>), ^bb1
  ^bb1:  // pred: ^bb0
    %1 = stream.resource.alloc uninitialized on(#hal.device.affinity<@__device_0>) : !stream.resource<constant>{%c8960}
    %file = stream.file.constant on(#hal.device.affinity<@__device_0>) %buffer_cst[%c0 for %c8960] : !util.buffer{%c8960} -> !stream.file
    %2 = stream.file.read on(#hal.device.affinity<@__device_0>) await(%0) => %file[%c0_i64], %1[%c0], %c8960 : !stream.file -> !stream.resource<constant>{%c8960} => !stream.timepoint
    cf.br ^bb2(%2, %1 : !stream.timepoint, !stream.resource<constant>)
  ^bb2(%3: !stream.timepoint, %4: !stream.resource<constant>):  // 2 preds: ^bb0, ^bb1
    %5 = stream.timepoint.await sync %3 => %4 : !stream.resource<constant>{%c8960}
    util.global.store %5, @__constant_tensor_4x3x4x4xf32 : !stream.resource<constant>
    util.return
  }
  util.func public @main_graph$async(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.fence, %arg5: !hal.fence) -> (!hal.buffer_view, !hal.buffer_view) attributes {inlining_policy = #util.inline.never, iree.abi.model = "coarse-fences", iree.abi.stub} {
    %c152 = arith.constant 152 : index
    %c1024 = arith.constant 1024 : index
    %c52272 = arith.constant 52272 : index
    %c4 = arith.constant 4 : index
    %c8 = arith.constant 8 : index
    %c12 = arith.constant 12 : index
    %c49152 = arith.constant 49152 : index
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %c3 = arith.constant 3 : index
    %c64 = arith.constant 64 : index
    %c0_i8 = arith.constant 0 : i8
    %c256 = arith.constant 256 : index
    %c1088 = arith.constant 1088 : index
    %c128 = arith.constant 128 : index
    %c192 = arith.constant 192 : index
    %c320 = arith.constant 320 : index
    %c384 = arith.constant 384 : index
    %c448 = arith.constant 448 : index
    %c56384 = arith.constant 56384 : index
    %c136 = arith.constant 136 : index
    %c260 = arith.constant 260 : index
    %c264 = arith.constant 264 : index
    %c0 = arith.constant 0 : index
    %c8960 = arith.constant 8960 : index
    %c0_i32 = arith.constant 0 : i32
    %c4_i32 = arith.constant 4 : i32
    %c1024_i32 = arith.constant 1024 : i32
    %c1092_i32 = arith.constant 1092 : i32
    %c1088_i32 = arith.constant 1088 : i32
    %c128_i32 = arith.constant 128 : i32
    %c192_i32 = arith.constant 192 : i32
    %c68_i32 = arith.constant 68 : i32
    %c64_i32 = arith.constant 64 : i32
    %c256_i32 = arith.constant 256 : i32
    %c324_i32 = arith.constant 324 : i32
    %c384_i32 = arith.constant 384 : i32
    %c388_i32 = arith.constant 388 : i32
    %c320_i32 = arith.constant 320 : i32
    %c448_i32 = arith.constant 448 : i32
    %c452_i32 = arith.constant 452 : i32
    %c196_i32 = arith.constant 196 : i32
    %c260_i32 = arith.constant 260 : i32
    %__constant_tensor_4x3x4x4xf32 = util.global.load immutable @__constant_tensor_4x3x4x4xf32 : !stream.resource<constant>
    %element_type_f32 = hal.element_type<f32> : i32
    %dense_row_major = hal.encoding_type<dense_row_major> : i32
    hal.buffer_view.assert<%arg0 : !hal.buffer_view> message("tensor") shape([%c1, %c3, %c64, %c64]) type(%element_type_f32) encoding(%dense_row_major)
    %0 = stream.tensor.import on(#hal.device.affinity<@__device_0>) %arg0 : !hal.buffer_view -> tensor<1x3x64x64xf32> in !stream.resource<external>{%c49152}
    %1 = stream.timepoint.import on(#hal.device.affinity<@__device_0>) %arg4 : (!hal.fence) => !stream.timepoint
    hal.buffer_view.assert<%arg1 : !hal.buffer_view> message("tensor") shape([%c3]) type(%element_type_f32) encoding(%dense_row_major)
    %2 = stream.tensor.import on(#hal.device.affinity<@__device_0>) %arg1 : !hal.buffer_view -> tensor<3xf32> in !stream.resource<external>{%c12}
    hal.buffer_view.assert<%arg2 : !hal.buffer_view> message("tensor") shape([%c2]) type(%element_type_f32) encoding(%dense_row_major)
    %3 = stream.tensor.import on(#hal.device.affinity<@__device_0>) %arg2 : !hal.buffer_view -> tensor<2xf32> in !stream.resource<external>{%c8}
    hal.buffer_view.assert<%arg3 : !hal.buffer_view> message("tensor") shape([%c2]) type(%element_type_f32) encoding(%dense_row_major)
    %4 = stream.tensor.import on(#hal.device.affinity<@__device_0>) %arg3 : !hal.buffer_view -> tensor<2xf32> in !stream.resource<external>{%c8}
    %result, %result_timepoint = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) await(%1) => !stream.resource<external>{%c256} => !stream.timepoint
    %5 = stream.resource.subview %result[%c0] : !stream.resource<external>{%c256} -> !stream.resource<external>{%c12}
    %6 = stream.resource.subview %result[%c64] : !stream.resource<external>{%c256} -> !stream.resource<external>{%c152}
    %result_0, %result_timepoint_1 = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) await(%1) => !stream.resource<transient>{%c56384} => !stream.timepoint
    %7 = stream.timepoint.join max(%result_timepoint, %result_timepoint_1) => !stream.timepoint
    %8 = stream.cmd.execute on(#hal.device.affinity<@__device_0>) await(%7) => with(%4 as %arg6: !stream.resource<external>{%c8}, %2 as %arg7: !stream.resource<external>{%c12}, %0 as %arg8: !stream.resource<external>{%c49152}, %__constant_tensor_4x3x4x4xf32 as %arg9: !stream.resource<constant>{%c8960}, %3 as %arg10: !stream.resource<external>{%c8}, %result as %arg11: !stream.resource<external>{%c256}, %result_0 as %arg12: !stream.resource<transient>{%c56384}) {
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_0::@embedded_elf_x86_64::@main_graph$async_dispatch_0_elementwise_broadcast {
          ro %arg6[%c0 for %c8] : !stream.resource<external>{%c8},
          ro %arg7[%c0 for %c12] : !stream.resource<external>{%c12},
          rw %arg11[%c0 for %c256] : !stream.resource<external>{%c256},
          rw %arg11[%c0 for %c256] : !stream.resource<external>{%c256},
          rw %arg11[%c0 for %c256] : !stream.resource<external>{%c256}
        }
        stream.cmd.fill %c0_i8, %arg12[%c0 for %c52272] : i8 -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_1::@embedded_elf_x86_64::@main_graph$async_dispatch_1_slow_memcpy {
        ro %arg8[%c0 for %c49152] : !stream.resource<external>{%c49152},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_2::@embedded_elf_x86_64::@main_graph$async_dispatch_2_conv_4x16x16x3x4x4_f32 {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        ro %arg9[%c0 for %c8960] : !stream.resource<constant>{%c8960},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_3::@embedded_elf_x86_64::@main_graph$async_dispatch_3_conv_4x8x8x2x2_f32 {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_4::@embedded_elf_x86_64::@main_graph$async_dispatch_4_mmt4d_1x1x256x1x8x1_f32 {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          ro %arg9[%c0 for %c8960] : !stream.resource<constant>{%c8960},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_5::@embedded_elf_x86_64::@main_graph$async_dispatch_5_elementwise_broadcast(%c0_i32, %c1024_i32, %c1092_i32, %c1088_i32 : i32, i32, i32, i32) {
          ro %arg10[%c0 for %c8] : !stream.resource<external>{%c8},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.copy %arg12[%c1088], %arg12[%c0], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.copy %arg12[%c1024], %arg12[%c4], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_6::@embedded_elf_x86_64::@main_graph$async_dispatch_6_unpack_elementwise_1x2_f32 {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_7::@embedded_elf_x86_64::@main_graph$async_dispatch_7_elementwise_broadcast(%c0_i32, %c68_i32, %c64_i32 : i32, i32, i32) {
          ro %arg10[%c0 for %c8] : !stream.resource<external>{%c8},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c64], %arg12[%c0], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c1088], %arg12[%c8], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_8::@embedded_elf_x86_64::@main_graph$async_dispatch_8_elementwise_broadcast_2_f32(%c0_i32, %c64_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_10::@embedded_elf_x86_64::@main_graph$async_dispatch_10_elementwise_broadcast_2_f32(%c0_i32, %c256_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.dispatch @main_graph$async_dispatch_13::@embedded_elf_x86_64::@main_graph$async_dispatch_13_elementwise_broadcast(%c256_i32, %c0_i32 : i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c0], %arg12[%c320], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.dispatch @main_graph$async_dispatch_9::@embedded_elf_x86_64::@main_graph$async_dispatch_9_elementwise_broadcast(%c64_i32, %c324_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_11::@embedded_elf_x86_64::@main_graph$async_dispatch_11_elementwise_broadcast(%c256_i32, %c384_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_12::@embedded_elf_x86_64::@main_graph$async_dispatch_12_elementwise_broadcast(%c64_i32, %c256_i32, %c388_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c384], %arg12[%c0], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c320], %arg12[%c8], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_14::@embedded_elf_x86_64::@main_graph$async_dispatch_14_elementwise_2x2_f32_pack(%c64_i32, %c256_i32, %c0_i32, %c320_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_15::@embedded_elf_x86_64::@main_graph$async_dispatch_15_mmt4d_1x1x2x1x8x1_f32(%c192_i32, %c320_i32, %c256_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_16::@embedded_elf_x86_64::@main_graph$async_dispatch_16_unpack_elementwise_2_f32(%c256_i32, %c0_i32, %c192_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        ro %arg10[%c0 for %c8] : !stream.resource<external>{%c8},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_5::@embedded_elf_x86_64::@main_graph$async_dispatch_5_elementwise_broadcast(%c192_i32, %c0_i32, %c68_i32, %c64_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.copy %arg12[%c64], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.copy %arg12[%c0], %arg12[%c260], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_18::@embedded_elf_x86_64::@main_graph$async_dispatch_18_elementwise_2_f32 {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_7::@embedded_elf_x86_64::@main_graph$async_dispatch_7_elementwise_broadcast(%c192_i32, %c4_i32, %c0_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c0], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c64], %arg12[%c264], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_8::@embedded_elf_x86_64::@main_graph$async_dispatch_8_elementwise_broadcast_2_f32(%c256_i32, %c0_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_10::@embedded_elf_x86_64::@main_graph$async_dispatch_10_elementwise_broadcast_2_f32(%c256_i32, %c64_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.dispatch @main_graph$async_dispatch_13::@embedded_elf_x86_64::@main_graph$async_dispatch_13_elementwise_broadcast(%c64_i32, %c256_i32 : i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c256], %arg12[%c384], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.dispatch @main_graph$async_dispatch_9::@embedded_elf_x86_64::@main_graph$async_dispatch_9_elementwise_broadcast(%c0_i32, %c388_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_11::@embedded_elf_x86_64::@main_graph$async_dispatch_11_elementwise_broadcast(%c64_i32, %c448_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_12::@embedded_elf_x86_64::@main_graph$async_dispatch_12_elementwise_broadcast(%c0_i32, %c64_i32, %c452_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c448], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c384], %arg12[%c264], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_14::@embedded_elf_x86_64::@main_graph$async_dispatch_14_elementwise_2x2_f32_pack(%c0_i32, %c64_i32, %c256_i32, %c384_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_15::@embedded_elf_x86_64::@main_graph$async_dispatch_15_mmt4d_1x1x2x1x8x1_f32(%c320_i32, %c384_i32, %c256_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_16::@embedded_elf_x86_64::@main_graph$async_dispatch_16_unpack_elementwise_2_f32(%c256_i32, %c192_i32, %c0_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_5::@embedded_elf_x86_64::@main_graph$async_dispatch_5_elementwise_broadcast(%c0_i32, %c64_i32, %c196_i32, %c192_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.copy %arg12[%c192], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.copy %arg12[%c64], %arg12[%c260], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_18::@embedded_elf_x86_64::@main_graph$async_dispatch_18_elementwise_2_f32 {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_7::@embedded_elf_x86_64::@main_graph$async_dispatch_7_elementwise_broadcast(%c0_i32, %c68_i32, %c64_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c64], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c192], %arg12[%c264], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_8::@embedded_elf_x86_64::@main_graph$async_dispatch_8_elementwise_broadcast_2_f32(%c256_i32, %c64_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_10::@embedded_elf_x86_64::@main_graph$async_dispatch_10_elementwise_broadcast_2_f32(%c256_i32, %c192_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.dispatch @main_graph$async_dispatch_13::@embedded_elf_x86_64::@main_graph$async_dispatch_13_elementwise_broadcast(%c192_i32, %c256_i32 : i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c256], %arg12[%c384], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.dispatch @main_graph$async_dispatch_9::@embedded_elf_x86_64::@main_graph$async_dispatch_9_elementwise_broadcast(%c64_i32, %c388_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_11::@embedded_elf_x86_64::@main_graph$async_dispatch_11_elementwise_broadcast(%c192_i32, %c448_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_12::@embedded_elf_x86_64::@main_graph$async_dispatch_12_elementwise_broadcast(%c64_i32, %c192_i32, %c452_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c448], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c384], %arg12[%c264], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_14::@embedded_elf_x86_64::@main_graph$async_dispatch_14_elementwise_2x2_f32_pack(%c64_i32, %c192_i32, %c256_i32, %c384_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_15::@embedded_elf_x86_64::@main_graph$async_dispatch_15_mmt4d_1x1x2x1x8x1_f32(%c320_i32, %c384_i32, %c64_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_16::@embedded_elf_x86_64::@main_graph$async_dispatch_16_unpack_elementwise_2_f32(%c64_i32, %c0_i32, %c192_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_5::@embedded_elf_x86_64::@main_graph$async_dispatch_5_elementwise_broadcast(%c192_i32, %c0_i32, %c68_i32, %c64_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.copy %arg12[%c64], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.copy %arg12[%c0], %arg12[%c260], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_18::@embedded_elf_x86_64::@main_graph$async_dispatch_18_elementwise_2_f32 {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_7::@embedded_elf_x86_64::@main_graph$async_dispatch_7_elementwise_broadcast(%c192_i32, %c4_i32, %c0_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c0], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c64], %arg12[%c264], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_8::@embedded_elf_x86_64::@main_graph$async_dispatch_8_elementwise_broadcast_2_f32(%c256_i32, %c0_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_10::@embedded_elf_x86_64::@main_graph$async_dispatch_10_elementwise_broadcast_2_f32(%c256_i32, %c64_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.dispatch @main_graph$async_dispatch_13::@embedded_elf_x86_64::@main_graph$async_dispatch_13_elementwise_broadcast(%c64_i32, %c256_i32 : i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c256], %arg12[%c384], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.dispatch @main_graph$async_dispatch_9::@embedded_elf_x86_64::@main_graph$async_dispatch_9_elementwise_broadcast(%c0_i32, %c388_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_11::@embedded_elf_x86_64::@main_graph$async_dispatch_11_elementwise_broadcast(%c64_i32, %c448_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_12::@embedded_elf_x86_64::@main_graph$async_dispatch_12_elementwise_broadcast(%c0_i32, %c64_i32, %c452_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c448], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c384], %arg12[%c264], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_14::@embedded_elf_x86_64::@main_graph$async_dispatch_14_elementwise_2x2_f32_pack(%c0_i32, %c64_i32, %c256_i32, %c384_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_15::@embedded_elf_x86_64::@main_graph$async_dispatch_15_mmt4d_1x1x2x1x8x1_f32(%c320_i32, %c384_i32, %c256_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_16::@embedded_elf_x86_64::@main_graph$async_dispatch_16_unpack_elementwise_2_f32(%c256_i32, %c192_i32, %c0_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_5::@embedded_elf_x86_64::@main_graph$async_dispatch_5_elementwise_broadcast(%c0_i32, %c64_i32, %c196_i32, %c192_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.copy %arg12[%c192], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.copy %arg12[%c64], %arg12[%c260], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_18::@embedded_elf_x86_64::@main_graph$async_dispatch_18_elementwise_2_f32 {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_7::@embedded_elf_x86_64::@main_graph$async_dispatch_7_elementwise_broadcast(%c0_i32, %c68_i32, %c64_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c64], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c192], %arg12[%c264], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_8::@embedded_elf_x86_64::@main_graph$async_dispatch_8_elementwise_broadcast_2_f32(%c256_i32, %c64_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_10::@embedded_elf_x86_64::@main_graph$async_dispatch_10_elementwise_broadcast_2_f32(%c256_i32, %c192_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.dispatch @main_graph$async_dispatch_13::@embedded_elf_x86_64::@main_graph$async_dispatch_13_elementwise_broadcast(%c192_i32, %c256_i32 : i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c256], %arg12[%c384], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.dispatch @main_graph$async_dispatch_9::@embedded_elf_x86_64::@main_graph$async_dispatch_9_elementwise_broadcast(%c64_i32, %c388_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_11::@embedded_elf_x86_64::@main_graph$async_dispatch_11_elementwise_broadcast(%c192_i32, %c448_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_12::@embedded_elf_x86_64::@main_graph$async_dispatch_12_elementwise_broadcast(%c64_i32, %c192_i32, %c452_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c448], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c384], %arg12[%c264], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_14::@embedded_elf_x86_64::@main_graph$async_dispatch_14_elementwise_2x2_f32_pack(%c64_i32, %c192_i32, %c256_i32, %c384_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_15::@embedded_elf_x86_64::@main_graph$async_dispatch_15_mmt4d_1x1x2x1x8x1_f32(%c320_i32, %c384_i32, %c64_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_16::@embedded_elf_x86_64::@main_graph$async_dispatch_16_unpack_elementwise_2_f32(%c64_i32, %c0_i32, %c192_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_5::@embedded_elf_x86_64::@main_graph$async_dispatch_5_elementwise_broadcast(%c192_i32, %c0_i32, %c68_i32, %c64_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.copy %arg12[%c64], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.copy %arg12[%c0], %arg12[%c260], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_18::@embedded_elf_x86_64::@main_graph$async_dispatch_18_elementwise_2_f32 {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_7::@embedded_elf_x86_64::@main_graph$async_dispatch_7_elementwise_broadcast(%c192_i32, %c4_i32, %c0_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c0], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c64], %arg12[%c264], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_8::@embedded_elf_x86_64::@main_graph$async_dispatch_8_elementwise_broadcast_2_f32(%c256_i32, %c0_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_10::@embedded_elf_x86_64::@main_graph$async_dispatch_10_elementwise_broadcast_2_f32(%c256_i32, %c64_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.dispatch @main_graph$async_dispatch_13::@embedded_elf_x86_64::@main_graph$async_dispatch_13_elementwise_broadcast(%c64_i32, %c256_i32 : i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c256], %arg12[%c384], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.dispatch @main_graph$async_dispatch_9::@embedded_elf_x86_64::@main_graph$async_dispatch_9_elementwise_broadcast(%c0_i32, %c388_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_11::@embedded_elf_x86_64::@main_graph$async_dispatch_11_elementwise_broadcast(%c64_i32, %c448_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_12::@embedded_elf_x86_64::@main_graph$async_dispatch_12_elementwise_broadcast(%c0_i32, %c64_i32, %c452_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c448], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c384], %arg12[%c264], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_14::@embedded_elf_x86_64::@main_graph$async_dispatch_14_elementwise_2x2_f32_pack(%c0_i32, %c64_i32, %c256_i32, %c384_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_15::@embedded_elf_x86_64::@main_graph$async_dispatch_15_mmt4d_1x1x2x1x8x1_f32(%c320_i32, %c384_i32, %c256_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_16::@embedded_elf_x86_64::@main_graph$async_dispatch_16_unpack_elementwise_2_f32(%c256_i32, %c192_i32, %c0_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_5::@embedded_elf_x86_64::@main_graph$async_dispatch_5_elementwise_broadcast(%c0_i32, %c64_i32, %c196_i32, %c192_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.copy %arg12[%c192], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.copy %arg12[%c64], %arg12[%c260], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_18::@embedded_elf_x86_64::@main_graph$async_dispatch_18_elementwise_2_f32 {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_7::@embedded_elf_x86_64::@main_graph$async_dispatch_7_elementwise_broadcast(%c0_i32, %c68_i32, %c64_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c64], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c192], %arg12[%c264], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_8::@embedded_elf_x86_64::@main_graph$async_dispatch_8_elementwise_broadcast_2_f32(%c256_i32, %c64_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_10::@embedded_elf_x86_64::@main_graph$async_dispatch_10_elementwise_broadcast_2_f32(%c256_i32, %c192_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.dispatch @main_graph$async_dispatch_13::@embedded_elf_x86_64::@main_graph$async_dispatch_13_elementwise_broadcast(%c192_i32, %c256_i32 : i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c256], %arg12[%c384], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.dispatch @main_graph$async_dispatch_9::@embedded_elf_x86_64::@main_graph$async_dispatch_9_elementwise_broadcast(%c64_i32, %c388_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_11::@embedded_elf_x86_64::@main_graph$async_dispatch_11_elementwise_broadcast(%c192_i32, %c448_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_12::@embedded_elf_x86_64::@main_graph$async_dispatch_12_elementwise_broadcast(%c64_i32, %c192_i32, %c452_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c448], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c384], %arg12[%c264], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_14::@embedded_elf_x86_64::@main_graph$async_dispatch_14_elementwise_2x2_f32_pack(%c64_i32, %c192_i32, %c256_i32, %c384_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_15::@embedded_elf_x86_64::@main_graph$async_dispatch_15_mmt4d_1x1x2x1x8x1_f32(%c320_i32, %c384_i32, %c64_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_16::@embedded_elf_x86_64::@main_graph$async_dispatch_16_unpack_elementwise_2_f32(%c64_i32, %c0_i32, %c192_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_5::@embedded_elf_x86_64::@main_graph$async_dispatch_5_elementwise_broadcast(%c192_i32, %c0_i32, %c68_i32, %c64_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.copy %arg12[%c64], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.copy %arg12[%c0], %arg12[%c260], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_18::@embedded_elf_x86_64::@main_graph$async_dispatch_18_elementwise_2_f32 {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_7::@embedded_elf_x86_64::@main_graph$async_dispatch_7_elementwise_broadcast(%c192_i32, %c4_i32, %c0_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c0], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c64], %arg12[%c264], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_8::@embedded_elf_x86_64::@main_graph$async_dispatch_8_elementwise_broadcast_2_f32(%c256_i32, %c0_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_10::@embedded_elf_x86_64::@main_graph$async_dispatch_10_elementwise_broadcast_2_f32(%c256_i32, %c64_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.dispatch @main_graph$async_dispatch_13::@embedded_elf_x86_64::@main_graph$async_dispatch_13_elementwise_broadcast(%c64_i32, %c256_i32 : i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c256], %arg12[%c384], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.dispatch @main_graph$async_dispatch_9::@embedded_elf_x86_64::@main_graph$async_dispatch_9_elementwise_broadcast(%c0_i32, %c388_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_11::@embedded_elf_x86_64::@main_graph$async_dispatch_11_elementwise_broadcast(%c64_i32, %c448_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_12::@embedded_elf_x86_64::@main_graph$async_dispatch_12_elementwise_broadcast(%c0_i32, %c64_i32, %c452_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c448], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c384], %arg12[%c264], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_14::@embedded_elf_x86_64::@main_graph$async_dispatch_14_elementwise_2x2_f32_pack(%c0_i32, %c64_i32, %c256_i32, %c384_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_15::@embedded_elf_x86_64::@main_graph$async_dispatch_15_mmt4d_1x1x2x1x8x1_f32(%c320_i32, %c384_i32, %c256_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_16::@embedded_elf_x86_64::@main_graph$async_dispatch_16_unpack_elementwise_2_f32(%c256_i32, %c192_i32, %c0_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_5::@embedded_elf_x86_64::@main_graph$async_dispatch_5_elementwise_broadcast(%c0_i32, %c64_i32, %c196_i32, %c192_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.copy %arg12[%c192], %arg12[%c256], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.copy %arg12[%c64], %arg12[%c260], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_18::@embedded_elf_x86_64::@main_graph$async_dispatch_18_elementwise_2_f32 {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_7::@embedded_elf_x86_64::@main_graph$async_dispatch_7_elementwise_broadcast(%c0_i32, %c68_i32, %c64_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c64], %arg12[%c128], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c192], %arg12[%c136], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_8::@embedded_elf_x86_64::@main_graph$async_dispatch_8_elementwise_broadcast_2_f32(%c128_i32, %c64_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_10::@embedded_elf_x86_64::@main_graph$async_dispatch_10_elementwise_broadcast_2_f32(%c128_i32, %c192_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.dispatch @main_graph$async_dispatch_13::@embedded_elf_x86_64::@main_graph$async_dispatch_13_elementwise_broadcast(%c192_i32, %c128_i32 : i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c128], %arg12[%c256], %c4 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.dispatch @main_graph$async_dispatch_9::@embedded_elf_x86_64::@main_graph$async_dispatch_9_elementwise_broadcast(%c64_i32, %c260_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_11::@embedded_elf_x86_64::@main_graph$async_dispatch_11_elementwise_broadcast(%c192_i32, %c384_i32 : i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_12::@embedded_elf_x86_64::@main_graph$async_dispatch_12_elementwise_broadcast(%c64_i32, %c192_i32, %c388_i32 : i32, i32, i32) {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
        }
      }
      stream.cmd.concurrent {
        stream.cmd.copy %arg12[%c384], %arg12[%c128], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
        stream.cmd.copy %arg12[%c256], %arg12[%c136], %c8 : !stream.resource<transient>{%c56384} -> !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_14::@embedded_elf_x86_64::@main_graph$async_dispatch_14_elementwise_2x2_f32_pack(%c64_i32, %c192_i32, %c128_i32, %c256_i32 : i32, i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_15::@embedded_elf_x86_64::@main_graph$async_dispatch_15_mmt4d_1x1x2x1x8x1_f32(%c320_i32, %c256_i32, %c64_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_16::@embedded_elf_x86_64::@main_graph$async_dispatch_16_unpack_elementwise_2_f32(%c64_i32, %c0_i32, %c128_i32 : i32, i32, i32) {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_113::@embedded_elf_x86_64::@main_graph$async_dispatch_113_elementwise_broadcast {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        rw %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_114::@embedded_elf_x86_64::@main_graph$async_dispatch_114_elementwise_2_f32 {
        ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
        wo %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384}
      }
      stream.cmd.concurrent {
        stream.cmd.dispatch @main_graph$async_dispatch_115::@embedded_elf_x86_64::@main_graph$async_dispatch_115_elementwise_broadcast_10x2_f32 {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg11[%c0 for %c256] : !stream.resource<external>{%c256}
        }
        stream.cmd.dispatch @main_graph$async_dispatch_116::@embedded_elf_x86_64::@main_graph$async_dispatch_116_elementwise_broadcast_9x2_f32 {
          ro %arg12[%c0 for %c56384] : !stream.resource<transient>{%c56384},
          rw %arg11[%c0 for %c256] : !stream.resource<external>{%c256}
        }
      }
    } => !stream.timepoint
    %9 = stream.resource.dealloca on(#hal.device.affinity<@__device_0>) await(%8) => %result_0 : !stream.resource<transient>{%c56384} => !stream.timepoint
    stream.timepoint.chain_external on(#hal.device.affinity<@__device_0>) %9 => (%arg5 : !hal.fence)
    %10 = stream.tensor.export on(#hal.device.affinity<@__device_0>) %6 : tensor<19x2xf32> in !stream.resource<external>{%c152} -> !hal.buffer_view
    %11 = stream.tensor.export on(#hal.device.affinity<@__device_0>) %5 : tensor<3xf32> in !stream.resource<external>{%c12} -> !hal.buffer_view
    util.return %10, %11 : !hal.buffer_view, !hal.buffer_view
  }
  util.func public @main_graph(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view) -> (!hal.buffer_view, !hal.buffer_view) attributes {iree.abi.stub} {
    %0 = util.null : !hal.fence
    %c-1_i32 = arith.constant -1 : i32
    %c0 = arith.constant 0 : index
    %device_0 = hal.devices.get %c0 : !hal.device
    %fence = hal.fence.create device(%device_0 : !hal.device) flags("None") : !hal.fence
    %1:2 = util.call @main_graph$async(%arg0, %arg1, %arg2, %arg3, %0, %fence) : (!hal.buffer_view, !hal.buffer_view, !hal.buffer_view, !hal.buffer_view, !hal.fence, !hal.fence) -> (!hal.buffer_view, !hal.buffer_view)
    %status = hal.fence.await until([%fence]) timeout_millis(%c-1_i32) flags("None") : i32
    util.return %1#0, %1#1 : !hal.buffer_view, !hal.buffer_view
  }
}
