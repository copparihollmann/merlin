#composite_of_5952b = #util.composite<5952xi8, [
    dense<"0x26E9733EC8181D3EA18D17BE3DFDFE3D747CA73CA916753E7724A0BEE399DBBD9A23983D8818483E2781583EE4BF9E3E5C7405BE66A108BE14DA1F3E7360B43D639B853EE1C42C3D25246CBE9FA0F43DCADF34BE569A813E99584ABD175CF93DF867823EF924EABCF77E313E33F75EBECF29E93D4DCD313E2C56943D4A47073D1D330E3D4C230A3E5EFDF0BD28928C3E57CF9FBE927E6BBD6F523F3E2E1A133E996437BE86B2863E663144BE02B97CBE444E7B3E1BCFCABDE9860CBE4DE5423E583371BE6E6E9EBEAC1D62BEEF0DFB3DC08B9E3E0BC9803EFED62C3E7F3B7FBEA4951DBE30053CBE8903EE3D29D655BE897B99BE02EBF0BC5CEBCC3D87C2D93DD4284ABEC0F50E3DD672FCB9B26E6C3E626B77BE45A5803E911E803E2594783EE8EA373E3CC16BBEC9531BBD81998D3C49F21D3EA71AB63D35FB353EAF5DFBBDE3FB7A3E30C504BD63B6C53D476567BEA75B153DAA25253E071063BE3B70933ED3F2BBBDCA9F813E1597933E757738BE943B1CBDBA39AABD9CD79E3DB52B293CD76B2A3EC2CC983EE24E0EBE839E8DBEBACFE23DC62E19BC8D6468BEAAC9463D4F6522BE79930E3E6946073ECE37013EEE6E7ABE2B2366BEFC8A653E0A539FBD9DD3E43C92C1493E71554B3ED22C32BE45E7BC3DF4419EBEEB286F3EA62544BC69B040BE17DEA4BDA646E03D8C5CD6BD5758003E67C471BE5737193E61CD193ED0C29BBE0E4B34BE3CF088BE95DDEFBC65F17A3E25CCA13BBEEC003E61F788BEC5F94EBEB25B9CBDB7BD4FBEB5F6C33D5697923E43081C3E89ADDCBDB68826BE2CC68ABDDB8D5E3E1ACC22BE5AF81DBEB33E8FBE89EA68BEA91B6E3EC4D870BE95DB36BE5AAE97BE7604DABD804F9FBDC52AC13DCB1A83BD1CDC0D3E62E93CBEA7DF5BBE326C1DBE54D98EBE26F78A3D724C123ED9B278BDFA1E92BCBEDC8CBEEB44BBBCC329173E0709373ECECAB2BCB7B227BEFCE6E8BD48F70EBE587E993EFA47543E67E178BE19B129BE4415393ECF4F4EBDCFF12D3D2098A4BDA34415BE8B2F33BEC7A7243E294766BED3C09B3E237C0A3DFBE093BEA11B373DD7BCC3BD000B96BCF200693EADE6923E8CF61C3DE316313D6FD40F3E4A6CF53C8D96FC3D5306BE3D56F47B3E46858B3ED3B7B7BD5D8F1E3E78ABF4BD297A343E3808613E9639983EA4E48B3EA98B42BD16E28D3E8BE34F3E596017BEFD6360BED37A07BE8BEC40BED60173BE9F2C65BEB439A9BD6B8D353E50622A3ED932CA3C0C03423E7A181FBD37409EBED74084BE9B32993D8F1B3FBD086A7E3E69FD5D3E38459BBD7BF75D3E0945923EC60E66BE403D50BEF6C070BE400E8CBEE179813E72406ABE7AEE75BE6AD485BD01B5453D2380EFBB407842BE775E0E3E2E7977BE64FD33BEDC2421BEE66D5E3ED9CD523DAD7A883EA2DBB3BCD5F7593E40B921BDDD498FBE96D69C3E0B7FFEBDB6348BBE37F4793E2B97A63DDFA740BD7D21D93C36007A3EE09540BE6230093E2A12BB3C8548FFBD0D75543EF051F7BCECD3A93D3E9538BE51F7953B7B42653E7A01833D014F85BED1DD92BED2F98BBEDC7B493E77B1653E26F705BE591F68BEE07D7E3E4B6F2EBE3F78A13E0236213EE516F63A06443ABEE2D5233E87D69F3DE591323E91EE30BD4234A13EF48D7CBDBA6C86BE7A53863D2614D93D7CCAEB3D838635BEC2037ABEBCDC963E71E11E3EF9087B3E6985CEBDF725D13D5301EBBD6DE1A0BEE0D8CBBD2A7A8ABE5E7B4E3B1CE63A3E7E23BD3DE5574A3E12AF0C3E4DD679BE15A078BE33B4563E9202813D27A8E43D8F03483E"> : tensor<32x10xf32>,
    dense<[0.0962907821, -0.155916616, -2.659500e-01, -0.253344834, -0.238115147, -0.204406232, 5.3752563E-4, -0.247130185, -0.111521207, -0.20010379, -0.30845052, 0.15546523, 0.0545346662, 0.0396357551, 0.145887375, 0.267154038, 0.313625038, -0.0588332526, -0.239435181, 0.0780267491, 0.312959671, 0.260689229, 0.0252451561, 0.244547799, 0.0530805327, -9.820750e-02, 0.232707471, -0.00378808728, -0.296180874, -0.262859076, -0.0734717101, 0.167452633]> : tensor<32xf32>,
    dense<"0x5BA03E3C8296C13C6ECED53D0A92C63D7173E2372DE484BD2C317BBC370609BE0A865BBD2F1C053D5FB065BD5D8C863C168C82BD6F25163ED0ADC2BC053B0B3EFFD51E3E7E21B0BD5222183E71C0B3BDB342F6BDF978043DDB24EC3CBF71033ED78E31BE0D9C11BE6E2F96BCCF2014BE178A2FBEED2BC2BC40A2863D064CAF3DDF3D353B7254FCBD462F663CB258033E9F8614BEA944083EF301B83D1D9219BECE9508BED999FB3D2A92B4BD8F18EE3CA733BDBD8B812C3E4142F5BDA6E118BE920E6E3D921D0E3E24DE5F3DDEF1953DD70DEABD44C792BD3B38F53B3D1FB43D7719C83DCED7A3BBF6D67C3C880C043E7AA1ACBDA3642BBE1425203E3FA2043E7F9B07BED5CF2FBE9973173E91712C3E14640B3D021BF1BDA5FC19BE280933BCC25217BEBF9EBD3C69A41BBEE9BD2A3EB86A2ABB07E7393C0726DDBDFA25193D5EE18F3C49F86F3D48720A3E6E7F28BECECBC93C02B29D3D02439E3C2906033E149092BD4F882FBED7D895BD7DB7BABCD48CC3BD733086BDB73D14BE83371ABE9565023DB31864BCE5EB593942C2E53D15572ABE3E8FD7BD972707BE65E3B0BDC694BABD93AD24BDC2C91FBE109CD83CF2AF13BE8F43E6BC91A0403C4BE4553DC0B9D23C7D64ACBDD898C83D2DE4F43C8941F13887C9F6BD1DE621BD4E6AA53DC06A113E1ADEB6BD1601D0BDA090933D3EE368BD2E370A3DB4B12CBE12A3363D7A4F0E3E6E632ABEE1C29F3B0F4DE43DD21F353B284C2B3DBEFAE63DCAFC193E3BF5573D6192063ED39FAB3DF6B9433D2631413D8725EA3D5678CFBC8BAD00BD9C3126BE3C8DF6BBC700E0BD91C3E23DB1D128BE9B289D3B1862EB3DDDD026BE31312C3E1C83E63D3990253E651034BE728F08BDA5AF323D1BFCB5BD4A10293E0F68003E817866BD69DEBDBD0EDB223E50EA96BDE2CF88BCFB2A133E7FC8B13DDB58293E34591DBE683C33BE2BFCE4BD51FB2BBE99D20FBED91AA2BD7808733D28E5873D3581D13C453A93BDC619B33CAFAE34BD94B0283D067AC13D145D0ABE1E9D943D7286833DE907F0BD52B9BFBDE9A00ABEEAE5863D5A3816BE7A6B6C3DF0D4DD3CFFF71F3E20623BB9FDF62ABEC05504BE7010C23DA50E1D3DDD825A3DC06421BEA53EB53DDC83D1BCE329A23B0266EABC34606DBD6ECC2EBE8441183EC3F6063D8A7B943D9DF29ABC76ABCCBD4177FFBD15F2C2BDA67C8FBCE3878DBD6CAA2C3E94F111BC447102BEC46B053E070912BEB8A5803D52BE2ABE259ADCBC5898133E05F5E6BDB90F9EBD30FD323E7BA9963D3A8D19BE7E3B6A3D897FAABD6F3A9EBCA5E614BD9C49F5BDB426483D1D519DBD013404BEE8AD04BEAD62F6BDCB1A023E60FA203E53B2B5BDFB5E27BE3CDD2D3D758C29BECF73B1BCE7FB0EBE8AEA5F3DA190843D0A2CDDBDBBDDC0BB099B63BDB2A917BE35B01BBE290BD2BDD38087BD97002EBDD3DA643D76A32B3E0B482BBB4C0107BE2207CDBD90EAC1BD003933BE5A1F533D1271CCBD2C99283E3D6923BECC59A7BD6804333D3D2C8BBDF7331F3EEB87FD3C163A84BB2C37753C1089C93D78682EBDC66D8ABD8433143E2BC4CEBD1714B6BD52E6D6BD7963093EB5462DBE5FD58FBDDE1C333D550E7E3DDE8EEA3DB11B053E1EE055BD8406CFBD3D5E603D03510EBEC2EC9CBDBB8E113E8A2F3C3CE603DF3D05EA8B3DAC6617BE0F7308BE5AC1BDBC2B51273C4156F2BD099615BE09C4213E6761DFBC4EE21C3EF0E0343EF96A2B3E4211783D02DE2ABE5591783DF38EAEBD834F243E70E76DBD65559EBD9C74D83DDC342BBE8460BEBD031E33BEFC7785BDEF1BD8BDC5FE153E43761ABE4FB0243EB8F9E5BD4564713CB1970ABE6023FD3D6F4F0E3E6139DEBD88AFC1BDCCE1893DF6BF05BE401B41BB2A29F0BDBBB223BE493DCE3DD407CF3DEFFD323D2625163E6B6CEC3D8475D83D8357233EB8F2B03DB41E0DBC0FF3583D76B106BEFCCB2BBE0CFA103D20B3C73D1FB7D6BCFB895EBDD17F983DE59B463DD5CD32BE319B453D34F04DBC4F99A0BB3BC6873CE2A036BD930E24BEDF5199BDA1F5053E559E8CBD094532BE6C4F07BE1FDBA33D9D97233DC2F634BE5FCDB53D2FBEF53C70C6B23D1478303E3B6D333E0DB572BDBB54F23DDA8084BDB9132B3E0CB691BCAF116FBD3819B8BDD814E43D511F0EBE1FB532BEB252023E812573BD017099BDFC8C123E269BA13DC3AA033EFB18283E29103CBC94CFD33D2462513D5D0F09BE0BB8D73D770B1CBDD5853B3B6E7CBB3DA29F1BBCF85427BDE5C687BB84FD753D6A4B14BE857D1E3EF7AA9C3D0B1A3F3DD77A393C2CFF003E7E0700BEACC12D3E7D35913D977077BD75E5253E6669B63DAEF0853DC0FAA83D811D0B3E1BA525BE9656AD3DD34312BD3D1733BEEF04F7BD235FBC3CFDBB29BE9D7D003EC4D28E3C01EE253E5C6C00BE840A9ABD552830BEF42292BDDC0B90BD9058AF3DE1807FBC67F90CBDC0F897BC428FEF3D9C6714BDF21C1CBE339A45BD5CD48E3C436CAFBC7C60BEBD52AFE13D06D297BD7F46A1BDA838C2BD4EC3CEBDE236CD3D2ECD2A3E36B62C3E842A5FBD6386BFBDD07438BD33A0173E0318ED3D0515083E10B42EBD0A61BBBD0B53303CF947FE3D114307BE1247033EA97104BD4F3D503CAC0DDCBD307C183EB78C5B3D473D1BBE0596FABD98FD2BBDE20DDABC76B6CDBDE39F1E3E54CB2FBE8759AA3D5282DC3C5EE91DBE5CE0313E4C7725BD818BA1BD6540303D6687F0BDC4902CBE62D1B9BD5F3200BE6F9014BEDFDF263E13791F3E06E0E7BDD2752B3E138C17BDF74891BD376F9EBD6B2228BEA0F3303D2BBAB9BD829F0A3E0B2F9C3D078C74BD14620CBE2766D93D346B303EC52F10BCED92F8BCD976343E17092CBED18D153E831531BE5DD12C3EDB1314BEE766D33C11D695BD75AE03BE7BF402BE16392A3EF93402BEE8C9343C349D063DDFC027BE158315BE2F53093EFBDE253EF00040BCBD812B3E3B0118BE851AAA3D83F0DE3DE2A7DDBDAF720FBD053F06BEEC5A80BDDE7DCE3D4382CCBD6C3917BEC7612FBE6AEBBFBC959CD6BD0D74073EC2DC98BDC936D13CA4590C3DEB5D303CF227E43C9FAC0B3E19887CBD340D59BDD6EF0DBE544D6E3D99D23BBD61F06ABBC5D9BBBD7AC00ABE8FC3D9BD38F3AD3D6F5D2FBEDC51A0BDB1940CBE07556CBD60F2843D20EA11BE9788123EE9EBF6BDFFE62B3EE106963DC13427BE0F99C3BC2FED1F3E356556BD094A9EBD4E23063E23EDD0BDB8E1873C3CA22A3E0CA3323DB023C8BDAC4C15BE65A72FBB20AEE33DAF430F3D35EE243DEFC544BDA59FD8BCA0C1EC3D34BB793CD969E7BDA66F03BEA6955EBD375BC2BDFB9EEBBD624A063CDE7FD4BD727E493DF35E0B3D15A6DDBDF1ABC13D04BE02BE3A471ABD5B860A3E7284713D5345263E145F29BB5C44583DE3D5C83DFB0BF33D42AC443D0C20A1BDCFF03EBD65606ABCDD348EBC1F09143EB84655BDC6882A3C5EAC4CBD5500023D6BF8933B56E096BC19D7B2BD069D63BD82511CBE7BE816BE4194DEBDC9CEF8BD93F8A3BD6DE4093D084128BDF80C533B34B4973C585A653CFB699BBC5F6CFDBDC57E46BD12C589BB9DE46CBD3F0D083EF8FD193EFF2ABA399A661DBEBAD485BD7EC933BE1408D63DC237E6BD2DEC97BD9B88CA3B51F3F3BCE5EAA83C4CE818BE21D412BE6DF606BEB5737F3B9ACC9F3DBCEA1CBEADDA1E3E27F37DBD818C26BC8BFFAEBC0C801D3EB885173E5FF68D3D6E28843D7CC2923DB8B3883D8F1D213E685F88BDD2C03D3C609CA73D58313D3DFDA5923D2F2DBEBD054D0F3E7230813D12DBBDBDD9DC20BE61EAF5BD52E5D93D10D382BDCBC9D0BDEB28B83DA8C71E3D913064BDE3FA533D77FAF73DCED9363D64D408BEA29253BDE54CD7BD1309C1BD4B6AB4BDEB46AF3D8AD2223E6CA747BD65EFA9BD7865313DAD46CCBD4ADEB4BD3D4E21BCD8A1263E9152F23C6091DFBD59ABCFBD77978FBD9D70983D673623BE1FD9153ECCC5DC3D1328E3BD555AAD3D49D8223E3DAB2FBE860FF2BC898CA0BDBEDA52BDBF557F3DDCBEE83D5C45F73D2A5F7ABD1F6FA93DE367A73DFC95E1BCB05F813DE8CDA33D8D74BBBCFF8523BE4C897BBD53B0293EA6BA94BDC4E28ABDD0DCCBBC824523BECAB0EBBDDCCB283E84B643BD34B3753D183745BDC87931BE2F43EA3C646CF33D896C6D3DCD5871BD9ADDDD3CFC7407BE1847AD3DA5212FBEF32F2FBEA4E624BE825115BE57D016BE2A47233E1A71EABA38F1FFBA40B08EBC076EE83D174E2E3E09F4CFBC2A6733BE835DA53C5A5BE5BDEDEDCBBD4C02B5BCE41518BE48802B3D694CD53D4ADD09BC1151863DDC49DDBD00E9293E275BE7BDFBB40F3E589D803DA00A533DC3D9E23D2219273E3D86213E58C7D13BFFE989BDE64D23BEBC5C323EA84FEC3D84C7913D090A9BBDEFBD55BD04AE3DBD1D8C2EBE710C5FBD4DD6B2BDD886FD3D1B0AFB3BD90B17BE5D9E0C3D92A8153EDC721DBEF9941DBD5E0CF3BD7B934DBCA0D8F73D6C5E183E457B04BD5AC0073DD98D0DBE958CA8BC6A55C83DC121A2BDCD236F3C11EF1F3ECECDB0BDD35F11BD9B58753D2440B6BDF425993D25B3DEBCE4C434BDAA59213DD9D69C3D559C1EBE291D32BE391D1A3DD957A23C998497BD723415BEBC2F303E0F941D3E4D5C7C3DEBF5DD3D7ADBAB3CED65F13D30A1D03DC795303CA63A45BDD021B43DB69B2C3EA9B28E3DE6DDA0BDCCD12D3EF9AFE7BDB574CEBD0F090CBE894CAABD403960BCD95A51BD568E3CBDA884D9BC9C17AD3D49AAE43DA5A5F5BDE2B9143EB338A0BCA87033BEB1B2213D70E12CBE269C09BCCE100ABE921E2F3D46A1C23D6722063E7CA09F3DCAF4E43BA795113E5B02B03D48FA1E3DCE4AA53D74DFD7BD46CB073E69C68F3DA24E0A3E72A474BC708AB1BD560C90BD77EB35BC56DFF6BDA10E67BD873428BD699F303C9B6C1A3E9925E33DD7AF1D3D3EC91D3EF25619BCA0A269BCED120FBEF52A093EA7FA5ABDA2B2F43DC4E60EBE3CF3E93A115ADFBA9A601C3EA9185F3DBFB41D3D11AA853DA58C073D9D80FF3DD71A15BD9BE729BEE4E1DE3D5BA13D3B19EAE3BD8D6C183E88C8703D88BFEFBDA8C6E73D39F2F73DC67D103EA2A341BC2C1698BD047FCABCD72A363C24161D3E50571ABD1ECE113EBC3B92BC53087E3D7A255B3D9320303D9923C6BA342E423D6D8DDA3C9B1AFA3D838627BD4154C4BD73F8CA3DFFAD733D605333BE94C2253E865A1F3E06C0DFBCD6AD853D4C30F13C728D823CEAA1963D9B232FBD1335323EA2C1C0BDF4B014BE6C2CEABC2679AE3CF8CCBABDADD5253D5368ACBDA728B2BCDAA9A43D74E2B0BDBC6F973D6041203E79FFE4BD78EED13DC4B3E6BC0462CBBD33DC173CA3B4333E363E17BEE3BE2C3E87C662BCFFF68CBD52D312BEBBBEC4BC11E0143E4207063E314DFBBC8383BFBC1156D3BD6F3D86BC1185C03D1FC3333E9AC4A33DB1940B3EC23798BDEEF4F73D77D6D43BD8E1DD3CD92F813D1BFE083EBC91243E6EF3E83D0EF920BDD88E9C3D366BC0BD28BC783D01C96EBDADF92C3C938017BE95DA213E5B841ABE4F5529BE894A04BE785F2A3EEBC01C3E292EDD3D957CF23D65E1F13DB50ADDBDDC6D1ABE3F9F2A3E94FFE93DB88AE0BD50C8033E738E7ABC9C2CA7BD73BA0EBEF429EDBDABEAECBC9E37DF3D8421B2BD1744ECBD3B922D3E75B1F53C09E52FBEF59166BDDCE00DBE7E1A9C3C3E611B3E6B961A3EB09DCE3D069A263EB1AFF93D5086C93D05B593BC8A7D6F3DD6CDB9BBAF4E053ECE3A073E638A1ABE"> : tensor<32x32xf32>,
    dense<[0.162499294, -0.0801915451, 0.153941914, 0.0219113454, -0.140127942, -0.12445996, -0.149894521, 0.162132412, 0.105042696, -0.0859371721, 6.965030e-02, -0.141210482, -0.0333313271, -0.0386215597, -0.0218895562, 0.161435679, -0.0469571315, -0.0064728288, 0.138868779, 0.0946954563, -0.118682154, 0.125606269, 0.142559305, 0.101437077, 0.132687211, -0.0944273397, 0.160846531, -0.0927824079, -0.130839854, -0.0758508593, 0.176237047, -0.0873066708]> : tensor<32xf32>,
    dense<[[-0.148675621, -0.00800752174, -0.154642224, 0.0714647844, -0.158757433, -0.0998362749, -0.0515264794, 0.0373864658, 0.0141011765, -0.106712803, 0.172995389, -0.159487143, -0.134175375, -0.0625612437, 0.0190407019, -0.167385533, -0.118601315, -0.14933382, -0.126252428, 0.0328095295, 0.161362395, 0.166322604, 0.105357215, -0.0199586395, -0.0860766768, 0.157569975, 0.122067556, -0.0260244776, 0.0585044622, 0.0506174564, -0.163079426, -0.0315102674], [0.102913834, 0.142172322, -0.0771354958, 0.0138733936, 0.00633722125, -7.187530e-02, 0.135073066, 0.0433540829, 0.091250725, -0.0407002196, 0.132568911, -0.128669098, 0.0537779666, 0.0500060953, 0.0648744926, -0.17312856, 0.174260497, -0.0767506734, -0.150335029, -0.0197679456, -0.114997737, 0.0462276936, -0.0195699614, -0.0607960708, -0.00727524143, 0.0066478434, 0.011014699, 8.34507591E-6, -0.082545422, -0.0434851795, 0.127168015, -0.0459757186]]> : tensor<2x32xf32>,
    dense<[0.150014639, -0.112291597]> : tensor<2xf32>,
    dense<0> : vector<56xi8>,
]>
#encoding = #iree_encoding.layout<[#iree_cpu.cpu_encoding_resolver<configuration = {encoding_info = {innerDimsPos = [0, 1], innerTileSizes = [7, 1], outerDimsPerm = [0, 1]}}>]>
#encoding1 = #iree_encoding.layout<[#iree_cpu.cpu_encoding_resolver<configuration = {encoding_info = {innerDimsPos = [0], innerTileSizes = [7], outerDimsPerm = [0]}}>]>
#encoding2 = #iree_encoding.layout<[#iree_cpu.cpu_encoding_resolver<configuration = {encoding_info = {innerDimsPos = [0, 1], innerTileSizes = [2, 1], outerDimsPerm = [0, 1]}}>]>
#encoding3 = #iree_encoding.layout<[#iree_cpu.cpu_encoding_resolver<configuration = {encoding_info = {innerDimsPos = [0], innerTileSizes = [2], outerDimsPerm = [0]}}>]>
#encoding4 = #iree_encoding.layout<[#iree_cpu.cpu_encoding_resolver<configuration = {encoding_info = {innerDimsPos = [0, 1], innerTileSizes = [32, 1], outerDimsPerm = [0, 1]}}>]>
#executable_target_embedded_elf_riscv_64 = #hal.executable.target<"llvm-cpu", "embedded-elf-riscv_64", {cpu = "", cpu_features = "+m,+a,+f,+d,+c,+v,+zvl256b,+zfh,+zba,+zbb,+zbc,+zbs,+zicbom,+zicboz,+zicbop,+zihintpause", data_layout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128", iree.encoding.resolver = #iree_cpu.cpu_encoding_resolver<>, loop_vectorization = true, max_stack_allocation_size = 32768 : i64, native_vector_size = 32 : i64, target_abi = "lp64d", target_triple = "riscv64-unknown-unknown-eabi-elf", ukernels = "all"}>
#map = affine_map<(d0, d1, d2) -> (d0, d2)>
#map1 = affine_map<(d0, d1, d2) -> (d1, d2)>
#map2 = affine_map<(d0, d1, d2) -> (d0, d1)>
#map3 = affine_map<(d0, d1) -> (d1)>
#map4 = affine_map<(d0, d1) -> (d0, d1)>
#device_target_local = #hal.device.target<"local", [#executable_target_embedded_elf_riscv_64]> : !hal.device
#encoding5 = #iree_encoding.encoding<operand_index = 0 : index, op_type =  matmul, element_types = [f32, f32, f32], user_indexing_maps = [#map, #map1, #map2], iteration_sizes = [?, 32, 10]>
#encoding6 = #iree_encoding.encoding<operand_index = 1 : index, op_type =  matmul, element_types = [f32, f32, f32], user_indexing_maps = [#map, #map1, #map2], iteration_sizes = [?, 32, 10]>
#encoding7 = #iree_encoding.encoding<operand_index = 2 : index, op_type =  matmul, element_types = [f32, f32, f32], user_indexing_maps = [#map, #map1, #map2], iteration_sizes = [?, 32, 10]>
#encoding8 = #iree_encoding.encoding<operand_index = 0 : index, op_type =  matmul, element_types = [f32, f32, f32], user_indexing_maps = [#map, #map1, #map2], iteration_sizes = [?, 32, 32]>
#encoding9 = #iree_encoding.encoding<operand_index = 1 : index, op_type =  matmul, element_types = [f32, f32, f32], user_indexing_maps = [#map, #map1, #map2], iteration_sizes = [?, 32, 32]>
#encoding10 = #iree_encoding.encoding<operand_index = 2 : index, op_type =  matmul, element_types = [f32, f32, f32], user_indexing_maps = [#map, #map1, #map2], iteration_sizes = [?, 32, 32]>
#encoding11 = #iree_encoding.encoding<operand_index = 0 : index, op_type =  matmul, element_types = [f32, f32, f32], user_indexing_maps = [#map, #map1, #map2], iteration_sizes = [?, 2, 32]>
#encoding12 = #iree_encoding.encoding<operand_index = 1 : index, op_type =  matmul, element_types = [f32, f32, f32], user_indexing_maps = [#map, #map1, #map2], iteration_sizes = [?, 2, 32]>
#encoding13 = #iree_encoding.encoding<operand_index = 2 : index, op_type =  matmul, element_types = [f32, f32, f32], user_indexing_maps = [#map, #map1, #map2], iteration_sizes = [?, 2, 32]>
#encoding14 = #iree_encoding.encoding<operand_index = 2 : index, op_type =  matmul, element_types = [f32, f32, f32], user_indexing_maps = [#map, #map1, [#map2, #map3]], iteration_sizes = [?, 32, 10]>
#encoding15 = #iree_encoding.encoding<operand_index = 2 : index, op_type =  matmul, element_types = [f32, f32, f32], user_indexing_maps = [#map, #map1, [#map2, #map3]], iteration_sizes = [?, 32, 32]>
#encoding16 = #iree_encoding.encoding<operand_index = 2 : index, op_type =  matmul, element_types = [f32, f32, f32], user_indexing_maps = [#map, #map1, [#map2, #map3]], iteration_sizes = [?, 2, 32]>
module attributes {stream.affinity.default = #hal.device.affinity<@__device_0>} {
  util.global private @__device_0 = #device_target_local
  util.global private @__hoisted_tensor_32x10xf32__encoded : !stream.resource<constant>
  stream.executable private @_encoding_0 {
    stream.executable.export public @_encoding_0_encode_32x10xf32_to_32x10xf32 workgroups() -> (index, index, index) {
      %x, %y, %z = iree_tensor_ext.dispatch.workgroup_count_from_slice()
      stream.return %x, %y, %z : index, index, index
    }
    builtin.module {
      func.func @_encoding_0_encode_32x10xf32_to_32x10xf32(%arg0: !stream.binding {stream.alignment = 64 : index}, %arg1: !stream.binding {stream.alignment = 64 : index}) {
        %c0 = arith.constant 0 : index
        %0 = stream.binding.subspan %arg0[%c0] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<32x10xf32>>
        %1 = stream.binding.subspan %arg1[%c0] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<32x10xf32, #encoding>>
        %2 = iree_tensor_ext.dispatch.tensor.load %0, offsets = [0, 0], sizes = [32, 10], strides = [1, 1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<32x10xf32>> -> tensor<32x10xf32>
        %3 = iree_encoding.set_encoding %2 : tensor<32x10xf32> -> tensor<32x10xf32, #encoding>
        iree_tensor_ext.dispatch.tensor.store %3, %1, offsets = [0, 0], sizes = [32, 10], strides = [1, 1] : tensor<32x10xf32, #encoding> -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<32x10xf32, #encoding>>
        return
      }
    }
  }
  stream.executable private @_encoding_1 {
    stream.executable.export public @_encoding_1_encode_32xf32_to_32xf32 workgroups() -> (index, index, index) {
      %x, %y, %z = iree_tensor_ext.dispatch.workgroup_count_from_slice()
      stream.return %x, %y, %z : index, index, index
    }
    builtin.module {
      func.func @_encoding_1_encode_32xf32_to_32xf32(%arg0: !stream.binding {stream.alignment = 64 : index}, %arg1: !stream.binding {stream.alignment = 64 : index}, %arg2: i32, %arg3: i32) {
        %0 = arith.index_castui %arg2 : i32 to index
        %1 = arith.index_castui %arg3 : i32 to index
        %2:2 = util.assume.int 
            %0[<umin = 1280, umax = 1280, udiv = 1280>, <umin = 5504, umax = 5504, udiv = 5504>], 
            %1[<umin = 1408, umax = 1408, udiv = 1408>, <umin = 6080, umax = 6080, udiv = 6080>]
          : index, index
        %3 = stream.binding.subspan %arg0[%2#0] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<32xf32>>
        %4 = stream.binding.subspan %arg1[%2#1] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<32xf32, #encoding1>>
        %5 = iree_tensor_ext.dispatch.tensor.load %3, offsets = [0], sizes = [32], strides = [1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<32xf32>> -> tensor<32xf32>
        %6 = iree_encoding.set_encoding %5 : tensor<32xf32> -> tensor<32xf32, #encoding1>
        iree_tensor_ext.dispatch.tensor.store %6, %4, offsets = [0], sizes = [32], strides = [1] : tensor<32xf32, #encoding1> -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<32xf32, #encoding1>>
        return
      }
    }
  }
  stream.executable private @_encoding_2 {
    stream.executable.export public @_encoding_2_encode_32x32xf32_to_32x32xf32 workgroups() -> (index, index, index) {
      %x, %y, %z = iree_tensor_ext.dispatch.workgroup_count_from_slice()
      stream.return %x, %y, %z : index, index, index
    }
    builtin.module {
      func.func @_encoding_2_encode_32x32xf32_to_32x32xf32(%arg0: !stream.binding {stream.alignment = 64 : index}, %arg1: !stream.binding {stream.alignment = 64 : index}) {
        %c1408 = arith.constant 1408 : index
        %c1600 = arith.constant 1600 : index
        %0 = stream.binding.subspan %arg0[%c1408] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<32x32xf32>>
        %1 = stream.binding.subspan %arg1[%c1600] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<32x32xf32, #encoding>>
        %2 = iree_tensor_ext.dispatch.tensor.load %0, offsets = [0, 0], sizes = [32, 32], strides = [1, 1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<32x32xf32>> -> tensor<32x32xf32>
        %3 = iree_encoding.set_encoding %2 : tensor<32x32xf32> -> tensor<32x32xf32, #encoding>
        iree_tensor_ext.dispatch.tensor.store %3, %1, offsets = [0, 0], sizes = [32, 32], strides = [1, 1] : tensor<32x32xf32, #encoding> -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<32x32xf32, #encoding>>
        return
      }
    }
  }
  stream.executable private @_encoding_3 {
    stream.executable.export public @_encoding_3_encode_2x32xf32_to_2x32xf32 workgroups() -> (index, index, index) {
      %x, %y, %z = iree_tensor_ext.dispatch.workgroup_count_from_slice()
      stream.return %x, %y, %z : index, index, index
    }
    builtin.module {
      func.func @_encoding_3_encode_2x32xf32_to_2x32xf32(%arg0: !stream.binding {stream.alignment = 64 : index}, %arg1: !stream.binding {stream.alignment = 64 : index}) {
        %c5632 = arith.constant 5632 : index
        %c6272 = arith.constant 6272 : index
        %0 = stream.binding.subspan %arg0[%c5632] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<2x32xf32>>
        %1 = stream.binding.subspan %arg1[%c6272] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<2x32xf32, #encoding2>>
        %2 = iree_tensor_ext.dispatch.tensor.load %0, offsets = [0, 0], sizes = [2, 32], strides = [1, 1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<2x32xf32>> -> tensor<2x32xf32>
        %3 = iree_encoding.set_encoding %2 : tensor<2x32xf32> -> tensor<2x32xf32, #encoding2>
        iree_tensor_ext.dispatch.tensor.store %3, %1, offsets = [0, 0], sizes = [2, 32], strides = [1, 1] : tensor<2x32xf32, #encoding2> -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<2x32xf32, #encoding2>>
        return
      }
    }
  }
  stream.executable private @_encoding_4 {
    stream.executable.export public @_encoding_4_encode_2xf32_to_2xf32 workgroups() -> (index, index, index) {
      %x, %y, %z = iree_tensor_ext.dispatch.workgroup_count_from_slice()
      stream.return %x, %y, %z : index, index, index
    }
    builtin.module {
      func.func @_encoding_4_encode_2xf32_to_2xf32(%arg0: !stream.binding {stream.alignment = 64 : index}, %arg1: !stream.binding {stream.alignment = 64 : index}) {
        %c5888 = arith.constant 5888 : index
        %c6528 = arith.constant 6528 : index
        %0 = stream.binding.subspan %arg0[%c5888] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<2xf32>>
        %1 = stream.binding.subspan %arg1[%c6528] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<2xf32, #encoding3>>
        %2 = iree_tensor_ext.dispatch.tensor.load %0, offsets = [0], sizes = [2], strides = [1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<2xf32>> -> tensor<2xf32>
        %3 = iree_encoding.set_encoding %2 : tensor<2xf32> -> tensor<2xf32, #encoding3>
        iree_tensor_ext.dispatch.tensor.store %3, %1, offsets = [0], sizes = [2], strides = [1] : tensor<2xf32, #encoding3> -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<2xf32, #encoding3>>
        return
      }
    }
  }
  util.initializer {
    %c6080_i32 = arith.constant 6080 : i32
    %c5504_i32 = arith.constant 5504 : i32
    %c1408_i32 = arith.constant 1408 : i32
    %c1280_i32 = arith.constant 1280 : i32
    %c0 = arith.constant 0 : index
    %c6592 = arith.constant 6592 : index
    %c0_i64 = arith.constant 0 : i64
    %c5952 = arith.constant 5952 : index
    %0 = stream.timepoint.immediate => !stream.timepoint
    %buffer_cst = util.buffer.constant {alignment = 64 : index} : !util.buffer = #composite_of_5952b
    %did_map, %result = stream.resource.try_map on(#hal.device.affinity<@__device_0>) %buffer_cst[%c0] : !util.buffer -> i1, !stream.resource<constant>{%c5952}
    cf.cond_br %did_map, ^bb2(%0, %result : !stream.timepoint, !stream.resource<constant>), ^bb1
  ^bb1:  // pred: ^bb0
    %1 = stream.resource.alloc uninitialized on(#hal.device.affinity<@__device_0>) : !stream.resource<constant>{%c5952}
    %file = stream.file.constant on(#hal.device.affinity<@__device_0>) %buffer_cst[%c0 for %c5952] : !util.buffer{%c5952} -> !stream.file
    %2 = stream.file.read on(#hal.device.affinity<@__device_0>) await(%0) => %file[%c0_i64], %1[%c0], %c5952 : !stream.file -> !stream.resource<constant>{%c5952} => !stream.timepoint
    cf.br ^bb2(%2, %1 : !stream.timepoint, !stream.resource<constant>)
  ^bb2(%3: !stream.timepoint, %4: !stream.resource<constant>):  // 2 preds: ^bb0, ^bb1
    %result_0, %result_timepoint = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) : !stream.resource<constant>{%c6592} => !stream.timepoint
    %5 = stream.timepoint.join max(%3, %result_timepoint) => !stream.timepoint
    %6 = stream.cmd.execute once on(#hal.device.affinity<@__device_0>) await(%5) => with(%4 as %arg0: !stream.resource<constant>{%c5952}, %result_0 as %arg1: !stream.resource<constant>{%c6592}) {
      stream.cmd.concurrent {
        stream.cmd.dispatch @_encoding_0::@_encoding_0_encode_32x10xf32_to_32x10xf32 {
          ro %arg0[%c0 for %c5952] : !stream.resource<constant>{%c5952},
          wo %arg1[%c0 for %c6592] : !stream.resource<constant>{%c6592}
        }
        stream.cmd.dispatch @_encoding_1::@_encoding_1_encode_32xf32_to_32xf32(%c1280_i32, %c1408_i32 : i32, i32) {
          ro %arg0[%c0 for %c5952] : !stream.resource<constant>{%c5952},
          wo %arg1[%c0 for %c6592] : !stream.resource<constant>{%c6592}
        }
        stream.cmd.dispatch @_encoding_2::@_encoding_2_encode_32x32xf32_to_32x32xf32 {
          ro %arg0[%c0 for %c5952] : !stream.resource<constant>{%c5952},
          wo %arg1[%c0 for %c6592] : !stream.resource<constant>{%c6592}
        }
        stream.cmd.dispatch @_encoding_1::@_encoding_1_encode_32xf32_to_32xf32(%c5504_i32, %c6080_i32 : i32, i32) {
          ro %arg0[%c0 for %c5952] : !stream.resource<constant>{%c5952},
          wo %arg1[%c0 for %c6592] : !stream.resource<constant>{%c6592}
        }
        stream.cmd.dispatch @_encoding_3::@_encoding_3_encode_2x32xf32_to_2x32xf32 {
          ro %arg0[%c0 for %c5952] : !stream.resource<constant>{%c5952},
          wo %arg1[%c0 for %c6592] : !stream.resource<constant>{%c6592}
        }
        stream.cmd.dispatch @_encoding_4::@_encoding_4_encode_2xf32_to_2xf32 {
          ro %arg0[%c0 for %c5952] : !stream.resource<constant>{%c5952},
          wo %arg1[%c0 for %c6592] : !stream.resource<constant>{%c6592}
        }
      }
    } => !stream.timepoint
    %7 = stream.timepoint.await sync %6 => %result_0 : !stream.resource<constant>{%c6592}
    util.global.store %7, @__hoisted_tensor_32x10xf32__encoded : !stream.resource<constant>
    util.return
  }
  stream.executable private @main_graph$async_dispatch_0 {
    stream.executable.export public @main_graph$async_dispatch_0_matmul_like_Dx32x10_f32 workgroups(%arg0: index) -> (index, index, index) {
      %x, %y, %z = iree_tensor_ext.dispatch.workgroup_count_from_slice(%arg0)
      stream.return %x, %y, %z : index, index, index
    }
    builtin.module {
      func.func @main_graph$async_dispatch_0_matmul_like_Dx32x10_f32(%arg0: !stream.binding {stream.alignment = 64 : index}, %arg1: !stream.binding {stream.alignment = 64 : index}, %arg2: !stream.binding {stream.alignment = 64 : index}, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32) {
        %c1408 = arith.constant 1408 : index
        %c0 = arith.constant 0 : index
        %cst = arith.constant 0.000000e+00 : f32
        %c32_i64 = arith.constant 32 : i64
        %0 = arith.extui %arg4 : i32 to i64
        %1 = arith.shli %0, %c32_i64 : i64
        %2 = arith.extui %arg3 : i32 to i64
        %3 = arith.ori %2, %1 : i64
        %4 = arith.index_castui %3 : i64 to index
        %5 = arith.extui %arg6 : i32 to i64
        %6 = arith.shli %5, %c32_i64 : i64
        %7 = arith.extui %arg5 : i32 to i64
        %8 = arith.ori %7, %6 : i64
        %9 = arith.index_castui %8 : i64 to index
        %10:2 = util.assume.int 
            %4<umin = 0, umax = 360287970189639680, udiv = 1280>, 
            %9<umin = 0, umax = 9007199254740991>
          : index, index
        %11 = stream.binding.subspan %arg1[%c0] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<32x10xf32, #encoding>>
        %12 = stream.binding.subspan %arg1[%c1408] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<32xf32, #encoding1>>
        %13 = iree_tensor_ext.dispatch.workload.ordinal %10#1, 0 : index
        %14 = stream.binding.subspan %arg0[%c0] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<?x10xf32, #encoding4>>{%13}
        %15 = stream.binding.subspan %arg2[%10#0] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<?x32xf32, #encoding4>>{%13}
        %16 = iree_tensor_ext.dispatch.tensor.load %14, offsets = [0, 0], sizes = [%13, 10], strides = [1, 1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<?x10xf32, #encoding4>>{%13} -> tensor<?x10xf32, #encoding5>
        %17 = iree_tensor_ext.dispatch.tensor.load %11, offsets = [0, 0], sizes = [32, 10], strides = [1, 1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<32x10xf32, #encoding>> -> tensor<32x10xf32, #encoding6>
        %18 = iree_tensor_ext.dispatch.tensor.load %12, offsets = [0], sizes = [32], strides = [1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<32xf32, #encoding1>> -> tensor<32xf32, #encoding14>
        %19 = tensor.empty(%13) : tensor<?x32xf32, #encoding7>
        %20 = linalg.fill ins(%cst : f32) outs(%19 : tensor<?x32xf32, #encoding7>) -> tensor<?x32xf32, #encoding7>
        %21 = linalg.generic {indexing_maps = [#map, #map1, #map2], iterator_types = ["parallel", "parallel", "reduction"]} ins(%16, %17 : tensor<?x10xf32, #encoding5>, tensor<32x10xf32, #encoding6>) outs(%20 : tensor<?x32xf32, #encoding7>) {
        ^bb0(%in: f32, %in_0: f32, %out: f32):
          %25 = arith.mulf %in, %in_0 : f32
          %26 = arith.addf %out, %25 : f32
          linalg.yield %26 : f32
        } -> tensor<?x32xf32, #encoding7>
        %22 = linalg.generic {indexing_maps = [#map4, #map3, #map4], iterator_types = ["parallel", "parallel"]} ins(%21, %18 : tensor<?x32xf32, #encoding7>, tensor<32xf32, #encoding14>) outs(%19 : tensor<?x32xf32, #encoding7>) {
        ^bb0(%in: f32, %in_0: f32, %out: f32):
          %25 = arith.addf %in, %in_0 : f32
          %26 = arith.cmpf ugt, %25, %cst : f32
          %27 = arith.select %26, %25, %cst : f32
          linalg.yield %27 : f32
        } -> tensor<?x32xf32, #encoding7>
        %23 = iree_encoding.unset_encoding %22 : tensor<?x32xf32, #encoding7> -> tensor<?x32xf32>{%13}
        %24 = iree_encoding.set_encoding %23 : tensor<?x32xf32> -> tensor<?x32xf32, #encoding8>
        iree_tensor_ext.dispatch.tensor.store %24, %15, offsets = [0, 0], sizes = [%13, 32], strides = [1, 1] : tensor<?x32xf32, #encoding8> -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<?x32xf32, #encoding4>>{%13}
        return
      }
    }
  }
  stream.executable private @main_graph$async_dispatch_1 {
    stream.executable.export public @main_graph$async_dispatch_1_matmul_like_Dx32x32_f32 workgroups(%arg0: index) -> (index, index, index) {
      %x, %y, %z = iree_tensor_ext.dispatch.workgroup_count_from_slice(%arg0)
      stream.return %x, %y, %z : index, index, index
    }
    builtin.module {
      func.func @main_graph$async_dispatch_1_matmul_like_Dx32x32_f32(%arg0: !stream.binding {stream.alignment = 64 : index}, %arg1: !stream.binding {stream.alignment = 64 : index}, %arg2: !stream.binding {stream.alignment = 64 : index}, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32) {
        %c6080 = arith.constant 6080 : index
        %c1600 = arith.constant 1600 : index
        %cst = arith.constant 0.000000e+00 : f32
        %c32_i64 = arith.constant 32 : i64
        %0 = arith.extui %arg4 : i32 to i64
        %1 = arith.shli %0, %c32_i64 : i64
        %2 = arith.extui %arg3 : i32 to i64
        %3 = arith.ori %2, %1 : i64
        %4 = arith.index_castui %3 : i64 to index
        %5 = arith.extui %arg6 : i32 to i64
        %6 = arith.shli %5, %c32_i64 : i64
        %7 = arith.extui %arg5 : i32 to i64
        %8 = arith.ori %7, %6 : i64
        %9 = arith.index_castui %8 : i64 to index
        %10 = arith.extui %arg8 : i32 to i64
        %11 = arith.shli %10, %c32_i64 : i64
        %12 = arith.extui %arg7 : i32 to i64
        %13 = arith.ori %12, %11 : i64
        %14 = arith.index_castui %13 : i64 to index
        %15:3 = util.assume.int 
            %4<umin = 0, umax = 360287970189639680, udiv = 1280>, 
            %9<umin = 0, umax = 1513209474796486656>, 
            %14<umin = 0, umax = 9007199254740991>
          : index, index, index
        %16 = stream.binding.subspan %arg1[%c1600] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<32x32xf32, #encoding>>
        %17 = stream.binding.subspan %arg1[%c6080] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<32xf32, #encoding1>>
        %18 = iree_tensor_ext.dispatch.workload.ordinal %15#2, 0 : index
        %19 = stream.binding.subspan %arg0[%15#0] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<?x32xf32, #encoding4>>{%18}
        %20 = stream.binding.subspan %arg2[%15#1] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<?x32xf32, #encoding4>>{%18}
        %21 = iree_tensor_ext.dispatch.tensor.load %19, offsets = [0, 0], sizes = [%18, 32], strides = [1, 1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<?x32xf32, #encoding4>>{%18} -> tensor<?x32xf32, #encoding8>
        %22 = iree_tensor_ext.dispatch.tensor.load %16, offsets = [0, 0], sizes = [32, 32], strides = [1, 1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<32x32xf32, #encoding>> -> tensor<32x32xf32, #encoding9>
        %23 = iree_tensor_ext.dispatch.tensor.load %17, offsets = [0], sizes = [32], strides = [1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<32xf32, #encoding1>> -> tensor<32xf32, #encoding15>
        %24 = tensor.empty(%18) : tensor<?x32xf32, #encoding10>
        %25 = linalg.fill ins(%cst : f32) outs(%24 : tensor<?x32xf32, #encoding10>) -> tensor<?x32xf32, #encoding10>
        %26 = linalg.generic {indexing_maps = [#map, #map1, #map2], iterator_types = ["parallel", "parallel", "reduction"]} ins(%21, %22 : tensor<?x32xf32, #encoding8>, tensor<32x32xf32, #encoding9>) outs(%25 : tensor<?x32xf32, #encoding10>) {
        ^bb0(%in: f32, %in_0: f32, %out: f32):
          %30 = arith.mulf %in, %in_0 : f32
          %31 = arith.addf %out, %30 : f32
          linalg.yield %31 : f32
        } -> tensor<?x32xf32, #encoding10>
        %27 = linalg.generic {indexing_maps = [#map4, #map3, #map4], iterator_types = ["parallel", "parallel"]} ins(%26, %23 : tensor<?x32xf32, #encoding10>, tensor<32xf32, #encoding15>) outs(%24 : tensor<?x32xf32, #encoding10>) {
        ^bb0(%in: f32, %in_0: f32, %out: f32):
          %30 = arith.addf %in, %in_0 : f32
          %31 = arith.cmpf ugt, %30, %cst : f32
          %32 = arith.select %31, %30, %cst : f32
          linalg.yield %32 : f32
        } -> tensor<?x32xf32, #encoding10>
        %28 = iree_encoding.unset_encoding %27 : tensor<?x32xf32, #encoding10> -> tensor<?x32xf32>{%18}
        %29 = iree_encoding.set_encoding %28 : tensor<?x32xf32> -> tensor<?x32xf32, #encoding11>
        iree_tensor_ext.dispatch.tensor.store %29, %20, offsets = [0, 0], sizes = [%18, 32], strides = [1, 1] : tensor<?x32xf32, #encoding11> -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<?x32xf32, #encoding4>>{%18}
        return
      }
    }
  }
  stream.executable private @main_graph$async_dispatch_2 {
    stream.executable.export public @main_graph$async_dispatch_2_matmul_like_Dx2x32_f32 workgroups(%arg0: index) -> (index, index, index) {
      %x, %y, %z = iree_tensor_ext.dispatch.workgroup_count_from_slice(%arg0)
      stream.return %x, %y, %z : index, index, index
    }
    builtin.module {
      func.func @main_graph$async_dispatch_2_matmul_like_Dx2x32_f32(%arg0: !stream.binding {stream.alignment = 64 : index}, %arg1: !stream.binding {stream.alignment = 64 : index}, %arg2: !stream.binding {stream.alignment = 64 : index}, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32) {
        %c0 = arith.constant 0 : index
        %c6528 = arith.constant 6528 : index
        %c6272 = arith.constant 6272 : index
        %cst = arith.constant 0.000000e+00 : f32
        %c32_i64 = arith.constant 32 : i64
        %0 = arith.extui %arg4 : i32 to i64
        %1 = arith.shli %0, %c32_i64 : i64
        %2 = arith.extui %arg3 : i32 to i64
        %3 = arith.ori %2, %1 : i64
        %4 = arith.index_castui %3 : i64 to index
        %5 = arith.extui %arg6 : i32 to i64
        %6 = arith.shli %5, %c32_i64 : i64
        %7 = arith.extui %arg5 : i32 to i64
        %8 = arith.ori %7, %6 : i64
        %9 = arith.index_castui %8 : i64 to index
        %10:2 = util.assume.int 
            %4<umin = 0, umax = 1513209474796486656>, 
            %9<umin = 0, umax = 9007199254740991>
          : index, index
        %11 = stream.binding.subspan %arg1[%c6272] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<2x32xf32, #encoding2>>
        %12 = stream.binding.subspan %arg1[%c6528] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<2xf32, #encoding3>>
        %13 = iree_tensor_ext.dispatch.workload.ordinal %10#1, 0 : index
        %14 = stream.binding.subspan %arg0[%10#0] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<?x32xf32, #encoding4>>{%13}
        %15 = stream.binding.subspan %arg2[%c0] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<?x2xf32>>{%13}
        %16 = iree_tensor_ext.dispatch.tensor.load %14, offsets = [0, 0], sizes = [%13, 32], strides = [1, 1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<?x32xf32, #encoding4>>{%13} -> tensor<?x32xf32, #encoding11>
        %17 = iree_tensor_ext.dispatch.tensor.load %11, offsets = [0, 0], sizes = [2, 32], strides = [1, 1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<2x32xf32, #encoding2>> -> tensor<2x32xf32, #encoding12>
        %18 = iree_tensor_ext.dispatch.tensor.load %12, offsets = [0], sizes = [2], strides = [1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<2xf32, #encoding3>> -> tensor<2xf32, #encoding16>
        %19 = tensor.empty(%13) : tensor<?x2xf32, #encoding13>
        %20 = linalg.fill ins(%cst : f32) outs(%19 : tensor<?x2xf32, #encoding13>) -> tensor<?x2xf32, #encoding13>
        %21 = linalg.generic {indexing_maps = [#map, #map1, #map2], iterator_types = ["parallel", "parallel", "reduction"]} ins(%16, %17 : tensor<?x32xf32, #encoding11>, tensor<2x32xf32, #encoding12>) outs(%20 : tensor<?x2xf32, #encoding13>) {
        ^bb0(%in: f32, %in_0: f32, %out: f32):
          %24 = arith.mulf %in, %in_0 : f32
          %25 = arith.addf %out, %24 : f32
          linalg.yield %25 : f32
        } -> tensor<?x2xf32, #encoding13>
        %22 = linalg.generic {indexing_maps = [#map4, #map3, #map4], iterator_types = ["parallel", "parallel"]} ins(%21, %18 : tensor<?x2xf32, #encoding13>, tensor<2xf32, #encoding16>) outs(%19 : tensor<?x2xf32, #encoding13>) {
        ^bb0(%in: f32, %in_0: f32, %out: f32):
          %24 = arith.addf %in, %in_0 : f32
          linalg.yield %24 : f32
        } -> tensor<?x2xf32, #encoding13>
        %23 = iree_encoding.unset_encoding %22 : tensor<?x2xf32, #encoding13> -> tensor<?x2xf32>{%13}
        iree_tensor_ext.dispatch.tensor.store %23, %15, offsets = [0, 0], sizes = [%13, 2], strides = [1, 1] : tensor<?x2xf32> -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<?x2xf32>>{%13}
        return
      }
    }
  }
  stream.executable private @_encoding_5 {
    stream.executable.export public @_encoding_5_encode_Dx10xf32_to_Dx10xf32 workgroups(%arg0: index, %arg1: index) -> (index, index, index) {
      %x, %y, %z = iree_tensor_ext.dispatch.workgroup_count_from_slice(%arg0, %arg1)
      stream.return %x, %y, %z : index, index, index
    }
    builtin.module {
      func.func @_encoding_5_encode_Dx10xf32_to_Dx10xf32(%arg0: !stream.binding {stream.alignment = 64 : index}, %arg1: !stream.binding {stream.alignment = 64 : index}, %arg2: i32, %arg3: i32) {
        %c0 = arith.constant 0 : index
        %c32_i64 = arith.constant 32 : i64
        %0 = arith.extui %arg3 : i32 to i64
        %1 = arith.shli %0, %c32_i64 : i64
        %2 = arith.extui %arg2 : i32 to i64
        %3 = arith.ori %2, %1 : i64
        %4 = arith.index_castui %3 : i64 to index
        %5 = arith.extui %arg3 : i32 to i64
        %6 = arith.shli %5, %c32_i64 : i64
        %7 = arith.extui %arg2 : i32 to i64
        %8 = arith.ori %7, %6 : i64
        %9 = arith.index_castui %8 : i64 to index
        %10:2 = util.assume.int 
            %4<umin = 0, umax = 9007199254740991>, 
            %9<umin = 0, umax = 9007199254740991>
          : index, index
        %11 = iree_tensor_ext.dispatch.workload.ordinal %10#0, 0 : index
        %12 = iree_tensor_ext.dispatch.workload.ordinal %10#1, 1 : index
        %13 = stream.binding.subspan %arg0[%c0] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<readonly:tensor<?x10xf32>>{%11}
        %14 = stream.binding.subspan %arg1[%c0] : !stream.binding -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<?x10xf32, #encoding4>>{%12}
        %15 = iree_tensor_ext.dispatch.tensor.load %13, offsets = [0, 0], sizes = [%11, 10], strides = [1, 1] : !iree_tensor_ext.dispatch.tensor<readonly:tensor<?x10xf32>>{%11} -> tensor<?x10xf32>
        %16 = iree_encoding.set_encoding %15 : tensor<?x10xf32> -> tensor<?x10xf32, #encoding4>
        iree_tensor_ext.dispatch.tensor.store %16, %14, offsets = [0, 0], sizes = [%12, 10], strides = [1, 1] : tensor<?x10xf32, #encoding4> -> !iree_tensor_ext.dispatch.tensor<writeonly:tensor<?x10xf32, #encoding4>>{%12}
        return
      }
    }
  }
  util.func public @main_graph$async(%arg0: !hal.buffer_view, %arg1: !hal.fence, %arg2: !hal.fence) -> !hal.buffer_view attributes {inlining_policy = #util.inline.never, iree.abi.model = "coarse-fences", iree.abi.stub} {
    %c32_i64 = arith.constant 32 : i64
    %c4096 = arith.constant 4096 : index
    %c1280 = arith.constant 1280 : index
    %c8 = arith.constant 8 : index
    %c0 = arith.constant 0 : index
    %c32 = arith.constant 32 : index
    %c40 = arith.constant 40 : index
    %c10 = arith.constant 10 : index
    %c6592 = arith.constant 6592 : index
    %__hoisted_tensor_32x10xf32__encoded = util.global.load immutable @__hoisted_tensor_32x10xf32__encoded : !stream.resource<constant>
    %0 = hal.buffer_view.dim<%arg0 : !hal.buffer_view>[0] : index
    %element_type_f32 = hal.element_type<f32> : i32
    %dense_row_major = hal.encoding_type<dense_row_major> : i32
    hal.buffer_view.assert<%arg0 : !hal.buffer_view> message("tensor") shape([%0, %c10]) type(%element_type_f32) encoding(%dense_row_major)
    %1 = arith.muli %0, %c40 : index
    %2 = stream.tensor.import on(#hal.device.affinity<@__device_0>) %arg0 : !hal.buffer_view -> tensor<?x10xf32>{%0} in !stream.resource<external>{%1}
    %3 = stream.timepoint.import on(#hal.device.affinity<@__device_0>) %arg1 : (!hal.fence) => !stream.timepoint
    %4 = arith.ceildivsi %0, %c32 : index
    %5 = arith.muli %4, %c1280 : index
    %6 = arith.muli %4, %c4096 : index
    %7 = arith.muli %0, %c8 : index
    %result, %result_timepoint = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) await(%3) => !stream.resource<external>{%7} => !stream.timepoint
    %8 = arith.addi %5, %6 : index
    %9 = arith.addi %8, %6 : index
    %result_0, %result_timepoint_1 = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) await(%3) => !stream.resource<transient>{%9} => !stream.timepoint
    %10 = stream.timepoint.join max(%result_timepoint, %result_timepoint_1) => !stream.timepoint
    %11 = arith.index_castui %0 : index to i64
    %12 = arith.index_castui %0 : index to i32
    %13 = arith.shrui %11, %c32_i64 : i64
    %14 = arith.trunci %13 : i64 to i32
    %15 = arith.index_castui %5 : index to i64
    %16 = arith.index_castui %5 : index to i32
    %17 = arith.shrui %15, %c32_i64 : i64
    %18 = arith.trunci %17 : i64 to i32
    %19 = arith.index_castui %8 : index to i64
    %20 = arith.index_castui %8 : index to i32
    %21 = arith.shrui %19, %c32_i64 : i64
    %22 = arith.trunci %21 : i64 to i32
    %23 = stream.cmd.execute on(#hal.device.affinity<@__device_0>) await(%10) => with(%2 as %arg3: !stream.resource<external>{%1}, %__hoisted_tensor_32x10xf32__encoded as %arg4: !stream.resource<constant>{%c6592}, %result as %arg5: !stream.resource<external>{%7}, %result_0 as %arg6: !stream.resource<transient>{%9}) {
      stream.cmd.dispatch @_encoding_5::@_encoding_5_encode_Dx10xf32_to_Dx10xf32[%0, %0](%12, %14 : i32, i32) {
        ro %arg3[%c0 for %1] : !stream.resource<external>{%1},
        wo %arg6[%c0 for %9] : !stream.resource<transient>{%9}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_0::@main_graph$async_dispatch_0_matmul_like_Dx32x10_f32[%0](%16, %18, %12, %14 : i32, i32, i32, i32) {
        ro %arg6[%c0 for %9] : !stream.resource<transient>{%9},
        ro %arg4[%c0 for %c6592] : !stream.resource<constant>{%c6592},
        wo %arg6[%c0 for %9] : !stream.resource<transient>{%9}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_1::@main_graph$async_dispatch_1_matmul_like_Dx32x32_f32[%0](%16, %18, %20, %22, %12, %14 : i32, i32, i32, i32, i32, i32) {
        ro %arg6[%c0 for %9] : !stream.resource<transient>{%9},
        ro %arg4[%c0 for %c6592] : !stream.resource<constant>{%c6592},
        wo %arg6[%c0 for %9] : !stream.resource<transient>{%9}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_2::@main_graph$async_dispatch_2_matmul_like_Dx2x32_f32[%0](%20, %22, %12, %14 : i32, i32, i32, i32) {
        ro %arg6[%c0 for %9] : !stream.resource<transient>{%9},
        ro %arg4[%c0 for %c6592] : !stream.resource<constant>{%c6592},
        wo %arg5[%c0 for %7] : !stream.resource<external>{%7}
      }
    } => !stream.timepoint
    %24 = stream.resource.dealloca on(#hal.device.affinity<@__device_0>) await(%23) => %result_0 : !stream.resource<transient>{%9} => !stream.timepoint
    stream.timepoint.chain_external on(#hal.device.affinity<@__device_0>) %24 => (%arg2 : !hal.fence)
    %25 = stream.tensor.export on(#hal.device.affinity<@__device_0>) %result : tensor<?x2xf32>{%0} in !stream.resource<external>{%7} -> !hal.buffer_view
    util.return %25 : !hal.buffer_view
  }
  util.func public @main_graph(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub} {
    %0 = util.null : !hal.fence
    %c-1_i32 = arith.constant -1 : i32
    %c0 = arith.constant 0 : index
    %device_0 = hal.devices.get %c0 : !hal.device
    %fence = hal.fence.create device(%device_0 : !hal.device) flags("None") : !hal.fence
    %1 = util.call @main_graph$async(%arg0, %0, %fence) : (!hal.buffer_view, !hal.fence, !hal.fence) -> !hal.buffer_view
    %status = hal.fence.await until([%fence]) timeout_millis(%c-1_i32) flags("None") : i32
    util.return %1 : !hal.buffer_view
  }
}
