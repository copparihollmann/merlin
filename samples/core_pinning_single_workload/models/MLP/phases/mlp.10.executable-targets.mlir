#composite_of_5376b = #util.composite<5376xi8, [
    dense<"0x26E9733EC8181D3EA18D17BE3DFDFE3D747CA73CA916753E7724A0BEE399DBBD9A23983D8818483E2781583EE4BF9E3E5C7405BE66A108BE14DA1F3E7360B43D639B853EE1C42C3D25246CBE9FA0F43DCADF34BE569A813E99584ABD175CF93DF867823EF924EABCF77E313E33F75EBECF29E93D4DCD313E2C56943D4A47073D1D330E3D4C230A3E5EFDF0BD28928C3E57CF9FBE927E6BBD6F523F3E2E1A133E996437BE86B2863E663144BE02B97CBE444E7B3E1BCFCABDE9860CBE4DE5423E583371BE6E6E9EBEAC1D62BEEF0DFB3DC08B9E3E0BC9803EFED62C3E7F3B7FBEA4951DBE30053CBE8903EE3D29D655BE897B99BE02EBF0BC5CEBCC3D87C2D93DD4284ABEC0F50E3DD672FCB9B26E6C3E626B77BE45A5803E911E803E2594783EE8EA373E3CC16BBEC9531BBD81998D3C49F21D3EA71AB63D35FB353EAF5DFBBDE3FB7A3E30C504BD63B6C53D476567BEA75B153DAA25253E071063BE3B70933ED3F2BBBDCA9F813E1597933E757738BE943B1CBDBA39AABD9CD79E3DB52B293CD76B2A3EC2CC983EE24E0EBE839E8DBEBACFE23DC62E19BC8D6468BEAAC9463D4F6522BE79930E3E6946073ECE37013EEE6E7ABE2B2366BEFC8A653E0A539FBD9DD3E43C92C1493E71554B3ED22C32BE45E7BC3DF4419EBEEB286F3EA62544BC69B040BE17DEA4BDA646E03D8C5CD6BD5758003E67C471BE5737193E61CD193ED0C29BBE0E4B34BE3CF088BE95DDEFBC65F17A3E25CCA13BBEEC003E61F788BEC5F94EBEB25B9CBDB7BD4FBEB5F6C33D5697923E43081C3E89ADDCBDB68826BE2CC68ABDDB8D5E3E1ACC22BE5AF81DBEB33E8FBE89EA68BEA91B6E3EC4D870BE95DB36BE5AAE97BE7604DABD804F9FBDC52AC13DCB1A83BD1CDC0D3E62E93CBEA7DF5BBE326C1DBE54D98EBE26F78A3D724C123ED9B278BDFA1E92BCBEDC8CBEEB44BBBCC329173E0709373ECECAB2BCB7B227BEFCE6E8BD48F70EBE587E993EFA47543E67E178BE19B129BE4415393ECF4F4EBDCFF12D3D2098A4BDA34415BE8B2F33BEC7A7243E294766BED3C09B3E237C0A3DFBE093BEA11B373DD7BCC3BD000B96BCF200693EADE6923E8CF61C3DE316313D6FD40F3E4A6CF53C8D96FC3D5306BE3D56F47B3E46858B3ED3B7B7BD5D8F1E3E78ABF4BD297A343E3808613E9639983EA4E48B3EA98B42BD16E28D3E8BE34F3E596017BEFD6360BED37A07BE8BEC40BED60173BE9F2C65BEB439A9BD6B8D353E50622A3ED932CA3C0C03423E7A181FBD37409EBED74084BE9B32993D8F1B3FBD086A7E3E69FD5D3E38459BBD7BF75D3E0945923EC60E66BE403D50BEF6C070BE400E8CBEE179813E72406ABE7AEE75BE6AD485BD01B5453D2380EFBB407842BE775E0E3E2E7977BE64FD33BEDC2421BEE66D5E3ED9CD523DAD7A883EA2DBB3BCD5F7593E40B921BDDD498FBE96D69C3E0B7FFEBDB6348BBE37F4793E2B97A63DDFA740BD7D21D93C36007A3EE09540BE6230093E2A12BB3C8548FFBD0D75543EF051F7BCECD3A93D3E9538BE51F7953B7B42653E7A01833D014F85BED1DD92BED2F98BBEDC7B493E77B1653E26F705BE591F68BEE07D7E3E4B6F2EBE3F78A13E0236213EE516F63A06443ABEE2D5233E87D69F3DE591323E91EE30BD4234A13EF48D7CBDBA6C86BE7A53863D2614D93D7CCAEB3D838635BEC2037ABEBCDC963E71E11E3EF9087B3E6985CEBDF725D13D5301EBBD6DE1A0BEE0D8CBBD2A7A8ABE5E7B4E3B1CE63A3E7E23BD3DE5574A3E12AF0C3E4DD679BE15A078BE33B4563E9202813D27A8E43D8F03483E"> : tensor<32x10xf32>,
    dense<"0x5BA03E3C8296C13C6ECED53D0A92C63D7173E2372DE484BD2C317BBC370609BE0A865BBD2F1C053D5FB065BD5D8C863C168C82BD6F25163ED0ADC2BC053B0B3EFFD51E3E7E21B0BD5222183E71C0B3BDB342F6BDF978043DDB24EC3CBF71033ED78E31BE0D9C11BE6E2F96BCCF2014BE178A2FBEED2BC2BC40A2863D064CAF3DDF3D353B7254FCBD462F663CB258033E9F8614BEA944083EF301B83D1D9219BECE9508BED999FB3D2A92B4BD8F18EE3CA733BDBD8B812C3E4142F5BDA6E118BE920E6E3D921D0E3E24DE5F3DDEF1953DD70DEABD44C792BD3B38F53B3D1FB43D7719C83DCED7A3BBF6D67C3C880C043E7AA1ACBDA3642BBE1425203E3FA2043E7F9B07BED5CF2FBE9973173E91712C3E14640B3D021BF1BDA5FC19BE280933BCC25217BEBF9EBD3C69A41BBEE9BD2A3EB86A2ABB07E7393C0726DDBDFA25193D5EE18F3C49F86F3D48720A3E6E7F28BECECBC93C02B29D3D02439E3C2906033E149092BD4F882FBED7D895BD7DB7BABCD48CC3BD733086BDB73D14BE83371ABE9565023DB31864BCE5EB593942C2E53D15572ABE3E8FD7BD972707BE65E3B0BDC694BABD93AD24BDC2C91FBE109CD83CF2AF13BE8F43E6BC91A0403C4BE4553DC0B9D23C7D64ACBDD898C83D2DE4F43C8941F13887C9F6BD1DE621BD4E6AA53DC06A113E1ADEB6BD1601D0BDA090933D3EE368BD2E370A3DB4B12CBE12A3363D7A4F0E3E6E632ABEE1C29F3B0F4DE43DD21F353B284C2B3DBEFAE63DCAFC193E3BF5573D6192063ED39FAB3DF6B9433D2631413D8725EA3D5678CFBC8BAD00BD9C3126BE3C8DF6BBC700E0BD91C3E23DB1D128BE9B289D3B1862EB3DDDD026BE31312C3E1C83E63D3990253E651034BE728F08BDA5AF323D1BFCB5BD4A10293E0F68003E817866BD69DEBDBD0EDB223E50EA96BDE2CF88BCFB2A133E7FC8B13DDB58293E34591DBE683C33BE2BFCE4BD51FB2BBE99D20FBED91AA2BD7808733D28E5873D3581D13C453A93BDC619B33CAFAE34BD94B0283D067AC13D145D0ABE1E9D943D7286833DE907F0BD52B9BFBDE9A00ABEEAE5863D5A3816BE7A6B6C3DF0D4DD3CFFF71F3E20623BB9FDF62ABEC05504BE7010C23DA50E1D3DDD825A3DC06421BEA53EB53DDC83D1BCE329A23B0266EABC34606DBD6ECC2EBE8441183EC3F6063D8A7B943D9DF29ABC76ABCCBD4177FFBD15F2C2BDA67C8FBCE3878DBD6CAA2C3E94F111BC447102BEC46B053E070912BEB8A5803D52BE2ABE259ADCBC5898133E05F5E6BDB90F9EBD30FD323E7BA9963D3A8D19BE7E3B6A3D897FAABD6F3A9EBCA5E614BD9C49F5BDB426483D1D519DBD013404BEE8AD04BEAD62F6BDCB1A023E60FA203E53B2B5BDFB5E27BE3CDD2D3D758C29BECF73B1BCE7FB0EBE8AEA5F3DA190843D0A2CDDBDBBDDC0BB099B63BDB2A917BE35B01BBE290BD2BDD38087BD97002EBDD3DA643D76A32B3E0B482BBB4C0107BE2207CDBD90EAC1BD003933BE5A1F533D1271CCBD2C99283E3D6923BECC59A7BD6804333D3D2C8BBDF7331F3EEB87FD3C163A84BB2C37753C1089C93D78682EBDC66D8ABD8433143E2BC4CEBD1714B6BD52E6D6BD7963093EB5462DBE5FD58FBDDE1C333D550E7E3DDE8EEA3DB11B053E1EE055BD8406CFBD3D5E603D03510EBEC2EC9CBDBB8E113E8A2F3C3CE603DF3D05EA8B3DAC6617BE0F7308BE5AC1BDBC2B51273C4156F2BD099615BE09C4213E6761DFBC4EE21C3EF0E0343EF96A2B3E4211783D02DE2ABE5591783DF38EAEBD834F243E70E76DBD65559EBD9C74D83DDC342BBE8460BEBD031E33BEFC7785BDEF1BD8BDC5FE153E43761ABE4FB0243EB8F9E5BD4564713CB1970ABE6023FD3D6F4F0E3E6139DEBD88AFC1BDCCE1893DF6BF05BE401B41BB2A29F0BDBBB223BE493DCE3DD407CF3DEFFD323D2625163E6B6CEC3D8475D83D8357233EB8F2B03DB41E0DBC0FF3583D76B106BEFCCB2BBE0CFA103D20B3C73D1FB7D6BCFB895EBDD17F983DE59B463DD5CD32BE319B453D34F04DBC4F99A0BB3BC6873CE2A036BD930E24BEDF5199BDA1F5053E559E8CBD094532BE6C4F07BE1FDBA33D9D97233DC2F634BE5FCDB53D2FBEF53C70C6B23D1478303E3B6D333E0DB572BDBB54F23DDA8084BDB9132B3E0CB691BCAF116FBD3819B8BDD814E43D511F0EBE1FB532BEB252023E812573BD017099BDFC8C123E269BA13DC3AA033EFB18283E29103CBC94CFD33D2462513D5D0F09BE0BB8D73D770B1CBDD5853B3B6E7CBB3DA29F1BBCF85427BDE5C687BB84FD753D6A4B14BE857D1E3EF7AA9C3D0B1A3F3DD77A393C2CFF003E7E0700BEACC12D3E7D35913D977077BD75E5253E6669B63DAEF0853DC0FAA83D811D0B3E1BA525BE9656AD3DD34312BD3D1733BEEF04F7BD235FBC3CFDBB29BE9D7D003EC4D28E3C01EE253E5C6C00BE840A9ABD552830BEF42292BDDC0B90BD9058AF3DE1807FBC67F90CBDC0F897BC428FEF3D9C6714BDF21C1CBE339A45BD5CD48E3C436CAFBC7C60BEBD52AFE13D06D297BD7F46A1BDA838C2BD4EC3CEBDE236CD3D2ECD2A3E36B62C3E842A5FBD6386BFBDD07438BD33A0173E0318ED3D0515083E10B42EBD0A61BBBD0B53303CF947FE3D114307BE1247033EA97104BD4F3D503CAC0DDCBD307C183EB78C5B3D473D1BBE0596FABD98FD2BBDE20DDABC76B6CDBDE39F1E3E54CB2FBE8759AA3D5282DC3C5EE91DBE5CE0313E4C7725BD818BA1BD6540303D6687F0BDC4902CBE62D1B9BD5F3200BE6F9014BEDFDF263E13791F3E06E0E7BDD2752B3E138C17BDF74891BD376F9EBD6B2228BEA0F3303D2BBAB9BD829F0A3E0B2F9C3D078C74BD14620CBE2766D93D346B303EC52F10BCED92F8BCD976343E17092CBED18D153E831531BE5DD12C3EDB1314BEE766D33C11D695BD75AE03BE7BF402BE16392A3EF93402BEE8C9343C349D063DDFC027BE158315BE2F53093EFBDE253EF00040BCBD812B3E3B0118BE851AAA3D83F0DE3DE2A7DDBDAF720FBD053F06BEEC5A80BDDE7DCE3D4382CCBD6C3917BEC7612FBE6AEBBFBC959CD6BD0D74073EC2DC98BDC936D13CA4590C3DEB5D303CF227E43C9FAC0B3E19887CBD340D59BDD6EF0DBE544D6E3D99D23BBD61F06ABBC5D9BBBD7AC00ABE8FC3D9BD38F3AD3D6F5D2FBEDC51A0BDB1940CBE07556CBD60F2843D20EA11BE9788123EE9EBF6BDFFE62B3EE106963DC13427BE0F99C3BC2FED1F3E356556BD094A9EBD4E23063E23EDD0BDB8E1873C3CA22A3E0CA3323DB023C8BDAC4C15BE65A72FBB20AEE33DAF430F3D35EE243DEFC544BDA59FD8BCA0C1EC3D34BB793CD969E7BDA66F03BEA6955EBD375BC2BDFB9EEBBD624A063CDE7FD4BD727E493DF35E0B3D15A6DDBDF1ABC13D04BE02BE3A471ABD5B860A3E7284713D5345263E145F29BB5C44583DE3D5C83DFB0BF33D42AC443D0C20A1BDCFF03EBD65606ABCDD348EBC1F09143EB84655BDC6882A3C5EAC4CBD5500023D6BF8933B56E096BC19D7B2BD069D63BD82511CBE7BE816BE4194DEBDC9CEF8BD93F8A3BD6DE4093D084128BDF80C533B34B4973C585A653CFB699BBC5F6CFDBDC57E46BD12C589BB9DE46CBD3F0D083EF8FD193EFF2ABA399A661DBEBAD485BD7EC933BE1408D63DC237E6BD2DEC97BD9B88CA3B51F3F3BCE5EAA83C4CE818BE21D412BE6DF606BEB5737F3B9ACC9F3DBCEA1CBEADDA1E3E27F37DBD818C26BC8BFFAEBC0C801D3EB885173E5FF68D3D6E28843D7CC2923DB8B3883D8F1D213E685F88BDD2C03D3C609CA73D58313D3DFDA5923D2F2DBEBD054D0F3E7230813D12DBBDBDD9DC20BE61EAF5BD52E5D93D10D382BDCBC9D0BDEB28B83DA8C71E3D913064BDE3FA533D77FAF73DCED9363D64D408BEA29253BDE54CD7BD1309C1BD4B6AB4BDEB46AF3D8AD2223E6CA747BD65EFA9BD7865313DAD46CCBD4ADEB4BD3D4E21BCD8A1263E9152F23C6091DFBD59ABCFBD77978FBD9D70983D673623BE1FD9153ECCC5DC3D1328E3BD555AAD3D49D8223E3DAB2FBE860FF2BC898CA0BDBEDA52BDBF557F3DDCBEE83D5C45F73D2A5F7ABD1F6FA93DE367A73DFC95E1BCB05F813DE8CDA33D8D74BBBCFF8523BE4C897BBD53B0293EA6BA94BDC4E28ABDD0DCCBBC824523BECAB0EBBDDCCB283E84B643BD34B3753D183745BDC87931BE2F43EA3C646CF33D896C6D3DCD5871BD9ADDDD3CFC7407BE1847AD3DA5212FBEF32F2FBEA4E624BE825115BE57D016BE2A47233E1A71EABA38F1FFBA40B08EBC076EE83D174E2E3E09F4CFBC2A6733BE835DA53C5A5BE5BDEDEDCBBD4C02B5BCE41518BE48802B3D694CD53D4ADD09BC1151863DDC49DDBD00E9293E275BE7BDFBB40F3E589D803DA00A533DC3D9E23D2219273E3D86213E58C7D13BFFE989BDE64D23BEBC5C323EA84FEC3D84C7913D090A9BBDEFBD55BD04AE3DBD1D8C2EBE710C5FBD4DD6B2BDD886FD3D1B0AFB3BD90B17BE5D9E0C3D92A8153EDC721DBEF9941DBD5E0CF3BD7B934DBCA0D8F73D6C5E183E457B04BD5AC0073DD98D0DBE958CA8BC6A55C83DC121A2BDCD236F3C11EF1F3ECECDB0BDD35F11BD9B58753D2440B6BDF425993D25B3DEBCE4C434BDAA59213DD9D69C3D559C1EBE291D32BE391D1A3DD957A23C998497BD723415BEBC2F303E0F941D3E4D5C7C3DEBF5DD3D7ADBAB3CED65F13D30A1D03DC795303CA63A45BDD021B43DB69B2C3EA9B28E3DE6DDA0BDCCD12D3EF9AFE7BDB574CEBD0F090CBE894CAABD403960BCD95A51BD568E3CBDA884D9BC9C17AD3D49AAE43DA5A5F5BDE2B9143EB338A0BCA87033BEB1B2213D70E12CBE269C09BCCE100ABE921E2F3D46A1C23D6722063E7CA09F3DCAF4E43BA795113E5B02B03D48FA1E3DCE4AA53D74DFD7BD46CB073E69C68F3DA24E0A3E72A474BC708AB1BD560C90BD77EB35BC56DFF6BDA10E67BD873428BD699F303C9B6C1A3E9925E33DD7AF1D3D3EC91D3EF25619BCA0A269BCED120FBEF52A093EA7FA5ABDA2B2F43DC4E60EBE3CF3E93A115ADFBA9A601C3EA9185F3DBFB41D3D11AA853DA58C073D9D80FF3DD71A15BD9BE729BEE4E1DE3D5BA13D3B19EAE3BD8D6C183E88C8703D88BFEFBDA8C6E73D39F2F73DC67D103EA2A341BC2C1698BD047FCABCD72A363C24161D3E50571ABD1ECE113EBC3B92BC53087E3D7A255B3D9320303D9923C6BA342E423D6D8DDA3C9B1AFA3D838627BD4154C4BD73F8CA3DFFAD733D605333BE94C2253E865A1F3E06C0DFBCD6AD853D4C30F13C728D823CEAA1963D9B232FBD1335323EA2C1C0BDF4B014BE6C2CEABC2679AE3CF8CCBABDADD5253D5368ACBDA728B2BCDAA9A43D74E2B0BDBC6F973D6041203E79FFE4BD78EED13DC4B3E6BC0462CBBD33DC173CA3B4333E363E17BEE3BE2C3E87C662BCFFF68CBD52D312BEBBBEC4BC11E0143E4207063E314DFBBC8383BFBC1156D3BD6F3D86BC1185C03D1FC3333E9AC4A33DB1940B3EC23798BDEEF4F73D77D6D43BD8E1DD3CD92F813D1BFE083EBC91243E6EF3E83D0EF920BDD88E9C3D366BC0BD28BC783D01C96EBDADF92C3C938017BE95DA213E5B841ABE4F5529BE894A04BE785F2A3EEBC01C3E292EDD3D957CF23D65E1F13DB50ADDBDDC6D1ABE3F9F2A3E94FFE93DB88AE0BD50C8033E738E7ABC9C2CA7BD73BA0EBEF429EDBDABEAECBC9E37DF3D8421B2BD1744ECBD3B922D3E75B1F53C09E52FBEF59166BDDCE00DBE7E1A9C3C3E611B3E6B961A3EB09DCE3D069A263EB1AFF93D5086C93D05B593BC8A7D6F3DD6CDB9BBAF4E053ECE3A073E638A1ABE"> : tensor<32x32xf32>,
]>
#executable_target_system_elf_x86_64 = #hal.executable.target<"llvm-cpu", "system-elf-x86_64", {cpu = "znver3", cpu_features = "+prfchw,-cldemote,+avx,+aes,+sahf,+pclmul,-xop,+crc32,-amx-fp8,+xsaves,-avx512fp16,-usermsr,-sm4,-egpr,+sse4.1,-avx10.1,-avx512ifma,+xsave,+sse4.2,-tsxldtrk,-sm3,-ptwrite,-widekl,-movrs,+invpcid,+64bit,+xsavec,-avx512vpopcntdq,+cmov,-avx512vp2intersect,-avx512cd,+movbe,-avxvnniint8,-ccmp,-amx-int8,-kl,-sha512,-avxvnni,-rtm,+adx,+avx2,-hreset,-movdiri,-serialize,+vpclmulqdq,-avx512vl,-uintr,-cf,+clflushopt,-raoint,-cmpccxadd,+bmi,-amx-tile,+sse,-gfni,-avxvnniint16,-amx-fp16,-zu,-ndd,+xsaveopt,+rdrnd,-avx512f,-amx-bf16,-avx512bf16,-avx512vnni,-push2pop2,+cx8,-avx512bw,+sse3,+pku,-nf,-amx-tf32,-amx-avx512,+fsgsbase,+clzero,+mwaitx,-lwp,+lzcnt,+sha,-movdir64b,-ppx,+wbnoinvd,-enqcmd,-amx-transpose,-avxneconvert,-tbm,-pconfig,-amx-complex,+ssse3,+cx16,-avx10.2,+bmi2,+fma,+popcnt,-avxifma,+f16c,-avx512bitalg,+rdpru,+clwb,+mmx,+sse2,+rdseed,-avx512vbmi2,-prefetchi,-amx-movrs,+rdpid,-fma4,-avx512vbmi,+shstk,+vaes,-waitpkg,-sgx,+fxsr,-avx512dq,+sse4a", data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", iree.encoding.resolver = #iree_cpu.cpu_encoding_resolver<>, link_embedded = false, max_stack_allocation_size = 32768 : i64, native_vector_size = 32 : i64, target_triple = "x86_64-unknown-linux-gnu"}>
#pipeline_layout = #hal.pipeline.layout<constants = 2, bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, ReadOnly>, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#pipeline_layout1 = #hal.pipeline.layout<constants = 4, bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, ReadOnly>, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#pipeline_layout2 = #hal.pipeline.layout<constants = 4, bindings = [#hal.pipeline.binding<storage_buffer, "ReadOnly|Indirect">, #hal.pipeline.binding<storage_buffer, Indirect>], flags = Indirect>
#device_target_local = #hal.device.target<"local", [#executable_target_system_elf_x86_64]> : !hal.device
module attributes {stream.affinity.default = #hal.device.affinity<@__device_0>} {
  util.global private @__device_0 = #device_target_local
  hal.executable private @main_graph$async_dispatch_0 {
    hal.executable.variant public @system_elf_x86_64 target(#executable_target_system_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_0_matmul_like_Dx32x10_f32 ordinal(0) layout(#pipeline_layout) count(%arg0: !hal.device, %arg1: index) -> (index, index, index) {
        %c64 = arith.constant 64 : index
        %c0 = arith.constant 0 : index
        %c1 = arith.constant 1 : index
        %0 = arith.cmpi sle, %arg1, %c0 : index
        %1 = arith.subi %c0, %arg1 : index
        %2 = arith.subi %arg1, %c1 : index
        %3 = arith.select %0, %1, %2 : index
        %4 = arith.divsi %3, %c64 : index
        %5 = arith.subi %c0, %4 : index
        %6 = arith.addi %4, %c1 : index
        %7 = arith.select %0, %5, %6 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %7, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu"} {
        llvm.mlir.global private constant @__constant_32xf32(dense<[0.0962907821, -0.155916616, -2.659500e-01, -0.253344834, -0.238115147, -0.204406232, 5.3752563E-4, -0.247130185, -0.111521207, -0.20010379, -0.30845052, 0.15546523, 0.0545346662, 0.0396357551, 0.145887375, 0.267154038, 0.313625038, -0.0588332526, -0.239435181, 0.0780267491, 0.312959671, 0.260689229, 0.0252451561, 0.244547799, 0.0530805327, -9.820750e-02, 0.232707471, -0.00378808728, -0.296180874, -0.262859076, -0.0734717101, 0.167452633]> : tensor<32xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<32 x f32>
        llvm.func @main_graph$async_dispatch_0_matmul_like_Dx32x10_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.poison : vector<1xf32>
          %2 = llvm.mlir.constant(7 : i64) : i64
          %3 = llvm.mlir.constant(6 : i64) : i64
          %4 = llvm.mlir.constant(5 : i64) : i64
          %5 = llvm.mlir.constant(4 : i64) : i64
          %6 = llvm.mlir.constant(3 : i64) : i64
          %7 = llvm.mlir.constant(2 : i64) : i64
          %8 = llvm.mlir.constant(1 : i64) : i64
          %9 = llvm.mlir.constant(0 : i64) : i64
          %10 = llvm.mlir.constant(true) : i1
          %11 = llvm.mlir.constant(10 : index) : i64
          %12 = llvm.mlir.addressof @__constant_32xf32 : !llvm.ptr
          %13 = llvm.mlir.poison : !llvm.array<2 x vector<1xf32>>
          %14 = llvm.mlir.poison : !llvm.array<8 x vector<1xf32>>
          %15 = llvm.mlir.constant(-64 : index) : i64
          %16 = llvm.mlir.constant(64 : index) : i64
          %17 = llvm.mlir.constant(9 : index) : i64
          %18 = llvm.mlir.constant(7 : index) : i64
          %19 = llvm.mlir.constant(6 : index) : i64
          %20 = llvm.mlir.constant(5 : index) : i64
          %21 = llvm.mlir.constant(4 : index) : i64
          %22 = llvm.mlir.constant(3 : index) : i64
          %23 = llvm.mlir.constant(2 : index) : i64
          %24 = llvm.mlir.constant(dense<0.000000e+00> : vector<1xf32>) : vector<1xf32>
          %25 = llvm.mlir.constant(0 : index) : i64
          %26 = llvm.mlir.constant(8 : index) : i64
          %27 = llvm.mlir.constant(1 : index) : i64
          %28 = llvm.mlir.constant(32 : index) : i64
          %29 = llvm.mlir.constant(32 : i64) : i64
          %30 = llvm.getelementptr %12[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<32 x f32>
          %31 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %32 = llvm.extractvalue %31[9] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %33 = llvm.load %32 : !llvm.ptr -> i32
          %34 = llvm.getelementptr %32[1] : (!llvm.ptr) -> !llvm.ptr, i32
          %35 = llvm.load %34 : !llvm.ptr -> i32
          %36 = llvm.zext %35 : i32 to i64
          %37 = llvm.shl %36, %29 : i64
          %38 = llvm.zext %33 : i32 to i64
          %39 = llvm.or %38, %37 : i64
          %40 = llvm.extractvalue %31[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %41 = llvm.getelementptr %40[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %42 = llvm.load %41 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %10 ["align"(%42, %16 : !llvm.ptr, i64)] : i1
          %43 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %44 = llvm.extractvalue %43[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %45 = llvm.load %44 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %10 ["align"(%45, %16 : !llvm.ptr, i64)] : i1
          %46 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %47 = llvm.extractvalue %46[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %48 = llvm.getelementptr %47[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %49 = llvm.load %48 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %10 ["align"(%49, %16 : !llvm.ptr, i64)] : i1
          %50 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)>
          %51 = llvm.extractvalue %50[0] : !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)> 
          %52 = llvm.zext %51 : i32 to i64
          %53 = llvm.mul %52, %16 overflow<nsw> : i64
          %54 = llvm.mul %52, %15 overflow<nsw> : i64
          %55 = llvm.add %54, %39 : i64
          %56 = llvm.icmp "slt" %55, %16 : i64
          %57 = llvm.select %56, %55, %16 : i1, i64
          %58 = llvm.icmp "sgt" %57, %25 : i64
          llvm.cond_br %58, ^bb1(%25 : i64), ^bb6
        ^bb1(%59: i64):  // 2 preds: ^bb0, ^bb5
          %60 = llvm.icmp "slt" %59, %57 : i64
          llvm.cond_br %60, ^bb2, ^bb6
        ^bb2:  // pred: ^bb1
          %61 = llvm.add %59, %53 : i64
          llvm.br ^bb3(%25 : i64)
        ^bb3(%62: i64):  // 2 preds: ^bb2, ^bb4
          %63 = llvm.icmp "slt" %62, %28 : i64
          llvm.cond_br %63, ^bb4, ^bb5
        ^bb4:  // pred: ^bb3
          %64 = llvm.mul %62, %11 : i64
          %65 = llvm.add %64, %25 : i64
          %66 = llvm.getelementptr %42[%65] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %67 = llvm.load %66 {alignment = 4 : i64} : !llvm.ptr -> vector<8xf32>
          %68 = llvm.extractelement %67[%9 : i64] : vector<8xf32>
          %69 = llvm.extractvalue %14[0] : !llvm.array<8 x vector<1xf32>> 
          %70 = llvm.insertelement %68, %69[%9 : i64] : vector<1xf32>
          %71 = llvm.extractelement %67[%8 : i64] : vector<8xf32>
          %72 = llvm.extractvalue %14[1] : !llvm.array<8 x vector<1xf32>> 
          %73 = llvm.insertelement %71, %72[%9 : i64] : vector<1xf32>
          %74 = llvm.extractelement %67[%7 : i64] : vector<8xf32>
          %75 = llvm.extractvalue %14[2] : !llvm.array<8 x vector<1xf32>> 
          %76 = llvm.insertelement %74, %75[%9 : i64] : vector<1xf32>
          %77 = llvm.extractelement %67[%6 : i64] : vector<8xf32>
          %78 = llvm.extractvalue %14[3] : !llvm.array<8 x vector<1xf32>> 
          %79 = llvm.insertelement %77, %78[%9 : i64] : vector<1xf32>
          %80 = llvm.extractelement %67[%5 : i64] : vector<8xf32>
          %81 = llvm.extractvalue %14[4] : !llvm.array<8 x vector<1xf32>> 
          %82 = llvm.insertelement %80, %81[%9 : i64] : vector<1xf32>
          %83 = llvm.extractelement %67[%4 : i64] : vector<8xf32>
          %84 = llvm.extractvalue %14[5] : !llvm.array<8 x vector<1xf32>> 
          %85 = llvm.insertelement %83, %84[%9 : i64] : vector<1xf32>
          %86 = llvm.extractelement %67[%3 : i64] : vector<8xf32>
          %87 = llvm.extractvalue %14[6] : !llvm.array<8 x vector<1xf32>> 
          %88 = llvm.insertelement %86, %87[%9 : i64] : vector<1xf32>
          %89 = llvm.extractelement %67[%2 : i64] : vector<8xf32>
          %90 = llvm.extractvalue %14[7] : !llvm.array<8 x vector<1xf32>> 
          %91 = llvm.insertelement %89, %90[%9 : i64] : vector<1xf32>
          %92 = llvm.mul %61, %11 overflow<nsw, nuw> : i64
          %93 = llvm.add %92, %25 overflow<nsw, nuw> : i64
          %94 = llvm.getelementptr inbounds|nuw %45[%93] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %95 = llvm.load %94 : !llvm.ptr -> f32
          %96 = llvm.insertelement %95, %1[%0 : i32] : vector<1xf32>
          %97 = llvm.intr.fmuladd(%70, %96, %24) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %98 = llvm.add %92, %27 overflow<nsw, nuw> : i64
          %99 = llvm.getelementptr inbounds|nuw %45[%98] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %100 = llvm.load %99 : !llvm.ptr -> f32
          %101 = llvm.insertelement %100, %1[%0 : i32] : vector<1xf32>
          %102 = llvm.intr.fmuladd(%73, %101, %97) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %103 = llvm.add %92, %23 overflow<nsw, nuw> : i64
          %104 = llvm.getelementptr inbounds|nuw %45[%103] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %105 = llvm.load %104 : !llvm.ptr -> f32
          %106 = llvm.insertelement %105, %1[%0 : i32] : vector<1xf32>
          %107 = llvm.intr.fmuladd(%76, %106, %102) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %108 = llvm.add %92, %22 overflow<nsw, nuw> : i64
          %109 = llvm.getelementptr inbounds|nuw %45[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %110 = llvm.load %109 : !llvm.ptr -> f32
          %111 = llvm.insertelement %110, %1[%0 : i32] : vector<1xf32>
          %112 = llvm.intr.fmuladd(%79, %111, %107) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %113 = llvm.add %92, %21 overflow<nsw, nuw> : i64
          %114 = llvm.getelementptr inbounds|nuw %45[%113] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %115 = llvm.load %114 : !llvm.ptr -> f32
          %116 = llvm.insertelement %115, %1[%0 : i32] : vector<1xf32>
          %117 = llvm.intr.fmuladd(%82, %116, %112) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %118 = llvm.add %92, %20 overflow<nsw, nuw> : i64
          %119 = llvm.getelementptr inbounds|nuw %45[%118] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %120 = llvm.load %119 : !llvm.ptr -> f32
          %121 = llvm.insertelement %120, %1[%0 : i32] : vector<1xf32>
          %122 = llvm.intr.fmuladd(%85, %121, %117) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %123 = llvm.add %92, %19 overflow<nsw, nuw> : i64
          %124 = llvm.getelementptr inbounds|nuw %45[%123] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %125 = llvm.load %124 : !llvm.ptr -> f32
          %126 = llvm.insertelement %125, %1[%0 : i32] : vector<1xf32>
          %127 = llvm.intr.fmuladd(%88, %126, %122) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %128 = llvm.add %92, %18 overflow<nsw, nuw> : i64
          %129 = llvm.getelementptr inbounds|nuw %45[%128] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %130 = llvm.load %129 : !llvm.ptr -> f32
          %131 = llvm.insertelement %130, %1[%0 : i32] : vector<1xf32>
          %132 = llvm.intr.fmuladd(%91, %131, %127) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %133 = llvm.add %64, %26 : i64
          %134 = llvm.getelementptr %42[%133] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %135 = llvm.load %134 {alignment = 4 : i64} : !llvm.ptr -> vector<2xf32>
          %136 = llvm.extractelement %135[%9 : i64] : vector<2xf32>
          %137 = llvm.extractvalue %13[0] : !llvm.array<2 x vector<1xf32>> 
          %138 = llvm.insertelement %136, %137[%9 : i64] : vector<1xf32>
          %139 = llvm.extractelement %135[%8 : i64] : vector<2xf32>
          %140 = llvm.extractvalue %13[1] : !llvm.array<2 x vector<1xf32>> 
          %141 = llvm.insertelement %139, %140[%9 : i64] : vector<1xf32>
          %142 = llvm.add %92, %26 overflow<nsw, nuw> : i64
          %143 = llvm.getelementptr inbounds|nuw %45[%142] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %144 = llvm.load %143 : !llvm.ptr -> f32
          %145 = llvm.insertelement %144, %1[%0 : i32] : vector<1xf32>
          %146 = llvm.intr.fmuladd(%138, %145, %132) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %147 = llvm.add %92, %17 overflow<nsw, nuw> : i64
          %148 = llvm.getelementptr inbounds|nuw %45[%147] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %149 = llvm.load %148 : !llvm.ptr -> f32
          %150 = llvm.insertelement %149, %1[%0 : i32] : vector<1xf32>
          %151 = llvm.intr.fmuladd(%141, %150, %146) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %152 = llvm.getelementptr %30[%62] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %153 = llvm.load %152 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %154 = llvm.fadd %151, %153 {fastmathFlags = #llvm.fastmath<contract>} : vector<1xf32>
          %155 = llvm.fcmp "ugt" %154, %24 : vector<1xf32>
          %156 = llvm.select %155, %154, %24 : vector<1xi1>, vector<1xf32>
          %157 = llvm.extractelement %156[%9 : i64] : vector<1xf32>
          %158 = llvm.mul %61, %28 overflow<nsw, nuw> : i64
          %159 = llvm.add %158, %62 overflow<nsw, nuw> : i64
          %160 = llvm.getelementptr inbounds|nuw %49[%159] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %157, %160 : f32, !llvm.ptr
          %161 = llvm.add %62, %27 : i64
          llvm.br ^bb3(%161 : i64)
        ^bb5:  // pred: ^bb3
          %162 = llvm.add %59, %27 : i64
          llvm.br ^bb1(%162 : i64)
        ^bb6:  // 2 preds: ^bb0, ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_1 {
    hal.executable.variant public @system_elf_x86_64 target(#executable_target_system_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_1_matmul_like_Dx32x32_f32 ordinal(0) layout(#pipeline_layout1) count(%arg0: !hal.device, %arg1: index) -> (index, index, index) {
        %c64 = arith.constant 64 : index
        %c0 = arith.constant 0 : index
        %c1 = arith.constant 1 : index
        %0 = arith.cmpi sle, %arg1, %c0 : index
        %1 = arith.subi %c0, %arg1 : index
        %2 = arith.subi %arg1, %c1 : index
        %3 = arith.select %0, %1, %2 : index
        %4 = arith.divsi %3, %c64 : index
        %5 = arith.subi %c0, %4 : index
        %6 = arith.addi %4, %c1 : index
        %7 = arith.select %0, %5, %6 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %7, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu"} {
        llvm.mlir.global private constant @__constant_32xf32(dense<[0.162499294, -0.0801915451, 0.153941914, 0.0219113454, -0.140127942, -0.12445996, -0.149894521, 0.162132412, 0.105042696, -0.0859371721, 6.965030e-02, -0.141210482, -0.0333313271, -0.0386215597, -0.0218895562, 0.161435679, -0.0469571315, -0.0064728288, 0.138868779, 0.0946954563, -0.118682154, 0.125606269, 0.142559305, 0.101437077, 0.132687211, -0.0944273397, 0.160846531, -0.0927824079, -0.130839854, -0.0758508593, 0.176237047, -0.0873066708]> : tensor<32xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<32 x f32>
        llvm.func @main_graph$async_dispatch_1_matmul_like_Dx32x32_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.poison : vector<1xf32>
          %2 = llvm.mlir.constant(7 : i64) : i64
          %3 = llvm.mlir.constant(6 : i64) : i64
          %4 = llvm.mlir.constant(5 : i64) : i64
          %5 = llvm.mlir.constant(4 : i64) : i64
          %6 = llvm.mlir.constant(3 : i64) : i64
          %7 = llvm.mlir.constant(2 : i64) : i64
          %8 = llvm.mlir.constant(1 : i64) : i64
          %9 = llvm.mlir.constant(0 : i64) : i64
          %10 = llvm.mlir.constant(true) : i1
          %11 = llvm.mlir.constant(8 : i64) : i64
          %12 = llvm.mlir.addressof @__constant_32xf32 : !llvm.ptr
          %13 = llvm.mlir.poison : !llvm.array<8 x vector<1xf32>>
          %14 = llvm.mlir.constant(-64 : index) : i64
          %15 = llvm.mlir.constant(7 : index) : i64
          %16 = llvm.mlir.constant(6 : index) : i64
          %17 = llvm.mlir.constant(5 : index) : i64
          %18 = llvm.mlir.constant(4 : index) : i64
          %19 = llvm.mlir.constant(3 : index) : i64
          %20 = llvm.mlir.constant(2 : index) : i64
          %21 = llvm.mlir.constant(64 : index) : i64
          %22 = llvm.mlir.constant(dense<0.000000e+00> : vector<1xf32>) : vector<1xf32>
          %23 = llvm.mlir.constant(1280 : index) : i64
          %24 = llvm.mlir.constant(0 : index) : i64
          %25 = llvm.mlir.constant(1 : index) : i64
          %26 = llvm.mlir.constant(8 : index) : i64
          %27 = llvm.mlir.constant(32 : index) : i64
          %28 = llvm.mlir.constant(32 : i64) : i64
          %29 = llvm.getelementptr %12[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<32 x f32>
          %30 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %31 = llvm.extractvalue %30[9] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %32 = llvm.load %31 : !llvm.ptr -> i32
          %33 = llvm.getelementptr %31[1] : (!llvm.ptr) -> !llvm.ptr, i32
          %34 = llvm.load %33 : !llvm.ptr -> i32
          %35 = llvm.getelementptr %31[2] : (!llvm.ptr) -> !llvm.ptr, i32
          %36 = llvm.load %35 : !llvm.ptr -> i32
          %37 = llvm.getelementptr %31[3] : (!llvm.ptr) -> !llvm.ptr, i32
          %38 = llvm.load %37 : !llvm.ptr -> i32
          %39 = llvm.zext %34 : i32 to i64
          %40 = llvm.shl %39, %28 : i64
          %41 = llvm.zext %32 : i32 to i64
          %42 = llvm.or %41, %40 : i64
          %43 = llvm.zext %38 : i32 to i64
          %44 = llvm.shl %43, %28 : i64
          %45 = llvm.zext %36 : i32 to i64
          %46 = llvm.or %45, %44 : i64
          %47 = llvm.extractvalue %30[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %48 = llvm.getelementptr %47[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %49 = llvm.load %48 : !llvm.ptr -> !llvm.ptr
          %50 = llvm.mul %23, %11 : i64
          %51 = llvm.udiv %50, %28 : i64
          %52 = llvm.getelementptr %49[%51] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %10 ["align"(%52, %21 : !llvm.ptr, i64)] : i1
          %53 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %54 = llvm.extractvalue %53[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %55 = llvm.load %54 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %10 ["align"(%55, %21 : !llvm.ptr, i64)] : i1
          %56 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %57 = llvm.extractvalue %56[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %58 = llvm.getelementptr %57[2] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %59 = llvm.load %58 : !llvm.ptr -> !llvm.ptr
          %60 = llvm.mul %42, %11 : i64
          %61 = llvm.udiv %60, %28 : i64
          %62 = llvm.getelementptr %59[%61] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %10 ["align"(%62, %21 : !llvm.ptr, i64)] : i1
          %63 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)>
          %64 = llvm.extractvalue %63[0] : !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)> 
          %65 = llvm.zext %64 : i32 to i64
          %66 = llvm.mul %65, %21 overflow<nsw> : i64
          %67 = llvm.mul %65, %14 overflow<nsw> : i64
          %68 = llvm.add %67, %46 : i64
          %69 = llvm.icmp "slt" %68, %21 : i64
          %70 = llvm.select %69, %68, %21 : i1, i64
          %71 = llvm.icmp "sgt" %70, %24 : i64
          llvm.cond_br %71, ^bb1(%24 : i64), ^bb8
        ^bb1(%72: i64):  // 2 preds: ^bb0, ^bb7
          %73 = llvm.icmp "slt" %72, %70 : i64
          llvm.cond_br %73, ^bb2, ^bb8
        ^bb2:  // pred: ^bb1
          %74 = llvm.add %72, %66 : i64
          llvm.br ^bb3(%24 : i64)
        ^bb3(%75: i64):  // 2 preds: ^bb2, ^bb6
          %76 = llvm.icmp "slt" %75, %27 : i64
          llvm.cond_br %76, ^bb4(%24, %22 : i64, vector<1xf32>), ^bb7
        ^bb4(%77: i64, %78: vector<1xf32>):  // 2 preds: ^bb3, ^bb5
          %79 = llvm.icmp "slt" %77, %27 : i64
          llvm.cond_br %79, ^bb5, ^bb6
        ^bb5:  // pred: ^bb4
          %80 = llvm.mul %75, %27 : i64
          %81 = llvm.add %80, %77 : i64
          %82 = llvm.getelementptr %52[%81] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %83 = llvm.load %82 {alignment = 4 : i64} : !llvm.ptr -> vector<8xf32>
          %84 = llvm.extractelement %83[%9 : i64] : vector<8xf32>
          %85 = llvm.extractvalue %13[0] : !llvm.array<8 x vector<1xf32>> 
          %86 = llvm.insertelement %84, %85[%9 : i64] : vector<1xf32>
          %87 = llvm.extractelement %83[%8 : i64] : vector<8xf32>
          %88 = llvm.extractvalue %13[1] : !llvm.array<8 x vector<1xf32>> 
          %89 = llvm.insertelement %87, %88[%9 : i64] : vector<1xf32>
          %90 = llvm.extractelement %83[%7 : i64] : vector<8xf32>
          %91 = llvm.extractvalue %13[2] : !llvm.array<8 x vector<1xf32>> 
          %92 = llvm.insertelement %90, %91[%9 : i64] : vector<1xf32>
          %93 = llvm.extractelement %83[%6 : i64] : vector<8xf32>
          %94 = llvm.extractvalue %13[3] : !llvm.array<8 x vector<1xf32>> 
          %95 = llvm.insertelement %93, %94[%9 : i64] : vector<1xf32>
          %96 = llvm.extractelement %83[%5 : i64] : vector<8xf32>
          %97 = llvm.extractvalue %13[4] : !llvm.array<8 x vector<1xf32>> 
          %98 = llvm.insertelement %96, %97[%9 : i64] : vector<1xf32>
          %99 = llvm.extractelement %83[%4 : i64] : vector<8xf32>
          %100 = llvm.extractvalue %13[5] : !llvm.array<8 x vector<1xf32>> 
          %101 = llvm.insertelement %99, %100[%9 : i64] : vector<1xf32>
          %102 = llvm.extractelement %83[%3 : i64] : vector<8xf32>
          %103 = llvm.extractvalue %13[6] : !llvm.array<8 x vector<1xf32>> 
          %104 = llvm.insertelement %102, %103[%9 : i64] : vector<1xf32>
          %105 = llvm.extractelement %83[%2 : i64] : vector<8xf32>
          %106 = llvm.extractvalue %13[7] : !llvm.array<8 x vector<1xf32>> 
          %107 = llvm.insertelement %105, %106[%9 : i64] : vector<1xf32>
          %108 = llvm.mul %74, %27 overflow<nsw, nuw> : i64
          %109 = llvm.add %108, %77 overflow<nsw, nuw> : i64
          %110 = llvm.getelementptr inbounds|nuw %55[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %111 = llvm.load %110 : !llvm.ptr -> f32
          %112 = llvm.insertelement %111, %1[%0 : i32] : vector<1xf32>
          %113 = llvm.intr.fmuladd(%86, %112, %78) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %114 = llvm.add %77, %25 : i64
          %115 = llvm.add %108, %114 overflow<nsw, nuw> : i64
          %116 = llvm.getelementptr inbounds|nuw %55[%115] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %117 = llvm.load %116 : !llvm.ptr -> f32
          %118 = llvm.insertelement %117, %1[%0 : i32] : vector<1xf32>
          %119 = llvm.intr.fmuladd(%89, %118, %113) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %120 = llvm.add %77, %20 : i64
          %121 = llvm.add %108, %120 overflow<nsw, nuw> : i64
          %122 = llvm.getelementptr inbounds|nuw %55[%121] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %123 = llvm.load %122 : !llvm.ptr -> f32
          %124 = llvm.insertelement %123, %1[%0 : i32] : vector<1xf32>
          %125 = llvm.intr.fmuladd(%92, %124, %119) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %126 = llvm.add %77, %19 : i64
          %127 = llvm.add %108, %126 overflow<nsw, nuw> : i64
          %128 = llvm.getelementptr inbounds|nuw %55[%127] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %129 = llvm.load %128 : !llvm.ptr -> f32
          %130 = llvm.insertelement %129, %1[%0 : i32] : vector<1xf32>
          %131 = llvm.intr.fmuladd(%95, %130, %125) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %132 = llvm.add %77, %18 : i64
          %133 = llvm.add %108, %132 overflow<nsw, nuw> : i64
          %134 = llvm.getelementptr inbounds|nuw %55[%133] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %135 = llvm.load %134 : !llvm.ptr -> f32
          %136 = llvm.insertelement %135, %1[%0 : i32] : vector<1xf32>
          %137 = llvm.intr.fmuladd(%98, %136, %131) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %138 = llvm.add %77, %17 : i64
          %139 = llvm.add %108, %138 overflow<nsw, nuw> : i64
          %140 = llvm.getelementptr inbounds|nuw %55[%139] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %141 = llvm.load %140 : !llvm.ptr -> f32
          %142 = llvm.insertelement %141, %1[%0 : i32] : vector<1xf32>
          %143 = llvm.intr.fmuladd(%101, %142, %137) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %144 = llvm.add %77, %16 : i64
          %145 = llvm.add %108, %144 overflow<nsw, nuw> : i64
          %146 = llvm.getelementptr inbounds|nuw %55[%145] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %147 = llvm.load %146 : !llvm.ptr -> f32
          %148 = llvm.insertelement %147, %1[%0 : i32] : vector<1xf32>
          %149 = llvm.intr.fmuladd(%104, %148, %143) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %150 = llvm.add %77, %15 : i64
          %151 = llvm.add %108, %150 overflow<nsw, nuw> : i64
          %152 = llvm.getelementptr inbounds|nuw %55[%151] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %153 = llvm.load %152 : !llvm.ptr -> f32
          %154 = llvm.insertelement %153, %1[%0 : i32] : vector<1xf32>
          %155 = llvm.intr.fmuladd(%107, %154, %149) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %156 = llvm.add %77, %26 : i64
          llvm.br ^bb4(%156, %155 : i64, vector<1xf32>)
        ^bb6:  // pred: ^bb4
          %157 = llvm.getelementptr %29[%75] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %158 = llvm.load %157 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %159 = llvm.fadd %78, %158 {fastmathFlags = #llvm.fastmath<contract>} : vector<1xf32>
          %160 = llvm.fcmp "ugt" %159, %22 : vector<1xf32>
          %161 = llvm.select %160, %159, %22 : vector<1xi1>, vector<1xf32>
          %162 = llvm.extractelement %161[%9 : i64] : vector<1xf32>
          %163 = llvm.mul %74, %27 overflow<nsw, nuw> : i64
          %164 = llvm.add %163, %75 overflow<nsw, nuw> : i64
          %165 = llvm.getelementptr inbounds|nuw %62[%164] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %162, %165 : f32, !llvm.ptr
          %166 = llvm.add %75, %25 : i64
          llvm.br ^bb3(%166 : i64)
        ^bb7:  // pred: ^bb3
          %167 = llvm.add %72, %25 : i64
          llvm.br ^bb1(%167 : i64)
        ^bb8:  // 2 preds: ^bb0, ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  hal.executable private @main_graph$async_dispatch_2 {
    hal.executable.variant public @system_elf_x86_64 target(#executable_target_system_elf_x86_64) {
      hal.executable.export public @main_graph$async_dispatch_2_matmul_like_Dx2x32_f32 ordinal(0) layout(#pipeline_layout2) count(%arg0: !hal.device, %arg1: index) -> (index, index, index) {
        %c64 = arith.constant 64 : index
        %c0 = arith.constant 0 : index
        %c1 = arith.constant 1 : index
        %0 = arith.cmpi sle, %arg1, %c0 : index
        %1 = arith.subi %c0, %arg1 : index
        %2 = arith.subi %arg1, %c1 : index
        %3 = arith.select %0, %1, %2 : index
        %4 = arith.divsi %3, %c64 : index
        %5 = arith.subi %c0, %4 : index
        %6 = arith.addi %4, %c1 : index
        %7 = arith.select %0, %5, %6 : index
        %c1_0 = arith.constant 1 : index
        %c1_1 = arith.constant 1 : index
        hal.return %7, %c1_0, %c1_1 : index, index, index
      } attributes {workgroup_size = [1 : index, 1 : index, 1 : index]}
      builtin.module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu"} {
        llvm.mlir.global private constant @__constant_2xf32(dense<[0.150014639, -0.112291597]> : tensor<2xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<2 x f32>
        llvm.mlir.global private constant @__constant_2x32xf32(dense<[[-0.148675621, -0.00800752174, -0.154642224, 0.0714647844, -0.158757433, -0.0998362749, -0.0515264794, 0.0373864658, 0.0141011765, -0.106712803, 0.172995389, -0.159487143, -0.134175375, -0.0625612437, 0.0190407019, -0.167385533, -0.118601315, -0.14933382, -0.126252428, 0.0328095295, 0.161362395, 0.166322604, 0.105357215, -0.0199586395, -0.0860766768, 0.157569975, 0.122067556, -0.0260244776, 0.0585044622, 0.0506174564, -0.163079426, -0.0315102674], [0.102913834, 0.142172322, -0.0771354958, 0.0138733936, 0.00633722125, -7.187530e-02, 0.135073066, 0.0433540829, 0.091250725, -0.0407002196, 0.132568911, -0.128669098, 0.0537779666, 0.0500060953, 0.0648744926, -0.17312856, 0.174260497, -0.0767506734, -0.150335029, -0.0197679456, -0.114997737, 0.0462276936, -0.0195699614, -0.0607960708, -0.00727524143, 0.0066478434, 0.011014699, 8.34507591E-6, -0.082545422, -0.0434851795, 0.127168015, -0.0459757186]]> : tensor<2x32xf32>) {addr_space = 0 : i32, alignment = 64 : i64, sym_visibility = "private"} : !llvm.array<2 x array<32 x f32>>
        llvm.func @main_graph$async_dispatch_2_matmul_like_Dx2x32_f32(%arg0: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg1: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}, %arg2: !llvm.ptr {llvm.align = 16 : i64, llvm.noalias, llvm.nonnull, llvm.noundef}) -> i32 {
          %0 = llvm.mlir.constant(0 : i32) : i32
          %1 = llvm.mlir.poison : vector<1xf32>
          %2 = llvm.mlir.constant(7 : i64) : i64
          %3 = llvm.mlir.constant(6 : i64) : i64
          %4 = llvm.mlir.constant(5 : i64) : i64
          %5 = llvm.mlir.constant(4 : i64) : i64
          %6 = llvm.mlir.constant(3 : i64) : i64
          %7 = llvm.mlir.constant(2 : i64) : i64
          %8 = llvm.mlir.constant(1 : i64) : i64
          %9 = llvm.mlir.constant(0 : i64) : i64
          %10 = llvm.mlir.constant(true) : i1
          %11 = llvm.mlir.constant(8 : i64) : i64
          %12 = llvm.mlir.addressof @__constant_2xf32 : !llvm.ptr
          %13 = llvm.mlir.addressof @__constant_2x32xf32 : !llvm.ptr
          %14 = llvm.mlir.poison : !llvm.array<8 x vector<1xf32>>
          %15 = llvm.mlir.constant(32 : i64) : i64
          %16 = llvm.mlir.constant(32 : index) : i64
          %17 = llvm.mlir.constant(8 : index) : i64
          %18 = llvm.mlir.constant(2 : index) : i64
          %19 = llvm.mlir.constant(1 : index) : i64
          %20 = llvm.mlir.constant(-64 : index) : i64
          %21 = llvm.mlir.constant(7 : index) : i64
          %22 = llvm.mlir.constant(6 : index) : i64
          %23 = llvm.mlir.constant(5 : index) : i64
          %24 = llvm.mlir.constant(4 : index) : i64
          %25 = llvm.mlir.constant(3 : index) : i64
          %26 = llvm.mlir.constant(64 : index) : i64
          %27 = llvm.mlir.constant(dense<0.000000e+00> : vector<1xf32>) : vector<1xf32>
          %28 = llvm.mlir.constant(0 : index) : i64
          %29 = llvm.getelementptr %13[0, 0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<2 x array<32 x f32>>
          %30 = llvm.getelementptr %12[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.array<2 x f32>
          %31 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %32 = llvm.extractvalue %31[9] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %33 = llvm.load %32 : !llvm.ptr -> i32
          %34 = llvm.getelementptr %32[1] : (!llvm.ptr) -> !llvm.ptr, i32
          %35 = llvm.load %34 : !llvm.ptr -> i32
          %36 = llvm.getelementptr %32[2] : (!llvm.ptr) -> !llvm.ptr, i32
          %37 = llvm.load %36 : !llvm.ptr -> i32
          %38 = llvm.getelementptr %32[3] : (!llvm.ptr) -> !llvm.ptr, i32
          %39 = llvm.load %38 : !llvm.ptr -> i32
          %40 = llvm.zext %35 : i32 to i64
          %41 = llvm.shl %40, %15 : i64
          %42 = llvm.zext %33 : i32 to i64
          %43 = llvm.or %42, %41 : i64
          %44 = llvm.zext %39 : i32 to i64
          %45 = llvm.shl %44, %15 : i64
          %46 = llvm.zext %37 : i32 to i64
          %47 = llvm.or %46, %45 : i64
          %48 = llvm.extractvalue %31[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %49 = llvm.load %48 : !llvm.ptr -> !llvm.ptr
          %50 = llvm.mul %43, %11 : i64
          %51 = llvm.udiv %50, %15 : i64
          %52 = llvm.getelementptr %49[%51] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.intr.assume %10 ["align"(%52, %26 : !llvm.ptr, i64)] : i1
          %53 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)>
          %54 = llvm.extractvalue %53[10] : !llvm.struct<"iree_hal_executable_dispatch_state_v0_t", (i32, i32, i16, i16, i32, i32, i16, i8, i8, ptr, ptr, ptr)> 
          %55 = llvm.getelementptr %54[1] : (!llvm.ptr) -> !llvm.ptr, !llvm.ptr
          %56 = llvm.load %55 : !llvm.ptr -> !llvm.ptr
          llvm.intr.assume %10 ["align"(%56, %26 : !llvm.ptr, i64)] : i1
          %57 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)>
          %58 = llvm.extractvalue %57[0] : !llvm.struct<"iree_hal_executable_workgroup_state_v0_t", (i32, i32, i16, i16, i32, ptr, i32)> 
          %59 = llvm.zext %58 : i32 to i64
          %60 = llvm.mul %59, %26 overflow<nsw> : i64
          %61 = llvm.mul %59, %20 overflow<nsw> : i64
          %62 = llvm.add %61, %47 : i64
          %63 = llvm.icmp "slt" %62, %26 : i64
          %64 = llvm.select %63, %62, %26 : i1, i64
          %65 = llvm.icmp "sgt" %64, %28 : i64
          llvm.cond_br %65, ^bb1(%28 : i64), ^bb8
        ^bb1(%66: i64):  // 2 preds: ^bb0, ^bb7
          %67 = llvm.icmp "slt" %66, %64 : i64
          llvm.cond_br %67, ^bb2, ^bb8
        ^bb2:  // pred: ^bb1
          %68 = llvm.add %66, %60 : i64
          llvm.br ^bb3(%28 : i64)
        ^bb3(%69: i64):  // 2 preds: ^bb2, ^bb6
          %70 = llvm.icmp "slt" %69, %18 : i64
          llvm.cond_br %70, ^bb4(%28, %27 : i64, vector<1xf32>), ^bb7
        ^bb4(%71: i64, %72: vector<1xf32>):  // 2 preds: ^bb3, ^bb5
          %73 = llvm.icmp "slt" %71, %16 : i64
          llvm.cond_br %73, ^bb5, ^bb6
        ^bb5:  // pred: ^bb4
          %74 = llvm.mul %69, %16 : i64
          %75 = llvm.add %74, %71 : i64
          %76 = llvm.getelementptr %29[%75] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %77 = llvm.load %76 {alignment = 4 : i64} : !llvm.ptr -> vector<8xf32>
          %78 = llvm.extractelement %77[%9 : i64] : vector<8xf32>
          %79 = llvm.extractvalue %14[0] : !llvm.array<8 x vector<1xf32>> 
          %80 = llvm.insertelement %78, %79[%9 : i64] : vector<1xf32>
          %81 = llvm.extractelement %77[%8 : i64] : vector<8xf32>
          %82 = llvm.extractvalue %14[1] : !llvm.array<8 x vector<1xf32>> 
          %83 = llvm.insertelement %81, %82[%9 : i64] : vector<1xf32>
          %84 = llvm.extractelement %77[%7 : i64] : vector<8xf32>
          %85 = llvm.extractvalue %14[2] : !llvm.array<8 x vector<1xf32>> 
          %86 = llvm.insertelement %84, %85[%9 : i64] : vector<1xf32>
          %87 = llvm.extractelement %77[%6 : i64] : vector<8xf32>
          %88 = llvm.extractvalue %14[3] : !llvm.array<8 x vector<1xf32>> 
          %89 = llvm.insertelement %87, %88[%9 : i64] : vector<1xf32>
          %90 = llvm.extractelement %77[%5 : i64] : vector<8xf32>
          %91 = llvm.extractvalue %14[4] : !llvm.array<8 x vector<1xf32>> 
          %92 = llvm.insertelement %90, %91[%9 : i64] : vector<1xf32>
          %93 = llvm.extractelement %77[%4 : i64] : vector<8xf32>
          %94 = llvm.extractvalue %14[5] : !llvm.array<8 x vector<1xf32>> 
          %95 = llvm.insertelement %93, %94[%9 : i64] : vector<1xf32>
          %96 = llvm.extractelement %77[%3 : i64] : vector<8xf32>
          %97 = llvm.extractvalue %14[6] : !llvm.array<8 x vector<1xf32>> 
          %98 = llvm.insertelement %96, %97[%9 : i64] : vector<1xf32>
          %99 = llvm.extractelement %77[%2 : i64] : vector<8xf32>
          %100 = llvm.extractvalue %14[7] : !llvm.array<8 x vector<1xf32>> 
          %101 = llvm.insertelement %99, %100[%9 : i64] : vector<1xf32>
          %102 = llvm.mul %68, %16 overflow<nsw, nuw> : i64
          %103 = llvm.add %102, %71 overflow<nsw, nuw> : i64
          %104 = llvm.getelementptr inbounds|nuw %52[%103] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %105 = llvm.load %104 : !llvm.ptr -> f32
          %106 = llvm.insertelement %105, %1[%0 : i32] : vector<1xf32>
          %107 = llvm.intr.fmuladd(%80, %106, %72) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %108 = llvm.add %71, %19 : i64
          %109 = llvm.add %102, %108 overflow<nsw, nuw> : i64
          %110 = llvm.getelementptr inbounds|nuw %52[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %111 = llvm.load %110 : !llvm.ptr -> f32
          %112 = llvm.insertelement %111, %1[%0 : i32] : vector<1xf32>
          %113 = llvm.intr.fmuladd(%83, %112, %107) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %114 = llvm.add %71, %18 : i64
          %115 = llvm.add %102, %114 overflow<nsw, nuw> : i64
          %116 = llvm.getelementptr inbounds|nuw %52[%115] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %117 = llvm.load %116 : !llvm.ptr -> f32
          %118 = llvm.insertelement %117, %1[%0 : i32] : vector<1xf32>
          %119 = llvm.intr.fmuladd(%86, %118, %113) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %120 = llvm.add %71, %25 : i64
          %121 = llvm.add %102, %120 overflow<nsw, nuw> : i64
          %122 = llvm.getelementptr inbounds|nuw %52[%121] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %123 = llvm.load %122 : !llvm.ptr -> f32
          %124 = llvm.insertelement %123, %1[%0 : i32] : vector<1xf32>
          %125 = llvm.intr.fmuladd(%89, %124, %119) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %126 = llvm.add %71, %24 : i64
          %127 = llvm.add %102, %126 overflow<nsw, nuw> : i64
          %128 = llvm.getelementptr inbounds|nuw %52[%127] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %129 = llvm.load %128 : !llvm.ptr -> f32
          %130 = llvm.insertelement %129, %1[%0 : i32] : vector<1xf32>
          %131 = llvm.intr.fmuladd(%92, %130, %125) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %132 = llvm.add %71, %23 : i64
          %133 = llvm.add %102, %132 overflow<nsw, nuw> : i64
          %134 = llvm.getelementptr inbounds|nuw %52[%133] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %135 = llvm.load %134 : !llvm.ptr -> f32
          %136 = llvm.insertelement %135, %1[%0 : i32] : vector<1xf32>
          %137 = llvm.intr.fmuladd(%95, %136, %131) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %138 = llvm.add %71, %22 : i64
          %139 = llvm.add %102, %138 overflow<nsw, nuw> : i64
          %140 = llvm.getelementptr inbounds|nuw %52[%139] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %141 = llvm.load %140 : !llvm.ptr -> f32
          %142 = llvm.insertelement %141, %1[%0 : i32] : vector<1xf32>
          %143 = llvm.intr.fmuladd(%98, %142, %137) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %144 = llvm.add %71, %21 : i64
          %145 = llvm.add %102, %144 overflow<nsw, nuw> : i64
          %146 = llvm.getelementptr inbounds|nuw %52[%145] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %147 = llvm.load %146 : !llvm.ptr -> f32
          %148 = llvm.insertelement %147, %1[%0 : i32] : vector<1xf32>
          %149 = llvm.intr.fmuladd(%101, %148, %143) : (vector<1xf32>, vector<1xf32>, vector<1xf32>) -> vector<1xf32>
          %150 = llvm.add %71, %17 : i64
          llvm.br ^bb4(%150, %149 : i64, vector<1xf32>)
        ^bb6:  // pred: ^bb4
          %151 = llvm.getelementptr %30[%69] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %152 = llvm.load %151 {alignment = 4 : i64} : !llvm.ptr -> vector<1xf32>
          %153 = llvm.extractelement %72[%9 : i64] : vector<1xf32>
          %154 = llvm.extractelement %152[%9 : i64] : vector<1xf32>
          %155 = llvm.fadd %153, %154 {fastmathFlags = #llvm.fastmath<contract>} : f32
          %156 = llvm.mul %68, %18 overflow<nsw, nuw> : i64
          %157 = llvm.add %156, %69 overflow<nsw, nuw> : i64
          %158 = llvm.getelementptr inbounds|nuw %56[%157] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %155, %158 : f32, !llvm.ptr
          %159 = llvm.add %69, %19 : i64
          llvm.br ^bb3(%159 : i64)
        ^bb7:  // pred: ^bb3
          %160 = llvm.add %66, %19 : i64
          llvm.br ^bb1(%160 : i64)
        ^bb8:  // 2 preds: ^bb0, ^bb1
          llvm.return %0 : i32
        }
      }
    }
  }
  util.global private @__constant_tensor_32x10xf32 : !stream.resource<constant>
  util.initializer {
    %c0 = arith.constant 0 : index
    %c0_i64 = arith.constant 0 : i64
    %c5376 = arith.constant 5376 : index
    %0 = stream.timepoint.immediate => !stream.timepoint
    %buffer_cst = util.buffer.constant {alignment = 64 : index} : !util.buffer = #composite_of_5376b
    %did_map, %result = stream.resource.try_map on(#hal.device.affinity<@__device_0>) %buffer_cst[%c0] : !util.buffer -> i1, !stream.resource<constant>{%c5376}
    cf.cond_br %did_map, ^bb2(%0, %result : !stream.timepoint, !stream.resource<constant>), ^bb1
  ^bb1:  // pred: ^bb0
    %1 = stream.resource.alloc uninitialized on(#hal.device.affinity<@__device_0>) : !stream.resource<constant>{%c5376}
    %file = stream.file.constant on(#hal.device.affinity<@__device_0>) %buffer_cst[%c0 for %c5376] : !util.buffer{%c5376} -> !stream.file
    %2 = stream.file.read on(#hal.device.affinity<@__device_0>) await(%0) => %file[%c0_i64], %1[%c0], %c5376 : !stream.file -> !stream.resource<constant>{%c5376} => !stream.timepoint
    cf.br ^bb2(%2, %1 : !stream.timepoint, !stream.resource<constant>)
  ^bb2(%3: !stream.timepoint, %4: !stream.resource<constant>):  // 2 preds: ^bb0, ^bb1
    %5 = stream.timepoint.await sync %3 => %4 : !stream.resource<constant>{%c5376}
    util.global.store %5, @__constant_tensor_32x10xf32 : !stream.resource<constant>
    util.return
  }
  util.func public @main_graph$async(%arg0: !hal.buffer_view, %arg1: !hal.fence, %arg2: !hal.fence) -> !hal.buffer_view attributes {inlining_policy = #util.inline.never, iree.abi.model = "coarse-fences", iree.abi.stub} {
    %c5376 = arith.constant 5376 : index
    %c10 = arith.constant 10 : index
    %c40 = arith.constant 40 : index
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c8 = arith.constant 8 : index
    %c32_i64 = arith.constant 32 : i64
    %__constant_tensor_32x10xf32 = util.global.load immutable @__constant_tensor_32x10xf32 : !stream.resource<constant>
    %0 = hal.buffer_view.dim<%arg0 : !hal.buffer_view>[0] : index
    %element_type_f32 = hal.element_type<f32> : i32
    %dense_row_major = hal.encoding_type<dense_row_major> : i32
    hal.buffer_view.assert<%arg0 : !hal.buffer_view> message("tensor") shape([%0, %c10]) type(%element_type_f32) encoding(%dense_row_major)
    %1 = arith.muli %0, %c40 : index
    %2 = stream.tensor.import on(#hal.device.affinity<@__device_0>) %arg0 : !hal.buffer_view -> tensor<?x10xf32>{%0} in !stream.resource<external>{%1}
    %3 = stream.timepoint.import on(#hal.device.affinity<@__device_0>) %arg1 : (!hal.fence) => !stream.timepoint
    %4 = arith.muli %0, %c128 : index
    %5 = arith.muli %0, %c8 : index
    %result, %result_timepoint = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) await(%3) => !stream.resource<external>{%5} => !stream.timepoint
    %6 = arith.addi %4, %4 : index
    %result_0, %result_timepoint_1 = stream.resource.alloca uninitialized on(#hal.device.affinity<@__device_0>) await(%3) => !stream.resource<transient>{%6} => !stream.timepoint
    %7 = stream.timepoint.join max(%result_timepoint, %result_timepoint_1) => !stream.timepoint
    %8 = arith.index_castui %0 : index to i64
    %9 = arith.index_castui %0 : index to i32
    %10 = arith.shrui %8, %c32_i64 : i64
    %11 = arith.trunci %10 : i64 to i32
    %12 = arith.index_castui %4 : index to i64
    %13 = arith.index_castui %4 : index to i32
    %14 = arith.shrui %12, %c32_i64 : i64
    %15 = arith.trunci %14 : i64 to i32
    %16 = stream.cmd.execute on(#hal.device.affinity<@__device_0>) await(%7) => with(%2 as %arg3: !stream.resource<external>{%1}, %__constant_tensor_32x10xf32 as %arg4: !stream.resource<constant>{%c5376}, %result as %arg5: !stream.resource<external>{%5}, %result_0 as %arg6: !stream.resource<transient>{%6}) {
      stream.cmd.dispatch @main_graph$async_dispatch_0::@system_elf_x86_64::@main_graph$async_dispatch_0_matmul_like_Dx32x10_f32[%0](%9, %11 : i32, i32) {
        ro %arg3[%c0 for %1] : !stream.resource<external>{%1},
        ro %arg4[%c0 for %c5376] : !stream.resource<constant>{%c5376},
        wo %arg6[%c0 for %6] : !stream.resource<transient>{%6}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_1::@system_elf_x86_64::@main_graph$async_dispatch_1_matmul_like_Dx32x32_f32[%0](%13, %15, %9, %11 : i32, i32, i32, i32) {
        ro %arg6[%c0 for %6] : !stream.resource<transient>{%6},
        ro %arg4[%c0 for %c5376] : !stream.resource<constant>{%c5376},
        wo %arg6[%c0 for %6] : !stream.resource<transient>{%6}
      }
      stream.cmd.dispatch @main_graph$async_dispatch_2::@system_elf_x86_64::@main_graph$async_dispatch_2_matmul_like_Dx2x32_f32[%0](%13, %15, %9, %11 : i32, i32, i32, i32) {
        ro %arg6[%c0 for %6] : !stream.resource<transient>{%6},
        wo %arg5[%c0 for %5] : !stream.resource<external>{%5}
      }
    } => !stream.timepoint
    %17 = stream.resource.dealloca on(#hal.device.affinity<@__device_0>) await(%16) => %result_0 : !stream.resource<transient>{%6} => !stream.timepoint
    stream.timepoint.chain_external on(#hal.device.affinity<@__device_0>) %17 => (%arg2 : !hal.fence)
    %18 = stream.tensor.export on(#hal.device.affinity<@__device_0>) %result : tensor<?x2xf32>{%0} in !stream.resource<external>{%5} -> !hal.buffer_view
    util.return %18 : !hal.buffer_view
  }
  util.func public @main_graph(%arg0: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub} {
    %0 = util.null : !hal.fence
    %c-1_i32 = arith.constant -1 : i32
    %c0 = arith.constant 0 : index
    %device_0 = hal.devices.get %c0 : !hal.device
    %fence = hal.fence.create device(%device_0 : !hal.device) flags("None") : !hal.fence
    %1 = util.call @main_graph$async(%arg0, %0, %fence) : (!hal.buffer_view, !hal.fence, !hal.fence) -> !hal.buffer_view
    %status = hal.fence.await until([%fence]) timeout_millis(%c-1_i32) flags("None") : i32
    util.return %1 : !hal.buffer_view
  }
}
